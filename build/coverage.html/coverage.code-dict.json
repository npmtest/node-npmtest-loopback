{"/home/travis/build/npmtest/node-npmtest-loopback/test.js":"/* istanbul instrument in package npmtest_loopback */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-loopback/lib.npmtest_loopback.js":"/* istanbul instrument in package npmtest_loopback */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_loopback = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_loopback = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-loopback/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-loopback && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_loopback */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_loopback\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_loopback.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_loopback.rollup.js'] =\n            local.assetsDict['/assets.npmtest_loopback.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_loopback.__dirname + '/lib.npmtest_loopback.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/index.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n/**\n * loopback ~ public api\n */\n\nconst loopback = module.exports = require('./lib/loopback');\nconst datasourceJuggler = require('loopback-datasource-juggler');\n\n/**\n * Connectors\n */\n\nloopback.Connector = require('./lib/connectors/base-connector');\nloopback.Memory = require('./lib/connectors/memory');\nloopback.Mail = require('./lib/connectors/mail');\nloopback.Remote = require('loopback-connector-remote');\n\n/**\n * Types\n */\n\nloopback.GeoPoint = require('loopback-datasource-juggler/lib/geo').GeoPoint;\nloopback.ValidationError = loopback.Model.ValidationError;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/loopback.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module dependencies.\n */\n\n'use strict';\nvar express = require('express');\nvar loopbackExpress = require('./server-app');\nvar proto = require('./application');\nvar fs = require('fs');\nvar ejs = require('ejs');\nvar path = require('path');\nvar merge = require('util')._extend;\nvar assert = require('assert');\nvar Registry = require('./registry');\nvar juggler = require('loopback-datasource-juggler');\n\n/**\n * LoopBack core module. It provides static properties and\n * methods to create models and data sources. The module itself is a function\n * that creates loopback `app`. For example:\n *\n * ```js\n * var loopback = require('loopback');\n * var app = loopback();\n * ```\n *\n * @property {String} version Version of LoopBack framework.  Static read-only property.\n * @property {Boolean} isBrowser True if running in a browser environment; false otherwise.  Static read-only property.\n * @property {Boolean} isServer True if running in a server environment; false otherwise.  Static read-only property.\n * @property {Registry} registry The global `Registry` object.\n * @property {String} faviconFile Path to a default favicon shipped with LoopBack.\n * Use as follows: `app.use(require('serve-favicon')(loopback.faviconFile));`\n * @class loopback\n * @header loopback\n */\n\nvar loopback = module.exports = createApplication;\n\n/*!\n * Framework version.\n */\n\nloopback.version = require('../package.json').version;\n\nloopback.registry = new Registry();\n\nObject.defineProperties(loopback, {\n  Model: {\n    get: function() { return this.registry.getModel('Model'); },\n  },\n  PersistedModel: {\n    get: function() { return this.registry.getModel('PersistedModel'); },\n  },\n  defaultDataSources: {\n    get: function() { return this.registry.defaultDataSources; },\n  },\n  modelBuilder: {\n    get: function() { return this.registry.modelBuilder; },\n  },\n});\n\n/*!\n * Create an loopback application.\n *\n * @return {Function}\n * @api public\n */\n\nfunction createApplication(options) {\n  var app = loopbackExpress();\n\n  merge(app, proto);\n\n  app.loopback = loopback;\n\n  // Create a new instance of models registry per each app instance\n  app.models = function() {\n    return proto.models.apply(this, arguments);\n  };\n\n  // Create a new instance of datasources registry per each app instance\n  app.datasources = app.dataSources = {};\n\n  // Create a new instance of connector registry per each app instance\n  app.connectors = {};\n\n  // Register built-in connectors. It's important to keep this code\n  // hand-written, so that all require() calls are static\n  // and thus browserify can process them (include connectors in the bundle)\n  app.connector('memory', loopback.Memory);\n  app.connector('remote', loopback.Remote);\n  app.connector('kv-memory',\n    require('loopback-datasource-juggler/lib/connectors/kv-memory'));\n\n  if (loopback.localRegistry || options && options.localRegistry === true) {\n    // setup the app registry\n    var registry = app.registry = new Registry();\n    if (options && options.loadBuiltinModels === true) {\n      require('./builtin-models')(registry);\n    }\n  } else {\n    app.registry = loopback.registry;\n  }\n\n  return app;\n}\n\nfunction mixin(source) {\n  for (var key in source) {\n    var desc = Object.getOwnPropertyDescriptor(source, key);\n\n    // Fix for legacy (pre-ES5) browsers like PhantomJS\n    if (!desc) continue;\n\n    Object.defineProperty(loopback, key, desc);\n  }\n}\n\nmixin(require('./runtime'));\n\n/*!\n * Expose static express methods like `express.Router`.\n */\n\nmixin(express);\n\n/*!\n * Expose additional loopback middleware\n * for example `loopback.configure` etc.\n *\n * ***only in node***\n */\n\nif (loopback.isServer) {\n  fs\n    .readdirSync(path.join(__dirname, '..', 'server', 'middleware'))\n    .filter(function(file) {\n      return file.match(/\\.js$/);\n    })\n    .forEach(function(m) {\n      loopback[m.replace(/\\.js$/, '')] = require('../server/middleware/' + m);\n    });\n\n  loopback.urlNotFound = loopback['url-not-found'];\n  delete loopback['url-not-found'];\n\n  loopback.errorHandler = loopback['error-handler'];\n  delete loopback['error-handler'];\n}\n\n// Expose path to the default favicon file\n// ***only in node***\n\nif (loopback.isServer) {\n  /*!\n   * Path to a default favicon shipped with LoopBack.\n   *\n   * **Example**\n   *\n   * ```js\n   * app.use(require('serve-favicon')(loopback.faviconFile));\n   * ```\n   */\n  loopback.faviconFile = path.resolve(__dirname, '../favicon.ico');\n}\n\n/**\n * Add a remote method to a model.\n * @param {Function} fn\n * @param {Object} options (optional)\n */\n\nloopback.remoteMethod = function(fn, options) {\n  fn.shared = true;\n  if (typeof options === 'object') {\n    Object.keys(options).forEach(function(key) {\n      fn[key] = options[key];\n    });\n  }\n  fn.http = fn.http || {verb: 'get'};\n};\n\n/**\n * Create a template helper.\n *\n *     var render = loopback.template('foo.ejs');\n *     var html = render({foo: 'bar'});\n *\n * @param {String} path Path to the template file.\n * @returns {Function}\n */\n\nloopback.template = function(file) {\n  var templates = this._templates || (this._templates = {});\n  var str = templates[file] || (templates[file] = fs.readFileSync(file, 'utf8'));\n  return ejs.compile(str, {\n    filename: file,\n  });\n};\n\nrequire('../lib/current-context')(loopback);\n\n/**\n * Create a named vanilla JavaScript class constructor with an attached\n * set of properties and options.\n *\n * This function comes with two variants:\n *  * `loopback.createModel(name, properties, options)`\n *  * `loopback.createModel(config)`\n *\n * In the second variant, the parameters `name`, `properties` and `options`\n * are provided in the config object. Any additional config entries are\n * interpreted as `options`, i.e. the following two configs are identical:\n *\n * ```js\n * { name: 'Customer', base: 'User' }\n * { name: 'Customer', options: { base: 'User' } }\n * ```\n *\n * **Example**\n *\n * Create an `Author` model using the three-parameter variant:\n *\n * ```js\n * loopback.createModel(\n *   'Author',\n *   {\n *     firstName: 'string',\n *     lastName: 'string'\n *   },\n *   {\n *     relations: {\n *       books: {\n *         model: 'Book',\n *         type: 'hasAndBelongsToMany'\n *       }\n *     }\n *   }\n * );\n * ```\n *\n * Create the same model using a config object:\n *\n * ```js\n * loopback.createModel({\n *   name: 'Author',\n *   properties: {\n *     firstName: 'string',\n *     lastName: 'string'\n *   },\n *   relations: {\n *     books: {\n *       model: 'Book',\n *       type: 'hasAndBelongsToMany'\n *     }\n *   }\n * });\n * ```\n *\n * @param {String} name Unique name.\n * @param {Object} properties\n * @param {Object} options (optional)\n *\n * @header loopback.createModel\n */\n\nloopback.createModel = function(name, properties, options) {\n  return this.registry.createModel.apply(this.registry, arguments);\n};\n\n/**\n * Alter an existing Model class.\n * @param {Model} ModelCtor The model constructor to alter.\n * @options {Object} config Additional configuration to apply\n * @property {DataSource} dataSource Attach the model to a dataSource.\n * @property {Object} [relations] Model relations to add/update.\n *\n * @header loopback.configureModel(ModelCtor, config)\n */\n\nloopback.configureModel = function(ModelCtor, config) {\n  return this.registry.configureModel.apply(this.registry, arguments);\n};\n\n/**\n * Look up a model class by name from all models created by\n * `loopback.createModel()`\n * @param {String} modelName The model name\n * @returns {Model} The model class\n *\n * @header loopback.findModel(modelName)\n */\nloopback.findModel = function(modelName) {\n  return this.registry.findModel.apply(this.registry, arguments);\n};\n\n/**\n * Look up a model class by name from all models created by\n * `loopback.createModel()`. Throw an error when no such model exists.\n *\n * @param {String} modelName The model name\n * @returns {Model} The model class\n *\n * @header loopback.getModel(modelName)\n */\nloopback.getModel = function(modelName) {\n  return this.registry.getModel.apply(this.registry, arguments);\n};\n\n/**\n * Look up a model class by the base model class.\n * The method can be used by LoopBack\n * to find configured models in models.json over the base model.\n * @param {Model} modelType The base model class\n * @returns {Model} The subclass if found or the base class\n *\n * @header loopback.getModelByType(modelType)\n */\nloopback.getModelByType = function(modelType) {\n  return this.registry.getModelByType.apply(this.registry, arguments);\n};\n\n/**\n * Create a data source with passing the provided options to the connector.\n *\n * @param {String} name Optional name.\n * @options {Object} options Data Source options\n * @property {Object} connector LoopBack connector.\n * @property {*} [*] Other&nbsp;connector properties.\n *   See the relevant connector documentation.\n */\n\nloopback.createDataSource = function(name, options) {\n  return this.registry.createDataSource.apply(this.registry, arguments);\n};\n\n/**\n * Get an in-memory data source. Use one if it already exists.\n *\n * @param {String} [name] The name of the data source.\n * If not provided, the `'default'` is used.\n */\n\nloopback.memory = function(name) {\n  return this.registry.memory.apply(this.registry, arguments);\n};\n/*!\n * Built in models / services\n */\n\nrequire('./builtin-models')(loopback);\n\nloopback.DataSource = juggler.DataSource;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/server-app.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('./globalize');\nvar assert = require('assert');\nvar express = require('express');\nvar merge = require('util')._extend;\nvar mergePhaseNameLists = require('loopback-phase').mergePhaseNameLists;\nvar debug = require('debug')('loopback:app');\nvar stableSortInPlace = require('stable').inplace;\n\nvar BUILTIN_MIDDLEWARE = {builtin: true};\n\nvar proto = {};\n\nmodule.exports = function loopbackExpress() {\n  var app = express();\n  app.__expressLazyRouter = app.lazyrouter;\n  merge(app, proto);\n  return app;\n};\n\n/**\n * Register a middleware using a factory function and a JSON config.\n *\n * **Example**\n *\n * ```js\n * app.middlewareFromConfig(compression, {\n *   enabled: true,\n *   phase: 'initial',\n *   params: {\n *     threshold: 128\n *   }\n * });\n * ```\n *\n * @param {function} factory The factory function creating a middleware handler.\n *   Typically a result of `require()` call, e.g. `require('compression')`.\n * @options {Object} config The configuration.\n * @property {String} phase The phase to register the middleware in.\n * @property {Boolean} [enabled] Whether the middleware is enabled.\n *   Default: `true`.\n * @property {Array|*} [params] The arguments to pass to the factory\n *   function. Either an array of arguments,\n *   or the value of the first argument when the factory expects\n *   a single argument only.\n * @property {Array|string|RegExp} [paths] Optional list of paths limiting\n *   the scope of the middleware.\n *\n * @returns {object} this (fluent API)\n *\n * @header app.middlewareFromConfig(factory, config)\n */\nproto.middlewareFromConfig = function(factory, config) {\n  assert(typeof factory === 'function', '\"factory\" must be a function');\n  assert(typeof config === 'object', '\"config\" must be an object');\n  assert(typeof config.phase === 'string' && config.phase,\n    '\"config.phase\" must be a non-empty string');\n\n  if (config.enabled === false)\n    return;\n\n  var params = config.params;\n  if (params === undefined) {\n    params = [];\n  } else if (!Array.isArray(params)) {\n    params = [params];\n  }\n\n  var handler = factory.apply(null, params);\n\n  // Check if methods/verbs filter exists\n  var verbs = config.methods || config.verbs;\n  if (Array.isArray(verbs)) {\n    verbs = verbs.map(function(verb) {\n      return verb && verb.toUpperCase();\n    });\n    if (verbs.indexOf('ALL') === -1) {\n      var originalHandler = handler;\n      if (handler.length <= 3) {\n        // Regular handler\n        handler = function(req, res, next) {\n          if (verbs.indexOf(req.method.toUpperCase()) === -1) {\n            return next();\n          }\n          originalHandler(req, res, next);\n        };\n      } else {\n        // Error handler\n        handler = function(err, req, res, next) {\n          if (verbs.indexOf(req.method.toUpperCase()) === -1) {\n            return next(err);\n          }\n          originalHandler(err, req, res, next);\n        };\n      }\n    }\n  }\n  this.middleware(config.phase, config.paths || [], handler);\n\n  return this;\n};\n\n/**\n * Register (new) middleware phases.\n *\n * If all names are new, then the phases are added just before \"routes\" phase.\n * Otherwise the provided list of names is merged with the existing phases\n * in such way that the order of phases is preserved.\n *\n * **Examples**\n *\n * ```js\n * // built-in phases:\n * // initial, session, auth, parse, routes, files, final\n *\n * app.defineMiddlewarePhases('custom');\n * // new list of phases\n * // initial, session, auth, parse, custom, routes, files, final\n *\n * app.defineMiddlewarePhases([\n *   'initial', 'postinit', 'preauth', 'routes', 'subapps'\n * ]);\n * // new list of phases\n * // initial, postinit, preauth, session, auth, parse, custom,\n * // routes, subapps, files, final\n * ```\n *\n * @param {string|Array.<string>} nameOrArray A phase name or a list of phase\n *   names to add.\n *\n * @returns {object} this (fluent API)\n *\n * @header app.defineMiddlewarePhases(nameOrArray)\n */\nproto.defineMiddlewarePhases = function(nameOrArray) {\n  this.lazyrouter();\n\n  if (Array.isArray(nameOrArray)) {\n    this._requestHandlingPhases =\n      mergePhaseNameLists(this._requestHandlingPhases, nameOrArray);\n  } else {\n    // add the new phase before 'routes'\n    var routesIx = this._requestHandlingPhases.indexOf('routes');\n    this._requestHandlingPhases.splice(routesIx - 1, 0, nameOrArray);\n  }\n\n  return this;\n};\n\n/**\n * Register a middleware handler to be executed in a given phase.\n * @param {string} name The phase name, e.g. \"init\" or \"routes\".\n * @param {Array|string|RegExp} [paths] Optional list of paths limiting\n *   the scope of the middleware.\n *   String paths are interpreted as expressjs path patterns,\n *   regular expressions are used as-is.\n * @param {function} handler The middleware handler, one of\n *   `function(req, res, next)` or\n *   `function(err, req, res, next)`\n * @returns {object} this (fluent API)\n *\n * @header app.middleware(name, handler)\n */\nproto.middleware = function(name, paths, handler) {\n  this.lazyrouter();\n\n  if (handler === undefined && typeof paths === 'function') {\n    handler = paths;\n    paths = undefined;\n  }\n\n  assert(typeof name === 'string' && name, '\"name\" must be a non-empty string');\n  assert(typeof handler === 'function', '\"handler\" must be a function');\n\n  if (paths === undefined) {\n    paths = '/';\n  }\n\n  var fullPhaseName = name;\n  var handlerName = handler.name || '<anonymous>';\n\n  var m = name.match(/^(.+):(before|after)$/);\n  if (m) {\n    name = m[1];\n  }\n\n  if (this._requestHandlingPhases.indexOf(name) === -1)\n    throw new Error(g.f('Unknown {{middleware}} phase %s', name));\n\n  debug('use %s %s %s', fullPhaseName, paths, handlerName);\n\n  this._skipLayerSorting = true;\n  this.use(paths, handler);\n\n  var layer = this._findLayerByHandler(handler);\n  if (layer) {\n    // Set the phase name for sorting\n    layer.phase = fullPhaseName;\n  } else {\n    debug('No matching layer is found for %s %s', fullPhaseName, handlerName);\n  }\n\n  this._skipLayerSorting = false;\n\n  this._sortLayersByPhase();\n\n  return this;\n};\n\n/*!\n * Find the corresponding express layer by handler\n *\n * This is needed because monitoring agents such as NewRelic can add handlers\n * to the stack. For example, NewRelic adds sentinel handler. We need to search\n * the stackto find the correct layer.\n */\nproto._findLayerByHandler = function(handler) {\n  // Other handlers can be added to the stack, for example,\n  // NewRelic adds sentinel handler. We need to search the stack\n  for (var k = this._router.stack.length - 1; k >= 0; k--) {\n    if (this._router.stack[k].handle === handler ||\n      // NewRelic replaces the handle and keeps it as __NR_original\n      this._router.stack[k].handle['__NR_original'] === handler\n      ) {\n      return this._router.stack[k];\n    } else {\n      // Aggressively check if the original handler has been wrapped\n      // into a new function with a property pointing to the original handler\n      for (var p in this._router.stack[k].handle) {\n        if (this._router.stack[k].handle[p] === handler) {\n          return this._router.stack[k];\n        }\n      }\n    }\n  }\n  return null;\n};\n\n// Install our custom PhaseList-based handler into the app\nproto.lazyrouter = function() {\n  var self = this;\n  if (self._router) return;\n\n  self.__expressLazyRouter();\n\n  var router = self._router;\n\n  // Mark all middleware added by Router ctor as builtin\n  // The sorting algo will keep them at beginning of the list\n  router.stack.forEach(function(layer) {\n    layer.phase = BUILTIN_MIDDLEWARE;\n  });\n\n  router.__expressUse = router.use;\n  router.use = function useAndSort() {\n    var retval = this.__expressUse.apply(this, arguments);\n    self._sortLayersByPhase();\n    return retval;\n  };\n\n  router.__expressRoute = router.route;\n  router.route = function routeAndSort() {\n    var retval = this.__expressRoute.apply(this, arguments);\n    self._sortLayersByPhase();\n    return retval;\n  };\n\n  self._requestHandlingPhases = [\n    'initial', 'session', 'auth', 'parse',\n    'routes', 'files', 'final',\n  ];\n};\n\nproto._sortLayersByPhase = function() {\n  if (this._skipLayerSorting) return;\n\n  var phaseOrder = {};\n  this._requestHandlingPhases.forEach(function(name, ix) {\n    phaseOrder[name + ':before'] = ix * 3;\n    phaseOrder[name] = ix * 3 + 1;\n    phaseOrder[name + ':after'] = ix * 3 + 2;\n  });\n\n  var router = this._router;\n  stableSortInPlace(router.stack, compareLayers);\n\n  function compareLayers(left, right) {\n    var leftPhase = left.phase;\n    var rightPhase = right.phase;\n\n    if (leftPhase === rightPhase) return 0;\n\n    // Builtin middleware is always first\n    if (leftPhase === BUILTIN_MIDDLEWARE) return -1;\n    if (rightPhase === BUILTIN_MIDDLEWARE) return 1;\n\n    // Layers registered via app.use and app.route\n    // are executed as the first items in `routes` phase\n    if (leftPhase === undefined) {\n      if (rightPhase === 'routes')\n        return -1;\n\n      return phaseOrder['routes'] - phaseOrder[rightPhase];\n    }\n\n    if (rightPhase === undefined)\n      return -compareLayers(right, left);\n\n    // Layers registered via `app.middleware` are compared via phase & hook\n    return phaseOrder[leftPhase] - phaseOrder[rightPhase];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/globalize.js":"// Copyright IBM Corp. 2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar path = require('path');\nvar SG = require('strong-globalize');\n\nSG.SetRootDir(path.join(__dirname, '..'), {autonomousMsgLoading: 'all'});\nmodule.exports = SG();\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-phase/index.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback-phase\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar SG = require('strong-globalize');\nSG.SetRootDir(__dirname);\n\nexports.PhaseList = require('./lib/phase-list');\nexports.Phase = require('./lib/phase');\nexports.mergePhaseNameLists = require('./lib/merge-name-lists');\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-phase/lib/phase-list.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-phase\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar g = require('strong-globalize')();\n\nvar Phase = require('./phase');\nvar zipMerge = require('./merge-name-lists');\nvar async = require('async');\n\nmodule.exports = PhaseList;\n\n/**\n * An ordered list of phases.\n *\n * ```js\n * var PhaseList = require('loopback-phase').PhaseList;\n * var phases = new PhaseList();\n * phases.add('my-phase');\n * ```\n *\n * @class PhaseList\n */\n\nfunction PhaseList() {\n  this._phases = [];\n  this._phaseMap = {};\n}\n\n/**\n * Get the first `Phase` in the list.\n *\n * @returns {Phase} The first phase.\n */\n\nPhaseList.prototype.first = function() {\n  return this._phases[0];\n};\n\n/**\n * Get the last `Phase` in the list.\n *\n * @returns {Phase} The last phase.\n */\n\nPhaseList.prototype.last = function() {\n  return this._phases[this._phases.length - 1];\n};\n\n/**\n * Add one or more phases to the list.\n *\n * @param {Phase|String|String[]} phase The phase (or phases) to be added.\n * @returns {Phase|Phase[]} The added phase or phases.\n */\n\nPhaseList.prototype.add = function(phase) {\n  var phaseList = this;\n  var phaseArray = Array.isArray(phase) ? phase : null;\n\n  if(phaseArray) {\n    return phaseArray.map(phaseList.add.bind(phaseList));\n  }\n\n  phase = this._resolveNameAndAddToMap(phase);\n  this._phases.push(phase);\n\n  return phase;\n};\n\nPhaseList.prototype._resolveNameAndAddToMap = function(phaseOrName) {\n  var phase = phaseOrName;\n\n  if(typeof phase === 'string') {\n    phase = new Phase(phase);\n  }\n\n  if (phase.id in this._phaseMap) {\n    throw new Error(g.f('Phase \"%s\" already exists.', phase.id));\n  }\n\n\n  if(!phase.__isPhase__) {\n    throw new Error(g.f('Cannot add a non phase object to a {{PhaseList}}'));\n  }\n\n  this._phaseMap[phase.id] = phase;\n  return phase;\n};\n\n/**\n * Add a new phase at the specified index.\n * @param {Number} index The zero-based index.\n * @param {String|String[]} phase The name of the phase to add.\n * @returns {Phase} The added phase.\n */\n\nPhaseList.prototype.addAt = function(index, phase) {\n  phase = this._resolveNameAndAddToMap(phase);\n  this._phases.splice(index, 0, phase);\n  return phase;\n};\n\n/**\n * Add a new phase as the next one after the given phase.\n * @param {String} after The referential phase.\n * @param {String|String[]} phase The name of the phase to add.\n * @returns {Phase} The added phase.\n */\n\nPhaseList.prototype.addAfter = function(after, phase) {\n  var ix = this.getPhaseNames().indexOf(after);\n  if (ix === -1) {\n    throw new Error(g.f('Unknown phase: %s', after));\n  }\n  return this.addAt(ix+1, phase);\n};\n\n/**\n * Add a new phase as the previous one before the given phase.\n * @param {String} before The referential phase.\n * @param {String|String[]} phase The name of the phase to add.\n * @returns {Phase} The added phase.\n */\n\nPhaseList.prototype.addBefore = function(before, phase) {\n  var ix = this.getPhaseNames().indexOf(before);\n  if (ix === -1) {\n    throw new Error(g.f('Unknown phase: %s', before));\n  }\n  return this.addAt(ix, phase);\n};\n\n/**\n * Remove a `Phase` from the list.\n *\n * @param {Phase|String} phase The phase to be removed.\n * @returns {Phase} The removed phase.\n */\n\nPhaseList.prototype.remove = function(phase) {\n  var phases = this._phases;\n  var phaseMap = this._phaseMap;\n  var phaseId;\n\n  if(!phase) return null;\n\n  if(typeof phase === 'object') {\n    phaseId = phase.id;\n  } else {\n    phaseId = phase;\n    phase = phaseMap[phaseId];\n  }\n\n  if(!phase || !phase.__isPhase__) return null;\n\n  phases.splice(phases.indexOf(phase), 1);\n  delete this._phaseMap[phaseId];\n\n  return phase;\n};\n\n/**\n * Merge the provided list of names with the existing phases\n * in such way that the order of phases is preserved.\n *\n * **Example**\n *\n * ```js\n * // Initial list of phases\n * phaseList.add(['initial', 'session', 'auth', 'routes', 'files', 'final']);\n *\n * // zip-merge more phases\n * phaseList.zipMerge([\n *   'initial', 'postinit', 'preauth', 'auth',\n *   'routes', 'subapps', 'final', 'last'\n * ]);\n *\n * // print the result\n * console.log('Result:', phaseList.getPhaseNames());\n * // Result: [\n * //   'initial', 'postinit', 'preauth', 'session', 'auth',\n * //   'routes', 'subapps', 'files', 'final', 'last'\n * // ]\n * ```\n *\n * @param {String[]} names List of phase names to zip-merge\n */\nPhaseList.prototype.zipMerge = function(names) {\n  if (!names.length) return;\n\n  var mergedNames = zipMerge(this.getPhaseNames(), names);\n  this._phases = mergedNames.map(function(name) {\n    var existing = this.find(name);\n    return existing ?\n      existing :\n      this._resolveNameAndAddToMap(name);\n  }, this);\n};\n\n/**\n * Find a `Phase` from the list.\n *\n * @param {String} id The phase identifier\n * @returns {Phase} The `Phase` with the given `id`.\n */\n\nPhaseList.prototype.find = function(id) {\n  return this._phaseMap[id] || null;\n};\n\n/**\n * Find or add a `Phase` from/into the list.\n *\n * @param {String} id The phase identifier\n * @returns {Phase} The `Phase` with the given `id`.\n */\n\nPhaseList.prototype.findOrAdd = function(id) {\n  var phase = this.find(id);\n  if(phase) return phase;\n  return this.add(id);\n};\n\n/**\n * Get the list of phases as an array of `Phase` objects.\n *\n * @returns {Phase[]} An array of phases.\n */\n\nPhaseList.prototype.toArray = function() {\n  return this._phases.slice(0);\n};\n\n/**\n * Launch the phases contained in the list. If there are no phases\n * in the list `process.nextTick` is called with the provided callback.\n *\n * @param {Object} [context] The context of each `Phase` handler.\n * @callback {Function} cb\n * @param {Error} err Any error that occured during a phase contained\n * in the list.\n */\n\nPhaseList.prototype.run = function(ctx, cb) {\n  var phases = this._phases;\n\n  if(typeof ctx === 'function') {\n    cb = ctx;\n    ctx = undefined;\n  }\n\n  if(phases.length) {\n    async.eachSeries(phases, function(phase, next) {\n      phase.run(ctx, next);\n    }, cb);\n  } else {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Get an array of phase identifiers.\n * @returns {String[]} phaseNames\n */\n\nPhaseList.prototype.getPhaseNames = function() {\n  return this._phases.map(function(phase) {\n    return phase.id;\n  });\n};\n\n/**\n * Register a phase handler for the given phase (and sub-phase).\n *\n * **Example**\n *\n * ```js\n * // register via phase.use()\n * phaseList.registerHandler('routes', function(ctx, next) { next(); });\n * // register via phase.before()\n * phaseList.registerHandler('auth:before', function(ctx, next) { next(); });\n * // register via phase.after()\n * phaseList.registerHandler('auth:after', function(ctx, next) { next(); });\n * ```\n *\n * @param {String} phaseName Name of an existing phase, optionally with\n *   \":before\" or \":after\" suffix.\n * @param {Function(Object, Function)} handler The handler function to register\n *   with the given phase.\n */\nPhaseList.prototype.registerHandler = function(phaseName, handler) {\n  var subphase = 'use';\n  var m = phaseName.match(/^(.+):(before|after)$/);\n  if (m) {\n    phaseName = m[1];\n    subphase = m[2];\n  }\n  var phase = this.find(phaseName);\n  if (!phase) throw new Error(g.f('Unknown phase %s', phaseName));\n  phase[subphase](handler);\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-phase/lib/phase.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback-phase\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar async = require('async');\n\nmodule.exports = Phase;\n\n/**\n * A slice of time in an application. Provides hooks to allow\n * functions to be executed before, during and after, the defined slice.\n * Handlers can be registered to a phase using `before()`, `use()`, or `after()`\n * so that they are placed into one of the three stages.\n *\n * ```js\n * var Phase = require('loopback-phase').Phase;\n *\n * // Create a phase without id\n * var anonymousPhase = new Phase();\n *\n * // Create a named phase\n * var myPhase1 = new Phase('my-phase');\n *\n * // Create a named phase with id & options\n * var myPhase2 = new Phase('my-phase', {parallel: true});\n *\n * // Create a named phase with options only\n * var myPhase3 = new Phase({id: 'my-phase', parallel: true});\n *\n * ```\n *\n * @class Phase\n *\n * @prop {String} id The name or identifier of the `Phase`.\n * @prop {Object} options The options to configure the `Phase`\n *\n * @param {String} [id] The name or identifier of the `Phase`.\n * @options {Object} [options] Options for the `Phase`\n * @property {String} [id] The name or identifier of the Phase\n * @property {Boolean} [parallel] To execute handlers in the same stage\n * in parallel\n * @end\n */\n\nfunction Phase(id, options) {\n  if (typeof id === 'object' && options === undefined) {\n    options = id;\n    id = options.id;\n  }\n  this.id = id;\n  this.options = options || {};\n  this.handlers = [];\n  this.beforeHandlers = [];\n  this.afterHandlers = [];\n}\n\n/**\n * Register a phase handler. The handler will be executed\n * once the phase is launched. Handlers must callback once\n * complete. If the handler calls back with an error, the phase will immediately\n * halt execution and call the callback provided to\n * `phase.run(callback)`.\n *\n * **Example**\n *\n * ```js\n * phase.use(function(ctx, next) {\n *   // specify an error if one occurred...\n *   var err = null;\n *   console.log(ctx.message, 'world!'); // => hello world\n *   next(err);\n * });\n *\n * phase.run({message: 'hello'}, function(err) {\n *   if(err) return console.error('phase has errored', err);\n *   console.log('phase has finished');\n * });\n * ```\n */\n\nPhase.prototype.use = function(handler) {\n  this.handlers.push(handler);\n  return this;\n};\n\n/**\n * Register a phase handler to be executed before the phase begins.\n * See `use()` for an example.\n *\n * @param {Function} handler\n */\n\nPhase.prototype.before = function(handler) {\n  this.beforeHandlers.push(handler);\n  return this;\n};\n\n/**\n * Register a phase handler to be executed after the phase completes.\n * See `use()` for an example.\n *\n * @param {Function} handler\n */\n\nPhase.prototype.after = function(handler) {\n  this.afterHandlers.push(handler);\n  return this;\n};\n\n/**\n * Begin the execution of a phase and its handlers. Provide\n * a context object to be passed as the first argument for each handler\n * function.\n *\n * The handlers are executed in serial stage by stage: beforeHandlers, handlers,\n * and afterHandlers. Handlers within the same stage are executed in serial by\n * default and in parallel only if the options.parallel is true,\n *\n * @param {Object} [context] The scope applied to each handler function.\n * @callback {Function} callback\n * @param {Error} err Any `Error` that occurs during the execution of\n * the phase.\n */\n\nPhase.prototype.run = function(ctx, cb) {\n  if (typeof ctx === 'function') {\n    cb = ctx;\n    ctx = {};\n  }\n\n  var self = this;\n  // Run a single handler with ctx\n  function runHandler(handler, done) {\n    handler(ctx, done);\n  }\n\n  // Run an array of handlers with ctx\n  function runHandlers(handlers, done) {\n    // Only run the handlers in parallel if the options.parallel is true\n    if (self.options.parallel) {\n      async.each(handlers, runHandler, done);\n    } else {\n      async.eachSeries(handlers, runHandler, done);\n    }\n  }\n\n  async.eachSeries([this.beforeHandlers, this.handlers, this.afterHandlers],\n    runHandlers, cb);\n};\n\n\n/**\n * Return the `Phase` as a string.\n */\n\nPhase.prototype.toString = function() {\n  return this.id;\n};\n\n// Internal flag to be used instead of\n// `instanceof Phase` which breaks\n// when there are two instances of\n// `require('loopback-phase')\n\nPhase.prototype.__isPhase__ = true;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-phase/node_modules/async/lib/async.js":"/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= q.concurrency; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n\n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-phase/lib/merge-name-lists.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback-phase\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar g = require('strong-globalize')();\n\n/**\n * Extend the list of builtin phases by merging in an array of phases\n * requested by a user while preserving the relative order of phases\n * as specified by both arrays.\n *\n * If the first new name does not match any existing phase, it is inserted\n * as the first phase in the new list. The same applies for the second phase,\n * and so on, until an existing phase is found.\n *\n * Any new names in the middle of the array are inserted immediatelly after\n * the last common phase. For example, extending\n * `[\"initial\", \"session\", \"auth\"]` with `[\"initial\", \"preauth\", \"auth\"]`\n * results in `[\"initial\", \"preauth\", \"session\", \"auth\"]`.\n *\n *\n * **Example**\n *\n * ```js\n * var result = mergePhaseNameLists(\n *   ['initial', 'session', 'auth', 'routes', 'files', 'final'],\n *   ['initial', 'postinit', 'preauth', 'auth',\n *     'routes', 'subapps', 'final', 'last']\n * );\n *\n * // result: [\n * //   'initial', 'postinit', 'preauth', 'session', 'auth',\n * //   'routes', 'subapps', 'files', 'final', 'last'\n * // ]\n * ```\n *\n * @param {Array} currentNames The current list of phase names.\n * @param {Array} namesToMerge The items to add (zip merge) into the target\n *   array.\n * @returns {Array} A new array containing combined items from both arrays.\n *\n * @header mergePhaseNameLists\n */\nmodule.exports = function mergePhaseNameLists(currentNames, namesToMerge) {\n  if (!namesToMerge.length) return currentNames.slice();\n\n  var targetArray = currentNames.slice();\n  var targetIx = targetArray.indexOf(namesToMerge[0]);\n\n  if (targetIx === -1) {\n    // the first new item does not match any existing one\n    // start adding the new items at the start of the list\n    targetArray.splice(0, 0, namesToMerge[0]);\n    targetIx = 0;\n  }\n\n  // merge (zip) two arrays\n  for (var sourceIx = 1; sourceIx < namesToMerge.length; sourceIx++) {\n    var valueToAdd = namesToMerge[sourceIx];\n    var previousValue = namesToMerge[sourceIx - 1];\n    var existingIx = targetArray.indexOf(valueToAdd, targetIx);\n\n    if (existingIx === -1) {\n      // A new phase - try to add it after the last one,\n      // unless it was already registered\n      if (targetArray.indexOf(valueToAdd) !== -1) {\n        throw new Error(g.f('Ordering conflict: cannot add \"%s' +\n        '\" after \"%s\", because the opposite order was ' +\n        ' already specified', valueToAdd, previousValue));\n      }\n      var previousIx = targetArray.indexOf(previousValue);\n      targetArray.splice(previousIx + 1, 0, valueToAdd);\n    } else {\n      // An existing phase - move the pointer\n      targetIx = existingIx;\n    }\n  }\n\n  return targetArray;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/application.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module dependencies.\n */\n\n'use strict';\nvar g = require('./globalize');\nvar DataSource = require('loopback-datasource-juggler').DataSource;\nvar Registry = require('./registry');\nvar assert = require('assert');\nvar fs = require('fs');\nvar extend = require('util')._extend;\nvar RemoteObjects = require('strong-remoting');\nvar classify = require('underscore.string/classify');\nvar camelize = require('underscore.string/camelize');\nvar path = require('path');\nvar util = require('util');\n\n/**\n * The `App` object represents a Loopback application.\n *\n * The App object extends [Express](http://expressjs.com/api.html#express) and\n * supports Express middleware. See\n * [Express documentation](http://expressjs.com/) for details.\n *\n * ```js\n * var loopback = require('loopback');\n * var app = loopback();\n *\n * app.get('/', function(req, res){\n *   res.send('hello world');\n * });\n *\n * app.listen(3000);\n * ```\n *\n * @class LoopBackApplication\n * @header var app = loopback()\n */\nfunction App() {\n  // this is a dummy placeholder for jsdox\n}\n\n/*!\n * Export the app prototype.\n */\n\nvar app = module.exports = {};\n\n/**\n * Lazily load a set of [remote objects](http://apidocs.strongloop.com/strong-remoting/#remoteobjectsoptions).\n *\n * **NOTE:** Calling `app.remotes()` more than once returns only a single set of remote objects.\n * @returns {RemoteObjects}\n */\n\napp.remotes = function() {\n  if (this._remotes) {\n    return this._remotes;\n  } else {\n    var options = {};\n\n    if (this.get) {\n      options = this.get('remoting');\n    }\n\n    return (this._remotes = RemoteObjects.create(options));\n  }\n};\n\n/*!\n * Remove a route by reference.\n */\n\napp.disuse = function(route) {\n  if (this.stack) {\n    for (var i = 0; i < this.stack.length; i++) {\n      if (this.stack[i].route === route) {\n        this.stack.splice(i, 1);\n      }\n    }\n  }\n};\n\n/**\n * Attach a model to the app. The `Model` will be available on the\n * `app.models` object.\n *\n * Example - Attach an existing model:\n ```js\n * var User = loopback.User;\n * app.model(User);\n *```\n * Example - Attach an existing model, alter some aspects of the model:\n * ```js\n * var User = loopback.User;\n * app.model(User, { dataSource: 'db' });\n *```\n *\n * @param {Object} Model The model to attach.\n * @options {Object} config The model's configuration.\n * @property {String|DataSource} dataSource The `DataSource` to which to attach the model.\n * @property {Boolean} [public] Whether the model should be exposed via REST API.\n * @property {Object} [relations] Relations to add/update.\n * @end\n * @returns {ModelConstructor} the model class\n */\n\napp.model = function(Model, config) {\n  var isPublic = true;\n  var registry = this.registry;\n\n  if (typeof Model === 'string') {\n    var msg = 'app.model(modelName, settings) is no longer supported. ' +\n      'Use app.registry.createModel(modelName, definition) and ' +\n      'app.model(ModelCtor, config) instead.';\n    throw new Error(msg);\n  }\n\n  if (arguments.length > 1) {\n    config = config || {};\n    configureModel(Model, config, this);\n    isPublic = config.public !== false;\n  } else {\n    assert(Model.prototype instanceof Model.registry.getModel('Model'),\n      Model.modelName + ' must be a descendant of loopback.Model');\n  }\n\n  var modelName = Model.modelName;\n  this.models[modelName] =\n    this.models[classify(modelName)] =\n      this.models[camelize(modelName)] = Model;\n\n  this.models().push(Model);\n\n  if (isPublic && Model.sharedClass) {\n    this.remotes().defineObjectType(Model.modelName, function(data) {\n      return new Model(data);\n    });\n    this.remotes().addClass(Model.sharedClass);\n    if (Model.settings.trackChanges && Model.Change) {\n      this.remotes().addClass(Model.Change.sharedClass);\n    }\n    clearHandlerCache(this);\n    this.emit('modelRemoted', Model.sharedClass);\n  }\n\n  var self = this;\n  Model.on('remoteMethodDisabled', function(model, methodName) {\n    self.emit('remoteMethodDisabled', model, methodName);\n  });\n  Model.on('remoteMethodAdded', function(model) {\n    self.emit('remoteMethodAdded', model);\n  });\n\n  Model.shared = isPublic;\n  Model.app = this;\n  Model.emit('attached', this);\n  return Model;\n};\n\n/**\n * Get the models exported by the app. Returns only models defined using `app.model()`\n *\n * There are two ways to access models:\n *\n * 1.  Call `app.models()` to get a list of all models.\n *\n * ```js\n * var models = app.models();\n *\n * models.forEach(function(Model) {\n *  console.log(Model.modelName); // color\n * });\n * ```\n *\n * 2. Use `app.models` to access a model by name.\n * `app.models` has properties for all defined models.\n *\n * The following example illustrates accessing the `Product` and `CustomerReceipt` models\n * using the `models` object.\n *\n * ```js\n * var loopback = require('loopback');\n *  var app = loopback();\n *  app.boot({\n *   dataSources: {\n *     db: {connector: 'memory'}\n *   }\n * });\n *\n * var productModel = app.registry.createModel('product');\n * app.model(productModel, {dataSource: 'db'});\n * var customerReceiptModel = app.registry.createModel('customer-receipt');\n * app.model(customerReceiptModel, {dataSource: 'db'});\n *\n * // available based on the given name\n * var Product = app.models.Product;\n *\n * // also available as camelCase\n * var product = app.models.product;\n *\n * // multi-word models are avaiable as pascal cased\n * var CustomerReceipt = app.models.CustomerReceipt;\n *\n * // also available as camelCase\n * var customerReceipt = app.models.customerReceipt;\n * ```\n *\n * @returns {Array} Array of model classes.\n */\n\napp.models = function() {\n  return this._models || (this._models = []);\n};\n\n/**\n * Define a DataSource.\n *\n * @param {String} name The data source name\n * @param {Object} config The data source config\n */\napp.dataSource = function(name, config) {\n  try {\n    var ds = dataSourcesFromConfig(name, config, this.connectors, this.registry);\n    this.dataSources[name] =\n    this.dataSources[classify(name)] =\n    this.dataSources[camelize(name)] = ds;\n    ds.app = this;\n    return ds;\n  } catch (err) {\n    if (err.message) {\n      err.message = g.f('Cannot create data source %s: %s',\n        JSON.stringify(name), err.message);\n    }\n    throw err;\n  }\n};\n\n/**\n * Register a connector.\n *\n * When a new data-source is being added via `app.dataSource`, the connector\n * name is looked up in the registered connectors first.\n *\n * Connectors are required to be explicitly registered only for applications\n * using browserify, because browserify does not support dynamic require,\n * which is used by LoopBack to automatically load the connector module.\n *\n * @param {String} name Name of the connector, e.g. 'mysql'.\n * @param {Object} connector Connector object as returned\n *   by `require('loopback-connector-{name}')`.\n */\napp.connector = function(name, connector) {\n  this.connectors[name] =\n  this.connectors[classify(name)] =\n  this.connectors[camelize(name)] = connector;\n};\n\n/**\n * Get all remote objects.\n * @returns {Object} [Remote objects](http://apidocs.strongloop.com/strong-remoting/#remoteobjectsoptions).\n */\n\napp.remoteObjects = function() {\n  var result = {};\n\n  this.remotes().classes().forEach(function(sharedClass) {\n    result[sharedClass.name] = sharedClass.ctor;\n  });\n\n  return result;\n};\n\n/*!\n * Get a handler of the specified type from the handler cache.\n * @triggers `mounted` events on shared class constructors (models)\n */\n\napp.handler = function(type, options) {\n  var handlers = this._handlers || (this._handlers = {});\n  if (handlers[type]) {\n    return handlers[type];\n  }\n\n  var remotes = this.remotes();\n  var handler = this._handlers[type] = remotes.handler(type, options);\n\n  remotes.classes().forEach(function(sharedClass) {\n    sharedClass.ctor.emit('mounted', app, sharedClass, remotes);\n  });\n\n  return handler;\n};\n\n/**\n * An object to store dataSource instances.\n */\n\napp.dataSources = app.datasources = {};\n\n/**\n * Enable app wide authentication.\n */\n\napp.enableAuth = function(options) {\n  var AUTH_MODELS = ['User', 'AccessToken', 'ACL', 'Role', 'RoleMapping'];\n\n  var remotes = this.remotes();\n  var app = this;\n\n  if (options && options.dataSource) {\n    var appModels = app.registry.modelBuilder.models;\n    AUTH_MODELS.forEach(function(m) {\n      var Model = app.registry.findModel(m);\n      if (!Model) {\n        throw new Error(\n          g.f('Authentication requires model %s to be defined.', m));\n      }\n\n      if (Model.dataSource || Model.app) return;\n\n      // Find descendants of Model that are attached,\n      // for example \"Customer\" extending \"User\" model\n      for (var name in appModels) {\n        var candidate = appModels[name];\n        var isSubclass = candidate.prototype instanceof Model;\n        var isAttached = !!candidate.dataSource || !!candidate.app;\n        if (isSubclass && isAttached) return;\n      }\n\n      app.model(Model, {\n        dataSource: options.dataSource,\n        public: m === 'User',\n      });\n    });\n  }\n\n  remotes.authorization = function(ctx, next) {\n    var method = ctx.method;\n    var req = ctx.req;\n    var Model = method.ctor;\n    var modelInstance = ctx.instance;\n\n    var modelId = modelInstance && modelInstance.id ||\n      // replacement for deprecated req.param()\n      (req.params && req.params.id !== undefined ? req.params.id :\n       req.body && req.body.id !== undefined ? req.body.id :\n       req.query && req.query.id !== undefined ? req.query.id :\n       undefined);\n\n    var modelName = Model.modelName;\n\n    var modelSettings = Model.settings || {};\n    var errStatusCode = modelSettings.aclErrorStatus || app.get('aclErrorStatus') || 401;\n    if (!req.accessToken) {\n      errStatusCode = 401;\n    }\n\n    if (Model.checkAccess) {\n      Model.checkAccess(\n        req.accessToken,\n        modelId,\n        method,\n        ctx,\n        function(err, allowed) {\n          if (err) {\n            console.log(err);\n            next(err);\n          } else if (allowed) {\n            next();\n          } else {\n            var messages = {\n              403: {\n                message: g.f('Access Denied'),\n                code: 'ACCESS_DENIED',\n              },\n              404: {\n                message: (g.f('could not find %s with id %s', modelName, modelId)),\n                code: 'MODEL_NOT_FOUND',\n              },\n              401: {\n                message: g.f('Authorization Required'),\n                code: 'AUTHORIZATION_REQUIRED',\n              },\n            };\n\n            var e = new Error(messages[errStatusCode].message || messages[403].message);\n            e.statusCode = errStatusCode;\n            e.code = messages[errStatusCode].code || messages[403].code;\n            next(e);\n          }\n        }\n      );\n    } else {\n      next();\n    }\n  };\n\n  this._verifyAuthModelRelations();\n\n  this.isAuthEnabled = true;\n};\n\napp._verifyAuthModelRelations = function() {\n  // Allow unit-tests (but also LoopBack users) to disable the warnings\n  if (this.get('_verifyAuthModelRelations') === false) return;\n\n  const AccessToken = this.registry.findModel('AccessToken');\n  const User = this.registry.findModel('User');\n  this.models().forEach(Model => {\n    if (Model === AccessToken || Model.prototype instanceof AccessToken) {\n      scheduleVerification(Model, verifyAccessTokenRelations);\n    }\n\n    if (Model === User || Model.prototype instanceof User) {\n      scheduleVerification(Model, verifyUserRelations);\n    }\n  });\n\n  function scheduleVerification(Model, verifyFn) {\n    if (Model.dataSource) {\n      verifyFn(Model);\n    } else {\n      Model.on('attached', () => verifyFn(Model));\n    }\n  }\n\n  function verifyAccessTokenRelations(Model) {\n    const belongsToUser = Model.relations && Model.relations.user;\n    if (belongsToUser) return;\n\n    const relationsConfig = Model.settings.relations || {};\n    const userName = (relationsConfig.user || {}).model;\n    if (userName) {\n      console.warn(\n        'The model %j configures \"belongsTo User-like models\" relation ' +\n          'with target model %j. However, the model %j is not attached to ' +\n          'the application and therefore cannot be used by this relation. ' +\n          'This typically happens when the application has a custom ' +\n          'custom User subclass, but does not fix AccessToken relations ' +\n          'to use this new model.\\n' +\n          'Learn more at http://ibm.biz/setup-loopback-auth',\n        Model.modelName, userName, userName);\n      return;\n    }\n\n    console.warn(\n      'The model %j does not have \"belongsTo User-like model\" relation ' +\n        'configured.\\n' +\n        'Learn more at http://ibm.biz/setup-loopback-auth',\n      Model.modelName);\n  }\n\n  function verifyUserRelations(Model) {\n    const hasManyTokens = Model.relations && Model.relations.accessTokens;\n    if (hasManyTokens) return;\n\n    const relationsConfig = Model.settings.relations || {};\n    const accessTokenName = (relationsConfig.accessTokens || {}).model;\n    if (accessTokenName) {\n      console.warn(\n        'The model %j configures \"hasMany AccessToken-like models\" relation ' +\n          'with target model %j. However, the model %j is not attached to ' +\n          'the application and therefore cannot be used by this relation. ' +\n          'This typically happens when the application has a custom ' +\n          'AccessToken subclass, but does not fix User relations to use this ' +\n          'new model.\\n' +\n          'Learn more at http://ibm.biz/setup-loopback-auth',\n        Model.modelName, accessTokenName, accessTokenName);\n      return;\n    }\n\n    console.warn(\n      'The model %j does not have \"hasMany AccessToken-like models\" relation ' +\n        'configured.\\n' +\n        'Learn more at http://ibm.biz/setup-loopback-auth',\n      Model.modelName);\n  }\n};\n\napp.boot = function(options) {\n  throw new Error(\n    g.f('{{`app.boot`}} was removed, use the new module {{loopback-boot}} instead'));\n};\n\nfunction dataSourcesFromConfig(name, config, connectorRegistry, registry) {\n  var connectorPath;\n\n  assert(typeof config === 'object',\n    'can not create data source without config object');\n\n  if (typeof config.connector === 'string') {\n    name = config.connector;\n    if (connectorRegistry[name]) {\n      config.connector = connectorRegistry[name];\n    } else {\n      connectorPath = path.join(__dirname, 'connectors', name + '.js');\n\n      if (fs.existsSync(connectorPath)) {\n        config.connector = require(connectorPath);\n      }\n    }\n    if (config.connector && typeof config.connector === 'object' && !config.connector.name)\n      config.connector.name = name;\n  }\n\n  return registry.createDataSource(config);\n}\n\nfunction configureModel(ModelCtor, config, app) {\n  assert(ModelCtor.prototype instanceof ModelCtor.registry.getModel('Model'),\n    ModelCtor.modelName + ' must be a descendant of loopback.Model');\n\n  var dataSource = config.dataSource;\n\n  if (dataSource) {\n    if (typeof dataSource === 'string') {\n      dataSource = app.dataSources[dataSource];\n    }\n\n    assert(\n      dataSource instanceof DataSource,\n      ModelCtor.modelName + ' is referencing a dataSource that does not exist: \"' +\n      config.dataSource + '\"'\n    );\n  }\n\n  config = extend({}, config);\n  config.dataSource = dataSource;\n\n  setSharedMethodSharedProperties(ModelCtor, app, config);\n\n  app.registry.configureModel(ModelCtor, config);\n}\n\nfunction setSharedMethodSharedProperties(model, app, modelConfigs) {\n  var settings = {};\n\n  // apply config.json settings\n  var config = app.get('remoting');\n  var configHasSharedMethodsSettings = config &&\n      config.sharedMethods &&\n      typeof config.sharedMethods === 'object';\n  if (configHasSharedMethodsSettings)\n    util._extend(settings, config.sharedMethods);\n\n  // apply model-config.json settings\n  var modelConfig = modelConfigs.options;\n  var modelConfigHasSharedMethodsSettings = modelConfig &&\n      modelConfig.remoting &&\n      modelConfig.remoting.sharedMethods &&\n      typeof modelConfig.remoting.sharedMethods === 'object';\n  if (modelConfigHasSharedMethodsSettings)\n    util._extend(settings, modelConfig.remoting.sharedMethods);\n\n  // validate setting values\n  Object.keys(settings).forEach(function(setting) {\n    var settingValue = settings[setting];\n    var settingValueType = typeof settingValue;\n    if (settingValueType !== 'boolean')\n      throw new TypeError(g.f('Expected boolean, got %s', settingValueType));\n  });\n\n  // set sharedMethod.shared using the merged settings\n  var sharedMethods = model.sharedClass.methods({includeDisabled: true});\n  sharedMethods.forEach(function(sharedMethod) {\n    // use the specific setting if it exists\n    var hasSpecificSetting = settings.hasOwnProperty(sharedMethod.name);\n    if (hasSpecificSetting) {\n      sharedMethod.shared = settings[sharedMethod.name];\n    } else { // otherwise, use the default setting if it exists\n      var hasDefaultSetting = settings.hasOwnProperty('*');\n      if (hasDefaultSetting)\n        sharedMethod.shared = settings['*'];\n    }\n  });\n}\n\nfunction clearHandlerCache(app) {\n  app._handlers = undefined;\n}\n\n/**\n * Listen for connections and update the configured port.\n *\n * When there are no parameters or there is only one callback parameter,\n * the server will listen on `app.get('host')` and `app.get('port')`.\n *\n * For example, to listen on host/port configured in app config:\n * ```js\n * app.listen();\n * ```\n *\n * Otherwise all arguments are forwarded to `http.Server.listen`.\n *\n * For example, to listen on the specified port and all hosts, and ignore app config.\n * ```js\n * app.listen(80);\n * ```\n *\n * The function also installs a `listening` callback that calls\n * `app.set('port')` with the value returned by `server.address().port`.\n * This way the port param contains always the real port number, even when\n * listen was called with port number 0.\n *\n * @param {Function} [cb] If specified, the callback is added as a listener\n *   for the server's \"listening\" event.\n * @returns {http.Server} A node `http.Server` with this application configured\n *   as the request handler.\n */\napp.listen = function(cb) {\n  var self = this;\n\n  var server = require('http').createServer(this);\n\n  server.on('listening', function() {\n    self.set('port', this.address().port);\n\n    var listeningOnAll = false;\n    var host = self.get('host');\n    if (!host) {\n      listeningOnAll = true;\n      host = this.address().address;\n      self.set('host', host);\n    } else if (host === '0.0.0.0' || host === '::') {\n      listeningOnAll = true;\n    }\n\n    if (!self.get('url')) {\n      if (process.platform === 'win32' && listeningOnAll) {\n        // Windows browsers don't support `0.0.0.0` host in the URL\n        // We are replacing it with localhost to build a URL\n        // that can be copied and pasted into the browser.\n        host = 'localhost';\n      }\n      var url = 'http://' + host + ':' + self.get('port') + '/';\n      self.set('url', url);\n    }\n  });\n\n  var useAppConfig =\n    arguments.length === 0 ||\n      (arguments.length == 1 && typeof arguments[0] == 'function');\n\n  if (useAppConfig) {\n    var port = this.get('port');\n    // NOTE(bajtos) port:undefined no longer works on node@6,\n    // we must pass port:0 explicitly\n    if (port === undefined) port = 0;\n    server.listen(port, this.get('host'), cb);\n  } else {\n    server.listen.apply(server, arguments);\n  }\n\n  return server;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/index.js":"// Copyright IBM Corp. 2011,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar SG = require('strong-globalize');\nSG.SetRootDir(__dirname);\n\nexports.ModelBuilder = exports.LDL = require('./lib/model-builder.js').ModelBuilder;\nexports.DataSource = exports.Schema = require('./lib/datasource.js').DataSource;\nexports.ModelBaseClass = require('./lib/model.js');\nexports.GeoPoint = require('./lib/geo.js').GeoPoint;\nexports.ValidationError = require('./lib/validations.js').ValidationError;\n\nObject.defineProperty(exports, 'version', {\n  get: function() { return require('./package.json').version; },\n});\n\nvar commonTest = './test/common_test';\nObject.defineProperty(exports, 'test', {\n  get: function() { return require(commonTest); },\n});\n\nexports.Transaction = require('loopback-connector').Transaction;\n\nexports.KeyValueAccessObject = require('./lib/kvao');\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/model-builder.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\n/*!\n * Module dependencies\n */\n\nvar g = require('strong-globalize')();\nvar inflection = require('inflection');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar assert = require('assert');\nvar deprecated = require('depd')('loopback-datasource-juggler');\nvar DefaultModelBaseClass = require('./model.js');\nvar List = require('./list.js');\nvar ModelDefinition = require('./model-definition.js');\nvar mergeSettings = require('./utils').mergeSettings;\nvar MixinProvider = require('./mixins');\n\n// Set up types\nrequire('./types')(ModelBuilder);\n\nvar introspect = require('./introspection')(ModelBuilder);\n\n/*!\n * Export public API\n */\nexports.ModelBuilder = exports.Schema = ModelBuilder;\n\n/*!\n * Helpers\n */\nvar slice = Array.prototype.slice;\n\n/**\n * ModelBuilder - A builder to define data models.\n *\n * @property {Object} definitions Definitions of the models.\n * @property {Object} models Model constructors\n * @class\n */\nfunction ModelBuilder() {\n  // create blank models pool\n  this.models = {};\n  this.definitions = {};\n  this.settings = {};\n  this.mixins = new MixinProvider(this);\n  this.defaultModelBaseClass = DefaultModelBaseClass;\n}\n\n// Inherit from EventEmitter\nutil.inherits(ModelBuilder, EventEmitter);\n\n// Create a default instance\nModelBuilder.defaultInstance = new ModelBuilder();\n\nfunction isModelClass(cls) {\n  if (!cls) {\n    return false;\n  }\n  return cls.prototype instanceof DefaultModelBaseClass;\n}\n\n/**\n * Get a model by name.\n *\n * @param {String} name The model name\n * @param {Boolean} forceCreate Whether the create a stub for the given name if a model doesn't exist.\n * @returns {*} The model class\n */\nModelBuilder.prototype.getModel = function(name, forceCreate) {\n  var model = this.models[name];\n  if (!model && forceCreate) {\n    model = this.define(name, {}, {unresolved: true});\n  }\n  return model;\n};\n\n/**\n * Get the model definition by name\n * @param {String} name The model name\n * @returns {ModelDefinition} The model definition\n */\nModelBuilder.prototype.getModelDefinition = function(name) {\n  return this.definitions[name];\n};\n\n/**\n * Define a model class.\n * Simple example:\n * ```\n * var User = modelBuilder.define('User', {\n *     email: String,\n *     password: String,\n *     birthDate: Date,\n *     activated: Boolean\n * });\n * ```\n * More advanced example:\n * ```\n * var User = modelBuilder.define('User', {\n *     email: { type: String, limit: 150, index: true },\n *     password: { type: String, limit: 50 },\n *     birthDate: Date,\n *     registrationDate: {type: Date, default: function () { return new Date }},\n *     activated: { type: Boolean, default: false }\n * });\n * ```\n *\n * @param {String} className Name of class\n * @param {Object} properties Hash of class properties in format `{property: Type, property2: Type2, ...}` or `{property: {type: Type}, property2: {type: Type2}, ...}`\n * @param {Object} settings Other configuration of class\n * @param {Function} parent Parent model\n * @return newly created class\n *\n */\nModelBuilder.prototype.define = function defineClass(className, properties, settings, parent) {\n  var modelBuilder = this;\n  var args = slice.call(arguments);\n  var pluralName = (settings && settings.plural) ||\n    inflection.pluralize(className);\n\n  var httpOptions = (settings && settings.http) || {};\n  var pathName = httpOptions.path || pluralName;\n\n  if (!className) {\n    throw new Error(g.f('Class name required'));\n  }\n  if (args.length === 1) {\n    properties = {};\n    args.push(properties);\n  }\n  if (args.length === 2) {\n    settings = {};\n    args.push(settings);\n  }\n\n  properties = properties || {};\n  settings = settings || {};\n\n  // Set the strict mode to be false by default\n  if (settings.strict === undefined || settings.strict === null) {\n    settings.strict = false;\n  }\n\n  // Set up the base model class\n  var ModelBaseClass = parent || this.defaultModelBaseClass;\n  var baseClass = settings.base || settings['super'];\n  if (baseClass) {\n    // Normalize base model property\n    settings.base = baseClass;\n    delete settings['super'];\n\n    if (isModelClass(baseClass)) {\n      ModelBaseClass = baseClass;\n    } else {\n      ModelBaseClass = this.models[baseClass];\n      assert(ModelBaseClass, 'Base model is not found: ' + baseClass);\n    }\n  }\n\n  // Make sure base properties are inherited\n  // See https://github.com/strongloop/loopback-datasource-juggler/issues/293\n  if ((parent && !settings.base) || (!parent && settings.base)) {\n    return ModelBaseClass.extend(className, properties, settings);\n  }\n\n  // Check if there is a unresolved model with the same name\n  var ModelClass = this.models[className];\n\n  // Create the ModelClass if it doesn't exist or it's resolved (override)\n  // TODO: [rfeng] We need to decide what names to use for built-in models such as User.\n  if (!ModelClass || !ModelClass.settings.unresolved) {\n    // every class can receive hash of data as optional param\n    ModelClass = function ModelConstructor(data, options) {\n      if (!(this instanceof ModelConstructor)) {\n        return new ModelConstructor(data, options);\n      }\n      if (ModelClass.settings.unresolved) {\n        throw new Error(g.f('Model %s is not defined.', ModelClass.modelName));\n      }\n      ModelBaseClass.apply(this, arguments);\n    };\n    // mix in EventEmitter (don't inherit from)\n    var events = new EventEmitter();\n    // The model can have more than 10 listeners for lazy relationship setup\n    // See https://github.com/strongloop/loopback/issues/404\n    events.setMaxListeners(32);\n    for (var f in EventEmitter.prototype) {\n      if (typeof EventEmitter.prototype[f] === 'function') {\n        ModelClass[f] = EventEmitter.prototype[f].bind(events);\n      }\n    }\n    hiddenProperty(ModelClass, 'modelName', className);\n  }\n\n  util.inherits(ModelClass, ModelBaseClass);\n\n  // store class in model pool\n  this.models[className] = ModelClass;\n\n  // Return the unresolved model\n  if (settings.unresolved) {\n    ModelClass.settings = {unresolved: true};\n    return ModelClass;\n  }\n\n  // Add metadata to the ModelClass\n  hiddenProperty(ModelClass, 'modelBuilder', modelBuilder);\n  hiddenProperty(ModelClass, 'dataSource', null); // Keep for back-compatibility\n  hiddenProperty(ModelClass, 'pluralModelName', pluralName);\n  hiddenProperty(ModelClass, 'relations', {});\n  if (pathName[0] !== '/') {\n    // Support both flavors path: 'x' and path: '/x'\n    pathName = '/' + pathName;\n  }\n  hiddenProperty(ModelClass, 'http', {path: pathName});\n  hiddenProperty(ModelClass, 'base', ModelBaseClass);\n  hiddenProperty(ModelClass, '_observers', {});\n  hiddenProperty(ModelClass, '_warned', {});\n\n  // inherit ModelBaseClass static methods\n  for (var i in ModelBaseClass) {\n    // We need to skip properties that are already in the subclass, for example, the event emitter methods\n    if (i !== '_mixins' && !(i in ModelClass)) {\n      ModelClass[i] = ModelBaseClass[i];\n    }\n  }\n\n  // Load and inject the model classes\n  if (settings.models) {\n    Object.keys(settings.models).forEach(function(m) {\n      var model = settings.models[m];\n      ModelClass[m] = typeof model === 'string' ? modelBuilder.getModel(model, true) : model;\n    });\n  }\n\n  ModelClass.getter = {};\n  ModelClass.setter = {};\n\n  for (var p in properties) {\n    // Remove properties that reverted by the subclass\n    if (properties[p] === null || properties[p] === false) {\n      // Hide the base property\n      delete properties[p];\n    }\n\n    // Throw error for properties with unsupported names\n    if (/\\./.test(p)) {\n      throw new Error(g.f('Property names containing dot(s) are not supported. ' +\n        'Model: %s, property: %s', className, p));\n    }\n\n    // Warn if property name is 'constructor'\n    if (p === 'constructor') {\n      deprecated(g.f('Property name should not be \"{{constructor}}\" in Model: %s', className));\n    }\n  }\n\n  var modelDefinition = new ModelDefinition(this, className, properties, settings);\n\n  this.definitions[className] = modelDefinition;\n\n  // expose properties on the ModelClass\n  ModelClass.definition = modelDefinition;\n  // keep a pointer to settings as models can use it for configuration\n  ModelClass.settings = modelDefinition.settings;\n\n  var idInjection = settings.idInjection;\n  if (idInjection !== false) {\n    // Default to true if undefined\n    idInjection = true;\n  }\n\n  var idNames = modelDefinition.idNames();\n  if (idNames.length > 0) {\n    // id already exists\n    idInjection = false;\n  }\n\n  // Add the id property\n  if (idInjection) {\n    // Set up the id property\n    ModelClass.definition.defineProperty('id', {type: Number, id: 1, generated: true});\n  }\n\n  idNames = modelDefinition.idNames(); // Reload it after rebuild\n  // Create a virtual property 'id'\n  if (idNames.length === 1) {\n    var idProp = idNames[0];\n    if (idProp !== 'id') {\n      Object.defineProperty(ModelClass.prototype, 'id', {\n        get: function() {\n          var idProp = ModelClass.definition.idNames()[0];\n          return this.__data[idProp];\n        },\n        configurable: true,\n        enumerable: false,\n      });\n    }\n  } else {\n    // Now the id property is an object that consists of multiple keys\n    Object.defineProperty(ModelClass.prototype, 'id', {\n      get: function() {\n        var compositeId = {};\n        var idNames = ModelClass.definition.idNames();\n        for (var i = 0, p; i < idNames.length; i++) {\n          p = idNames[i];\n          compositeId[p] = this.__data[p];\n        }\n        return compositeId;\n      },\n      configurable: true,\n      enumerable: false,\n    });\n  }\n\n  // A function to loop through the properties\n  ModelClass.forEachProperty = function(cb) {\n    var props = ModelClass.definition.properties;\n    var keys = Object.keys(props);\n    for (var i = 0, n = keys.length; i < n; i++) {\n      cb(keys[i], props[keys[i]]);\n    }\n  };\n\n  // A function to attach the model class to a data source\n  ModelClass.attachTo = function(dataSource) {\n    dataSource.attach(this);\n  };\n\n  /** Extend the model with the specified model, properties, and other settings.\n   * For example, to extend an existing model, for example, a built-in model:\n   *\n   * ```js\n   * var Customer = User.extend('customer', {\n   *   accountId: String,\n   *   vip: Boolean\n   * });\n   * ```\n   *\n   * To extend the base model, essentially creating a new model:\n   * ```js\n   * var user = loopback.Model.extend('user', properties, options);\n   * ```\n   *\n   * @param {String} className Name of the new model being defined.\n   * @options {Object} properties Properties to define for the model, added to properties of model being extended.\n   * @options {Object} settings Model settings, such as relations and acls.\n   *\n   */\n  ModelClass.extend = function(className, subclassProperties, subclassSettings) {\n    var properties = ModelClass.definition.properties;\n    var settings = ModelClass.definition.settings;\n\n    subclassProperties = subclassProperties || {};\n    subclassSettings = subclassSettings || {};\n\n    // Check if subclass redefines the ids\n    var idFound = false;\n    for (var k in subclassProperties) {\n      if (subclassProperties[k] && subclassProperties[k].id) {\n        idFound = true;\n        break;\n      }\n    }\n\n    // Merging the properties\n    var keys = Object.keys(properties);\n    for (var i = 0, n = keys.length; i < n; i++) {\n      var key = keys[i];\n\n      if (idFound && properties[key].id) {\n        // don't inherit id properties\n        continue;\n      }\n      if (subclassProperties[key] === undefined) {\n        var baseProp = properties[key];\n        var basePropCopy = baseProp;\n        if (baseProp && typeof baseProp === 'object') {\n          // Deep clone the base prop\n          basePropCopy = mergeSettings(null, baseProp);\n        }\n        subclassProperties[key] = basePropCopy;\n      }\n    }\n\n    // Merge the settings\n    var originalSubclassSettings = subclassSettings;\n    subclassSettings = mergeSettings(settings, subclassSettings);\n\n    // Ensure 'base' is not inherited. Note we don't have to delete 'super'\n    // as that is removed from settings by modelBuilder.define and thus\n    // it is never inherited\n    if (!originalSubclassSettings.base) {\n      subclassSettings.base = ModelClass;\n    }\n\n    // Define the subclass\n    var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);\n\n    // Calling the setup function\n    if (typeof subClass.setup === 'function') {\n      subClass.setup.call(subClass);\n    }\n\n    return subClass;\n  };\n\n  /**\n   * Register a property for the model class\n   * @param {String} propertyName Name of the property.\n   */\n  ModelClass.registerProperty = function(propertyName) {\n    var properties = modelDefinition.build();\n    var prop = properties[propertyName];\n    var DataType = prop.type;\n    if (!DataType) {\n      throw new Error(g.f('Invalid type for property %s', propertyName));\n    }\n\n    if (prop.required) {\n      var requiredOptions = typeof prop.required === 'object' ? prop.required : undefined;\n      ModelClass.validatesPresenceOf(propertyName, requiredOptions);\n    }\n\n    Object.defineProperty(ModelClass.prototype, propertyName, {\n      get: function() {\n        if (ModelClass.getter[propertyName]) {\n          return ModelClass.getter[propertyName].call(this); // Try getter first\n        } else {\n          return this.__data && this.__data[propertyName]; // Try __data\n        }\n      },\n      set: function(value) {\n        var DataType = ModelClass.definition.properties[propertyName].type;\n        if (Array.isArray(DataType) || DataType === Array) {\n          DataType = List;\n        } else if (DataType === Date) {\n          DataType = DateType;\n        } else if (DataType === Boolean) {\n          DataType = BooleanType;\n        } else if (typeof DataType === 'string') {\n          DataType = modelBuilder.resolveType(DataType);\n        }\n\n        var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;\n        if (value === undefined && persistUndefinedAsNull) {\n          value = null;\n        }\n\n        if (ModelClass.setter[propertyName]) {\n          ModelClass.setter[propertyName].call(this, value); // Try setter first\n        } else {\n          this.__data = this.__data || {};\n          if (value === null || value === undefined) {\n            this.__data[propertyName] = value;\n          } else {\n            if (DataType === List) {\n              this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);\n            } else {\n              // Assume the type constructor handles Constructor() call\n              // If not, we should call new DataType(value).valueOf();\n              this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);\n            }\n          }\n        }\n      },\n      configurable: true,\n      enumerable: true,\n    });\n\n    // FIXME: [rfeng] Do we need to keep the raw data?\n    // Use $ as the prefix to avoid conflicts with properties such as _id\n    Object.defineProperty(ModelClass.prototype, '$' + propertyName, {\n      get: function() {\n        return this.__data && this.__data[propertyName];\n      },\n      set: function(value) {\n        if (!this.__data) {\n          this.__data = {};\n        }\n        this.__data[propertyName] = value;\n      },\n      configurable: true,\n      enumerable: false,\n    });\n  };\n\n  var props = ModelClass.definition.properties;\n  var keys = Object.keys(props);\n  var size = keys.length;\n  for (i = 0; i < size; i++) {\n    var propertyName = keys[i];\n    ModelClass.registerProperty(propertyName);\n  }\n\n  var mixinSettings = settings.mixins || {};\n  keys = Object.keys(mixinSettings);\n  size = keys.length;\n  for (i = 0; i < size; i++) {\n    var name = keys[i];\n    var mixin = mixinSettings[name];\n    if (mixin === true) {\n      mixin = {};\n    }\n    if (Array.isArray(mixin)) {\n      mixin.forEach(function(m) {\n        if (m === true) m = {};\n        if (typeof m === 'object') {\n          modelBuilder.mixins.applyMixin(ModelClass, name, m);\n        }\n      });\n    } else if (typeof mixin === 'object') {\n      modelBuilder.mixins.applyMixin(ModelClass, name, mixin);\n    }\n  }\n\n  ModelClass.emit('defined', ModelClass);\n\n  return ModelClass;\n};\n\n// DataType for Date\nfunction DateType(arg) {\n  var d = new Date(arg);\n  if (isNaN(d.getTime())) {\n    throw new Error(g.f('Invalid date: %s', arg));\n  }\n  return d;\n}\n\n// Relax the Boolean coercision\nfunction BooleanType(arg) {\n  if (typeof arg === 'string') {\n    switch (arg) {\n      case 'true':\n      case '1':\n        return true;\n      case 'false':\n      case '0':\n        return false;\n    }\n  }\n  if (arg == null) {\n    return null;\n  }\n  return Boolean(arg);\n}\n\n/**\n * Define single property named `propertyName` on `model`\n *\n * @param {String} model Name of model\n * @param {String} propertyName Name of property\n * @param {Object} propertyDefinition Property settings\n */\nModelBuilder.prototype.defineProperty = function(model, propertyName, propertyDefinition) {\n  this.definitions[model].defineProperty(propertyName, propertyDefinition);\n  this.models[model].registerProperty(propertyName);\n};\n\n/**\n * Define a new value type that can be used in model schemas as a property type.\n * @param {function()} type Type constructor.\n * @param {string[]=} aliases Optional list of alternative names for this type.\n */\nModelBuilder.prototype.defineValueType = function(type, aliases) {\n  ModelBuilder.registerType(type, aliases);\n};\n\n/**\n * Extend existing model with specified properties\n *\n * Example:\n * Instead of extending a model with attributes like this (for example):\n *\n * ```js\n *     db.defineProperty('Content', 'competitionType',\n *       { type: String });\n *     db.defineProperty('Content', 'expiryDate',\n *       { type: Date, index: true });\n *     db.defineProperty('Content', 'isExpired',\n *       { type: Boolean, index: true });\n *```\n * This method enables you to extend a model as follows (for example):\n * ```js\n *     db.extendModel('Content', {\n *       competitionType: String,\n *       expiryDate: { type: Date, index: true },\n *       isExpired: { type: Boolean, index: true }\n *     });\n *```\n *\n * @param {String} model Name of model\n * @options {Object} properties JSON object specifying properties.  Each property is a key whos value is\n * either the [type](http://docs.strongloop.com/display/LB/LoopBack+types) or `propertyName: {options}`\n * where the options are described below.\n * @property {String} type Datatype of property: Must be an [LDL type](http://docs.strongloop.com/display/LB/LoopBack+types).\n * @property {Boolean} index True if the property is an index; false otherwise.\n */\nModelBuilder.prototype.extendModel = function(model, props) {\n  var t = this;\n  var keys = Object.keys(props);\n  for (var i = 0; i < keys.length; i++) {\n    var definition = props[keys[i]];\n    t.defineProperty(model, keys[i], definition);\n  }\n};\n\nModelBuilder.prototype.copyModel = function copyModel(Master) {\n  var modelBuilder = this;\n  var className = Master.modelName;\n  var md = Master.modelBuilder.definitions[className];\n  var Slave = function SlaveModel() {\n    Master.apply(this, [].slice.call(arguments));\n  };\n\n  util.inherits(Slave, Master);\n\n  Slave.__proto__ = Master;\n\n  hiddenProperty(Slave, 'modelBuilder', modelBuilder);\n  hiddenProperty(Slave, 'modelName', className);\n  hiddenProperty(Slave, 'relations', Master.relations);\n\n  if (!(className in modelBuilder.models)) {\n    // store class in model pool\n    modelBuilder.models[className] = Slave;\n    modelBuilder.definitions[className] = {\n      properties: md.properties,\n      settings: md.settings,\n    };\n  }\n\n  return Slave;\n};\n\n/*!\n * Define hidden property\n */\nfunction hiddenProperty(where, property, value) {\n  Object.defineProperty(where, property, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: value,\n  });\n}\n\n/**\n * Get the schema name\n */\nModelBuilder.prototype.getSchemaName = function(name) {\n  if (name) {\n    return name;\n  }\n  if (typeof this._nameCount !== 'number') {\n    this._nameCount = 0;\n  } else {\n    this._nameCount++;\n  }\n  return 'AnonymousModel_' + this._nameCount;\n};\n\n/**\n * Resolve the type string to be a function, for example, 'String' to String.\n * Returns {Function} if the type is resolved\n * @param {String} type The type string, such as 'number', 'Number', 'boolean', or 'String'. It's case insensitive\n */\nModelBuilder.prototype.resolveType = function(type) {\n  if (!type) {\n    return type;\n  }\n  if (Array.isArray(type) && type.length > 0) {\n    // For array types, the first item should be the type string\n    var itemType = this.resolveType(type[0]);\n    if (typeof itemType === 'function') {\n      return [itemType];\n    } else {\n      return itemType; // Not resolved, return the type string\n    }\n  }\n  if (typeof type === 'string') {\n    var schemaType = ModelBuilder.schemaTypes[type.toLowerCase()] || this.models[type];\n    if (schemaType) {\n      return schemaType;\n    } else {\n      // The type cannot be resolved, let's create a place holder\n      type = this.define(type, {}, {unresolved: true});\n      return type;\n    }\n  } else if (type.constructor.name === 'Object') {\n    // We also support the syntax {type: 'string', ...}\n    if (type.type) {\n      return this.resolveType(type.type);\n    } else {\n      return this.define(this.getSchemaName(null),\n        type, {\n          anonymous: true,\n          idInjection: false,\n          strict: this.settings.strictEmbeddedModels || false,\n        });\n    }\n  } else if ('function' === typeof type) {\n    return type;\n  }\n  return type;\n};\n\n/**\n * Build models from schema definitions\n *\n * `schemas` can be one of the following:\n *\n * 1. An array of named schema definition JSON objects\n * 2. A schema definition JSON object\n * 3. A list of property definitions (anonymous)\n *\n * @param {*} schemas The schemas\n * @returns {Object} A map of model constructors keyed by model name\n */\nModelBuilder.prototype.buildModels = function(schemas, createModel) {\n  var models = {};\n\n  // Normalize the schemas to be an array of the schema objects {name: <name>, properties: {}, options: {}}\n  if (!Array.isArray(schemas)) {\n    if (schemas.properties && schemas.name) {\n      // Only one item\n      schemas = [schemas];\n    } else {\n      // Anonymous schema\n      schemas = [\n        {\n          name: this.getSchemaName(),\n          properties: schemas,\n          options: {anonymous: true},\n        },\n      ];\n    }\n  }\n\n  var relations = [];\n  for (var s = 0, n = schemas.length; s < n; s++) {\n    var name = this.getSchemaName(schemas[s].name);\n    schemas[s].name = name;\n    var model;\n    if (typeof createModel === 'function') {\n      model = createModel(schemas[s].name, schemas[s].properties, schemas[s].options);\n    } else {\n      model = this.define(schemas[s].name, schemas[s].properties, schemas[s].options);\n    }\n    models[name] = model;\n    relations = relations.concat(model.definition.relations);\n  }\n\n  // Connect the models based on the relations\n  for (var i = 0; i < relations.length; i++) {\n    var relation = relations[i];\n    var sourceModel = models[relation.source];\n    var targetModel = models[relation.target];\n    if (sourceModel && targetModel) {\n      if (typeof sourceModel[relation.type] === 'function') {\n        sourceModel[relation.type](targetModel, {as: relation.as});\n      }\n    }\n  }\n  return models;\n};\n\n/**\n * Introspect the JSON document to build a corresponding model.\n * @param {String} name The model name\n * @param {Object} json The JSON object\n * @param {Object} options The options\n * @returns {}\n */\nModelBuilder.prototype.buildModelFromInstance = function(name, json, options) {\n  // Introspect the JSON document to generate a schema\n  var schema = introspect(json);\n\n  // Create a model for the generated schema\n  return this.define(name, schema, options);\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/model.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n// Turning on strict for this file breaks lots of test cases;\n// disabling strict for this file\n/* eslint-disable strict */\n\n/*!\n * Module exports class Model\n */\nmodule.exports = ModelBaseClass;\n\n/*!\n * Module dependencies\n */\n\nvar g = require('strong-globalize')();\nvar util = require('util');\nvar jutil = require('./jutil');\nvar List = require('./list');\nvar Hookable = require('./hooks');\nvar validations = require('./validations');\nvar _extend = util._extend;\nvar utils = require('./utils');\nvar fieldsToArray = utils.fieldsToArray;\nvar uuid = require('uuid');\nvar shortid = require('shortid');\n\n// Set up an object for quick lookup\nvar BASE_TYPES = {\n  'String': true,\n  'Boolean': true,\n  'Number': true,\n  'Date': true,\n  'Text': true,\n  'ObjectID': true,\n};\n\n/**\n * Model class: base class for all persistent objects.\n *\n * `ModelBaseClass` mixes `Validatable` and `Hookable` classes methods\n *\n * @class\n * @param {Object} data Initial object data\n */\nfunction ModelBaseClass(data, options) {\n  options = options || {};\n  if (!('applySetters' in options)) {\n    // Default to true\n    options.applySetters = true;\n  }\n  if (!('applyDefaultValues' in options)) {\n    options.applyDefaultValues = true;\n  }\n  this._initProperties(data, options);\n}\n\n/**\n * Initialize the model instance with a list of properties\n * @param {Object} data The data object\n * @param {Object} options An object to control the instantiation\n * @property {Boolean} applySetters Controls if the setters will be applied\n * @property {Boolean} applyDefaultValues Default attributes and values will be applied\n * @property {Boolean} strict Set the instance level strict mode\n * @property {Boolean} persisted Whether the instance has been persisted\n * @private\n */\nModelBaseClass.prototype._initProperties = function(data, options) {\n  var self = this;\n  var ctor = this.constructor;\n                                     // issue#1261\n  if (typeof data !== 'undefined' && data.constructor &&\n      typeof (data.constructor) !== 'function') {\n    throw new Error(g.f('Property name \"{{constructor}}\" is not allowed in %s data', ctor.modelName));\n  }\n\n  if (data instanceof ctor) {\n    // Convert the data to be plain object to avoid pollutions\n    data = data.toObject(false);\n  }\n  var properties = _extend({}, ctor.definition.properties);\n  data = data || {};\n\n  if (typeof ctor.applyProperties === 'function') {\n    ctor.applyProperties(data);\n  }\n\n  options = options || {};\n  var applySetters = options.applySetters;\n  var applyDefaultValues = options.applyDefaultValues;\n  var strict = options.strict;\n\n  if (strict === undefined) {\n    strict = ctor.definition.settings.strict;\n  } else if (strict === 'throw') {\n    g.warn('Warning: Model %s, {{strict mode: `throw`}} has been removed, ' +\n      'please use {{`strict: true`}} instead, which returns' +\n      '{{`Validation Error`}} for unknown properties,', ctor.modelName);\n  }\n\n  var persistUndefinedAsNull = ctor.definition.settings.persistUndefinedAsNull;\n\n  if (ctor.hideInternalProperties) {\n    // Object.defineProperty() is expensive. We only try to make the internal\n    // properties hidden (non-enumerable) if the model class has the\n    // `hideInternalProperties` set to true\n    Object.defineProperties(this, {\n      __cachedRelations: {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {},\n      },\n\n      __data: {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {},\n      },\n\n      // Instance level data source\n      __dataSource: {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: options.dataSource,\n      },\n\n      // Instance level strict mode\n      __strict: {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: strict,\n      },\n\n      __persisted: {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: false,\n      },\n    });\n\n    if (strict) {\n      Object.defineProperty(this, '__unknownProperties', {\n        writable: true,\n        enumerable: false,\n        configrable: true,\n        value: [],\n      });\n    }\n  } else {\n    this.__cachedRelations = {};\n    this.__data = {};\n    this.__dataSource = options.dataSource;\n    this.__strict = strict;\n    this.__persisted = false;\n    if (strict) {\n      this.__unknownProperties = [];\n    }\n  }\n\n  if (options.persisted !== undefined) {\n    this.__persisted = options.persisted === true;\n  }\n\n  if (data.__cachedRelations) {\n    this.__cachedRelations = data.__cachedRelations;\n  }\n\n  var keys = Object.keys(data);\n\n  if (Array.isArray(options.fields)) {\n    keys = keys.filter(function(k) {\n      return (options.fields.indexOf(k) != -1);\n    });\n  }\n\n  var size = keys.length;\n  var p, propVal;\n  for (var k = 0; k < size; k++) {\n    p = keys[k];\n    propVal = data[p];\n    if (typeof propVal === 'function') {\n      continue;\n    }\n\n    if (propVal === undefined && persistUndefinedAsNull) {\n      propVal = null;\n    }\n\n    if (properties[p]) {\n      // Managed property\n      if (applySetters || properties[p].id) {\n        self[p] = propVal;\n      } else {\n        self.__data[p] = propVal;\n      }\n    } else if (ctor.relations[p]) {\n      var relationType = ctor.relations[p].type;\n\n      var modelTo;\n      if (!properties[p]) {\n        modelTo = ctor.relations[p].modelTo || ModelBaseClass;\n        var multiple = ctor.relations[p].multiple;\n        var typeName = multiple ? 'Array' : modelTo.modelName;\n        var propType = multiple ? [modelTo] : modelTo;\n        properties[p] = {name: typeName, type: propType};\n        /* Issue #1252\n        this.setStrict(false);\n        */\n      }\n\n      // Relation\n      if (relationType === 'belongsTo' && propVal != null) {\n        // If the related model is populated\n        self.__data[ctor.relations[p].keyFrom] = propVal[ctor.relations[p].keyTo];\n\n        if (ctor.relations[p].options.embedsProperties) {\n          var fields = fieldsToArray(ctor.relations[p].properties,\n            modelTo.definition.properties, modelTo.settings.strict);\n          if (!~fields.indexOf(ctor.relations[p].keyTo)) {\n            fields.push(ctor.relations[p].keyTo);\n          }\n          self.__data[p] = new modelTo(propVal, {\n            fields: fields,\n            applySetters: false,\n            persisted: options.persisted,\n          });\n        }\n      }\n\n      self.__cachedRelations[p] = propVal;\n    } else {\n      // Un-managed property\n      if (strict === false || self.__cachedRelations[p]) {\n        self[p] = self.__data[p] =\n          (propVal !== undefined) ? propVal : self.__cachedRelations[p];\n\n        // Throw error for properties with unsupported names\n        if (/\\./.test(p)) {\n          throw new Error(g.f(\n            'Property names containing dot(s) are not supported. ' +\n            'Model: %s, dynamic property: %s',\n            this.constructor.modelName, p\n          ));\n        }\n      } else {\n        if (strict !== 'filter') {\n          this.__unknownProperties.push(p);\n        }\n      }\n    }\n  }\n\n  keys = Object.keys(properties);\n\n  if (Array.isArray(options.fields)) {\n    keys = keys.filter(function(k) {\n      return (options.fields.indexOf(k) != -1);\n    });\n  }\n\n  size = keys.length;\n\n  for (k = 0; k < size; k++) {\n    p = keys[k];\n    propVal = self.__data[p];\n    var type = properties[p].type;\n\n    // Set default values\n    if (applyDefaultValues && propVal === undefined) {\n      var def = properties[p]['default'];\n      if (def !== undefined) {\n        if (typeof def === 'function') {\n          if (def === Date) {\n            // FIXME: We should coerce the value in general\n            // This is a work around to {default: Date}\n            // Date() will return a string instead of Date\n            def = new Date();\n          } else {\n            def = def();\n          }\n        } else if (type.name === 'Date' && def === '$now') {\n          def = new Date();\n        }\n        // FIXME: We should coerce the value\n        // will implement it after we refactor the PropertyDefinition\n        self.__data[p] = propVal = def;\n      }\n    }\n\n    // Set default value using a named function\n    if (applyDefaultValues && propVal === undefined) {\n      var defn = properties[p].defaultFn;\n      switch (defn) {\n        case undefined:\n          break;\n        case 'guid':\n        case 'uuid':\n          // Generate a v1 (time-based) id\n          propVal = uuid.v1();\n          break;\n        case 'uuidv4':\n          // Generate a RFC4122 v4 UUID\n          propVal = uuid.v4();\n          break;\n        case 'now':\n          propVal = new Date();\n          break;\n        case 'shortid':\n          propVal = shortid.generate();\n          break;\n        default:\n          // TODO Support user-provided functions via a registry of functions\n          g.warn('Unknown default value provider %s', defn);\n      }\n      // FIXME: We should coerce the value\n      // will implement it after we refactor the PropertyDefinition\n      if (propVal !== undefined)\n        self.__data[p] = propVal;\n    }\n\n    if (propVal === undefined && persistUndefinedAsNull) {\n      self.__data[p] = propVal = null;\n    }\n\n    // Handle complex types (JSON/Object)\n    if (!BASE_TYPES[type.name]) {\n      if (typeof self.__data[p] !== 'object' && self.__data[p]) {\n        try {\n          self.__data[p] = JSON.parse(self.__data[p] + '');\n        } catch (e) {\n          self.__data[p] = String(self.__data[p]);\n        }\n      }\n\n      if (type.prototype instanceof ModelBaseClass) {\n        if (!(self.__data[p] instanceof type) &&\n            typeof self.__data[p] === 'object' &&\n            self.__data[p] !== null) {\n          self.__data[p] = new type(self.__data[p]);\n        }\n      } else if (type.name === 'Array' || Array.isArray(type)) {\n        if (!(self.__data[p] instanceof List) &&\n            self.__data[p] !== undefined &&\n            self.__data[p] !== null) {\n          self.__data[p] = List(self.__data[p], type, self);\n        }\n      }\n    }\n  }\n  this.trigger('initialize');\n};\n\n/**\n * Define a property on the model.\n * @param {String} prop Property name\n * @param {Object} params Various property configuration\n */\nModelBaseClass.defineProperty = function(prop, params) {\n  if (this.dataSource) {\n    this.dataSource.defineProperty(this.modelName, prop, params);\n  } else {\n    this.modelBuilder.defineProperty(this.modelName, prop, params);\n  }\n};\n\nModelBaseClass.getPropertyType = function(propName) {\n  var prop = this.definition.properties[propName];\n  if (!prop) {\n    // The property is not part of the definition\n    return null;\n  }\n  if (!prop.type) {\n    throw new Error(g.f('Type not defined for property %s.%s', this.modelName, propName));\n    // return null;\n  }\n  return prop.type.name;\n};\n\nModelBaseClass.prototype.getPropertyType = function(propName) {\n  return this.constructor.getPropertyType(propName);\n};\n\n/**\n * Return string representation of class\n * This overrides the default `toString()` method\n */\nModelBaseClass.toString = function() {\n  return '[Model ' + this.modelName + ']';\n};\n\n/**\n * Convert model instance to a plain JSON object.\n * Returns a canonical object representation (no getters and setters).\n *\n * @param {Boolean} onlySchema Restrict properties to dataSource only.  Default is false.  If true, the function returns only properties defined in the schema;  Otherwise it returns all enumerable properties.\n */\nModelBaseClass.prototype.toObject = function(onlySchema, removeHidden, removeProtected) {\n  if (onlySchema === undefined) {\n    onlySchema = true;\n  }\n  var data = {};\n  var self = this;\n  var Model = this.constructor;\n\n  // if it is already an Object\n  if (Model === Object) {\n    return self;\n  }\n\n  var strict = this.__strict;\n  var schemaLess = (strict === false) || !onlySchema;\n  var persistUndefinedAsNull = Model.definition.settings.persistUndefinedAsNull;\n\n  var props = Model.definition.properties;\n  var keys = Object.keys(props);\n  var propertyName, val;\n\n  for (var i = 0; i < keys.length; i++) {\n    propertyName = keys[i];\n    val = self[propertyName];\n\n    // Exclude functions\n    if (typeof val === 'function') {\n      continue;\n    }\n    // Exclude hidden properties\n    if (removeHidden && Model.isHiddenProperty(propertyName)) {\n      continue;\n    }\n\n    if (removeProtected && Model.isProtectedProperty(propertyName)) {\n      continue;\n    }\n\n    if (val instanceof List) {\n      data[propertyName] = val.toObject(!schemaLess, removeHidden, true);\n    } else {\n      if (val !== undefined && val !== null && val.toObject) {\n        data[propertyName] = val.toObject(!schemaLess, removeHidden, true);\n      } else {\n        if (val === undefined && persistUndefinedAsNull) {\n          val = null;\n        }\n        data[propertyName] = val;\n      }\n    }\n  }\n\n  if (schemaLess) {\n    // Find its own properties which can be set via myModel.myProperty = 'myValue'.\n    // If the property is not declared in the model definition, no setter will be\n    // triggered to add it to __data\n    keys = Object.keys(self);\n    var size = keys.length;\n    for (i = 0; i < size; i++) {\n      propertyName = keys[i];\n      if (props[propertyName]) {\n        continue;\n      }\n      if (propertyName.indexOf('__') === 0) {\n        continue;\n      }\n      if (removeHidden && Model.isHiddenProperty(propertyName)) {\n        continue;\n      }\n      if (removeProtected && Model.isProtectedProperty(propertyName)) {\n        continue;\n      }\n      if (data[propertyName] !== undefined) {\n        continue;\n      }\n      val = self[propertyName];\n      if (val !== undefined) {\n        if (typeof val === 'function') {\n          continue;\n        }\n        if (val !== null && val.toObject) {\n          data[propertyName] = val.toObject(!schemaLess, removeHidden, true);\n        } else {\n          data[propertyName] = val;\n        }\n      } else if (persistUndefinedAsNull) {\n        data[propertyName] = null;\n      }\n    }\n    // Now continue to check __data\n    keys = Object.keys(self.__data);\n    size = keys.length;\n    for (i = 0; i < size; i++) {\n      propertyName = keys[i];\n      if (propertyName.indexOf('__') === 0) {\n        continue;\n      }\n      if (data[propertyName] === undefined) {\n        if (removeHidden && Model.isHiddenProperty(propertyName)) {\n          continue;\n        }\n        if (removeProtected && Model.isProtectedProperty(propertyName)) {\n          continue;\n        }\n        var ownVal = self[propertyName];\n        // The ownVal can be a relation function\n        val = (ownVal !== undefined && (typeof ownVal !== 'function')) ? ownVal : self.__data[propertyName];\n        if (typeof val === 'function') {\n          continue;\n        }\n\n        if (val !== undefined && val !== null && val.toObject) {\n          data[propertyName] = val.toObject(!schemaLess, removeHidden, true);\n        } else if (val === undefined && persistUndefinedAsNull) {\n          data[propertyName] = null;\n        } else {\n          data[propertyName] = val;\n        }\n      }\n    }\n  }\n\n  return data;\n};\n\nModelBaseClass.isProtectedProperty = function(propertyName) {\n  var Model = this;\n  var settings = Model.definition && Model.definition.settings;\n  var protectedProperties = settings && (settings.protectedProperties || settings.protected);\n  if (Array.isArray(protectedProperties)) {\n    // Cache the protected properties as an object for quick lookup\n    settings.protectedProperties = {};\n    for (var i = 0; i < protectedProperties.length; i++) {\n      settings.protectedProperties[protectedProperties[i]] = true;\n    }\n    protectedProperties = settings.protectedProperties;\n  }\n  if (protectedProperties) {\n    return protectedProperties[propertyName];\n  } else {\n    return false;\n  }\n};\n\nModelBaseClass.isHiddenProperty = function(propertyName) {\n  var Model = this;\n  var settings = Model.definition && Model.definition.settings;\n  var hiddenProperties = settings && (settings.hiddenProperties || settings.hidden);\n  if (Array.isArray(hiddenProperties)) {\n    // Cache the hidden properties as an object for quick lookup\n    settings.hiddenProperties = {};\n    for (var i = 0; i < hiddenProperties.length; i++) {\n      settings.hiddenProperties[hiddenProperties[i]] = true;\n    }\n    hiddenProperties = settings.hiddenProperties;\n  }\n  if (hiddenProperties) {\n    return hiddenProperties[propertyName];\n  } else {\n    return false;\n  }\n};\n\nModelBaseClass.prototype.toJSON = function() {\n  return this.toObject(false, true, false);\n};\n\nModelBaseClass.prototype.fromObject = function(obj) {\n  for (var key in obj) {\n    this[key] = obj[key];\n  }\n};\n\n/**\n * Reset dirty attributes.\n * This method does not perform any database operations; it just resets the object to its\n * initial state.\n */\nModelBaseClass.prototype.reset = function() {\n  var obj = this;\n  for (var k in obj) {\n    if (k !== 'id' && !obj.constructor.dataSource.definitions[obj.constructor.modelName].properties[k]) {\n      delete obj[k];\n    }\n  }\n};\n\n// Node v0.11+ allows custom inspect functions to return an object\n// instead of string. That way options like `showHidden` and `colors`\n// can be preserved.\nvar versionParts = process.versions && process.versions.node ?\n  process.versions.node.split(/\\./g).map(function(v) { return +v; }) :\n  [1, 0, 0]; // browserify ships 1.0-compatible version of util.inspect\n\nvar INSPECT_SUPPORTS_OBJECT_RETVAL =\n versionParts[0] > 0 ||\n versionParts[1] > 11 ||\n (versionParts[0] === 11 && versionParts[1] >= 14);\n\nModelBaseClass.prototype.inspect = function(depth) {\n  if (INSPECT_SUPPORTS_OBJECT_RETVAL)\n    return this.__data;\n\n  // Workaround for older versions\n  // See also https://github.com/joyent/node/commit/66280de133\n  return util.inspect(this.__data, {\n    showHidden: false,\n    depth: depth,\n    colors: false,\n  });\n};\n\nModelBaseClass.mixin = function(anotherClass, options) {\n  if (typeof anotherClass === 'string') {\n    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);\n  } else {\n    if (anotherClass.prototype instanceof ModelBaseClass) {\n      var props = anotherClass.definition.properties;\n      for (var i in props) {\n        if (this.definition.properties[i]) {\n          continue;\n        }\n        this.defineProperty(i, props[i]);\n      }\n    }\n    return jutil.mixin(this, anotherClass, options);\n  }\n};\n\nModelBaseClass.prototype.getDataSource = function() {\n  return this.__dataSource || this.constructor.dataSource;\n};\n\nModelBaseClass.getDataSource = function() {\n  return this.dataSource;\n};\n\nModelBaseClass.prototype.setStrict = function(strict) {\n  this.__strict = strict;\n};\n\n// Mixin observer\njutil.mixin(ModelBaseClass, require('./observer'));\n\njutil.mixin(ModelBaseClass, Hookable);\njutil.mixin(ModelBaseClass, validations.Validatable);\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/jutil.js":"// Copyright IBM Corp. 2011,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar util = require('util');\n\n/**\n *\n * @param newClass\n * @param baseClass\n */\nexports.inherits = function(newClass, baseClass, options) {\n  util.inherits(newClass, baseClass);\n\n  options = options || {\n    staticProperties: true,\n    override: false,\n  };\n\n  if (options.staticProperties) {\n    Object.keys(baseClass).forEach(function(classProp) {\n      if (classProp !== 'super_' && (!newClass.hasOwnProperty(classProp) ||\n          options.override)) {\n        var pd = Object.getOwnPropertyDescriptor(baseClass, classProp);\n        Object.defineProperty(newClass, classProp, pd);\n      }\n    });\n  }\n};\n\n/**\n * Mix in the a class into the new class\n * @param newClass The target class to receive the mixin\n * @param mixinClass The class to be mixed in\n * @param options\n */\nexports.mixin = function(newClass, mixinClass, options) {\n  if (Array.isArray(newClass._mixins)) {\n    if (newClass._mixins.indexOf(mixinClass) !== -1) {\n      return;\n    }\n    newClass._mixins.push(mixinClass);\n  } else {\n    newClass._mixins = [mixinClass];\n  }\n\n  options = options || {\n    staticProperties: true,\n    instanceProperties: true,\n    override: false,\n    proxyFunctions: false,\n  };\n\n  if (options.staticProperties === undefined) {\n    options.staticProperties = true;\n  }\n\n  if (options.instanceProperties === undefined) {\n    options.instanceProperties = true;\n  }\n\n  if (options.staticProperties) {\n    mixInto(mixinClass, newClass, options);\n  }\n\n  if (options.instanceProperties && mixinClass.prototype) {\n    mixInto(mixinClass.prototype, newClass.prototype, options);\n  }\n\n  return newClass;\n};\n\nfunction mixInto(sourceScope, targetScope, options) {\n  Object.keys(sourceScope).forEach(function(propertyName) {\n    var targetPropertyExists = targetScope.hasOwnProperty(propertyName);\n    var sourceProperty = Object.getOwnPropertyDescriptor(sourceScope, propertyName);\n    var targetProperty = targetPropertyExists && Object.getOwnPropertyDescriptor(targetScope, propertyName);\n    var sourceIsFunc = typeof sourceProperty.value === 'function';\n    var isFunc = targetPropertyExists && typeof targetProperty.value === 'function';\n    var isDelegate = isFunc && targetProperty.value._delegate;\n    var shouldOverride = options.override || !targetPropertyExists || isDelegate;\n\n    if (propertyName == '_mixins') {\n      mergeMixins(sourceScope._mixins, targetScope._mixins);\n      return;\n    }\n\n    if (shouldOverride) {\n      Object.defineProperty(targetScope, propertyName, sourceProperty);\n    }\n  });\n}\n\nfunction mergeMixins(source, target) {\n  // hand-written equivalent of lodash.union()\n  for (var ix in source) {\n    var mx = source[ix];\n    if (target.indexOf(mx) === -1)\n      target.push(mx);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/list.js":"// Copyright IBM Corp. 2012,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar g = require('strong-globalize')();\nvar util = require('util');\nvar Any = require('./types').Types.Any;\n\nmodule.exports = List;\n\nfunction List(items, itemType, parent) {\n  var list = this;\n  if (!(list instanceof List)) {\n    return new List(items, itemType, parent);\n  }\n\n  if (typeof items === 'string') {\n    try {\n      items = JSON.parse(items);\n    } catch (e) {\n      const err = new Error(g.f('could not create List from JSON string: %j', items));\n      err.statusCode = 400;\n      throw err;\n    }\n  }\n\n  var arr = [];\n  arr.__proto__ = List.prototype;\n\n  items = items || [];\n  if (!Array.isArray(items)) {\n    const err = new Error(g.f('Items must be an array: %j', items));\n    err.statusCode = 400;\n    throw err;\n  }\n\n  if (!itemType) {\n    itemType = items[0] && items[0].constructor;\n  }\n\n  if (Array.isArray(itemType)) {\n    itemType = itemType[0];\n  }\n\n  if (itemType === Array) {\n    itemType = Any;\n  }\n\n  Object.defineProperty(arr, 'itemType', {\n    writable: true,\n    enumerable: false,\n    value: itemType,\n  });\n\n  if (parent) {\n    Object.defineProperty(arr, 'parent', {\n      writable: true,\n      enumerable: false,\n      value: parent,\n    });\n  }\n\n  items.forEach(function(item, i) {\n    if (itemType && !(item instanceof itemType)) {\n      arr[i] = itemType(item);\n    } else {\n      arr[i] = item;\n    }\n  });\n\n  return arr;\n}\n\nutil.inherits(List, Array);\n\nvar _push = List.prototype.push;\n\nList.prototype.push = function(obj) {\n  var item = this.itemType && (obj instanceof this.itemType) ? obj : this.itemType(obj);\n  _push.call(this, item);\n  return item;\n};\n\nList.prototype.toObject = function(onlySchema, removeHidden, removeProtected) {\n  var items = [];\n  this.forEach(function(item) {\n    if (item && typeof item === 'object' && item.toObject) {\n      items.push(item.toObject(onlySchema, removeHidden, removeProtected));\n    } else {\n      items.push(item);\n    }\n  });\n  return items;\n};\n\nList.prototype.toJSON = function() {\n  return this.toObject(true);\n};\n\nList.prototype.toString = function() {\n  return JSON.stringify(this.toJSON());\n};\n\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/types.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar Types = {};\n/**\n * Schema types\n */\nTypes.Text = function Text(value) {\n  if (!(this instanceof Text)) {\n    return value;\n  }\n  this.value = value;\n}; // Text type\n\nTypes.Text.prototype.toObject = Types.Text.prototype.toJSON = function() {\n  return this.value;\n};\n\nTypes.JSON = function JSON(value) {\n  if (!(this instanceof JSON)) {\n    return value;\n  }\n  this.value = value;\n}; // JSON Object\nTypes.JSON.prototype.toObject = Types.JSON.prototype.toJSON = function() {\n  return this.value;\n};\n\nTypes.Any = function Any(value) {\n  if (!(this instanceof Any)) {\n    return value;\n  }\n  this.value = value;\n}; // Any Type\nTypes.Any.prototype.toObject = Types.Any.prototype.toJSON = function() {\n  return this.value;\n};\n\nmodule.exports = function(modelTypes) {\n  var GeoPoint = require('./geo').GeoPoint;\n\n  for (var t in Types) {\n    modelTypes[t] = Types[t];\n  }\n\n  modelTypes.schemaTypes = {};\n  modelTypes.registerType = function(type, names) {\n    names = names || [];\n    names = names.concat([type.name]);\n    for (var n = 0; n < names.length; n++) {\n      this.schemaTypes[names[n].toLowerCase()] = type;\n    }\n  };\n\n  modelTypes.registerType(Types.Text);\n  modelTypes.registerType(Types.JSON);\n  modelTypes.registerType(Types.Any);\n\n  modelTypes.registerType(String);\n  modelTypes.registerType(Number);\n  modelTypes.registerType(Boolean);\n  modelTypes.registerType(Date);\n  modelTypes.registerType(Buffer, ['Binary']);\n  modelTypes.registerType(Array);\n  modelTypes.registerType(GeoPoint);\n  modelTypes.registerType(Object);\n};\n\nmodule.exports.Types = Types;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/hooks.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar deprecated = require('depd')('loopback-datasource-juggler');\nvar g = require('strong-globalize')();\n\n/*!\n * Module exports\n */\nmodule.exports = Hookable;\n\n/*\n * Hooks object.\n * @class Hookable\n */\n\nfunction Hookable() {\n}\n\n/**\n * List of hooks available\n */\nHookable.afterInitialize = null;\nHookable.beforeValidate = null;\nHookable.afterValidate = null;\nHookable.beforeSave = null;\nHookable.afterSave = null;\nHookable.beforeCreate = null;\nHookable.afterCreate = null;\nHookable.beforeUpdate = null;\nHookable.afterUpdate = null;\nHookable.beforeDestroy = null;\nHookable.afterDestroy = null;\n\n// TODO: Evaluate https://github.com/bnoguchi/hooks-js/\nHookable.prototype.trigger = function trigger(actionName, work, data, callback) {\n  var capitalizedName = capitalize(actionName);\n  var beforeHook = this.constructor['before' + capitalizedName] ||\n    this.constructor['pre' + capitalizedName];\n  var afterHook = this.constructor['after' + capitalizedName] ||\n    this.constructor['post' + capitalizedName];\n  if (actionName === 'validate') {\n    beforeHook = beforeHook || this.constructor.beforeValidation;\n    afterHook = afterHook || this.constructor.afterValidation;\n  }\n  var inst = this;\n\n  if (actionName !== 'initialize') {\n    if (beforeHook)\n      deprecateHook(inst.constructor, ['before', 'pre'], capitalizedName);\n    if (afterHook)\n      deprecateHook(inst.constructor, ['after', 'post'], capitalizedName);\n  }\n\n  // we only call \"before\" hook when we have actual action (work) to perform\n  if (work) {\n    if (beforeHook) {\n      // before hook should be called on instance with two parameters: next and data\n      beforeHook.call(inst, function() {\n        // Check arguments to next(err, result)\n        if (arguments.length) {\n          return callback && callback.apply(null, arguments);\n        }\n        // No err & result is present, proceed with the real work\n        // actual action also have one param: callback\n        work.call(inst, next);\n      }, data);\n    } else {\n      work.call(inst, next);\n    }\n  } else {\n    next();\n  }\n\n  function next(done) {\n    if (afterHook) {\n      afterHook.call(inst, done);\n    } else if (done) {\n      done.call(this);\n    }\n  }\n};\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction deprecateHook(ctor, prefixes, capitalizedName) {\n  var candidateNames = prefixes.map(function(p) { return p + capitalizedName; });\n  if (capitalizedName === 'Validate')\n    candidateNames.push(prefixes[0] + 'Validation');\n\n  var hookName = candidateNames.filter(function(hook) { return !!ctor[hook]; })[0];\n  if (!hookName) return; // just to be sure, this should never happen\n  if (ctor.modelName) hookName  = ctor.modelName + '.' + hookName;\n  deprecated(g.f('Model hook \"%s\" is deprecated, ' +\n    'use Operation hooks instead. ' +\n    '{{http://docs.strongloop.com/display/LB/Operation+hooks}}', hookName));\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/validations.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar g = require('strong-globalize')();\nvar util = require('util');\nvar extend = util._extend;\n\n/*!\n * Module exports\n */\nexports.ValidationError = ValidationError;\nexports.Validatable = Validatable;\n\n/**\n * This class provides methods that add validation cababilities to models.\n * Each of the validations runs when the `obj.isValid()` method is called.\n *\n * All of the methods have an options object parameter that has a\n * `message` property.  When there is only a single error message, this property is just a string;\n * for example: `Post.validatesPresenceOf('title', { message: 'can not be blank' });`\n *\n * In more complicated cases it can be a set of messages, for each possible error condition; for example:\n * `User.validatesLengthOf('password', { min: 6, max: 20, message: {min: 'too short', max: 'too long'}});`\n * @class Validatable\n */\nfunction Validatable() {\n}\n\n/**\n * Validate presence of one or more specified properties.\n * Requires a model to include a property to be considered valid; fails when validated field is blank.\n *\n * For example, validate presence of title\n * ```\n * Post.validatesPresenceOf('title');\n * ```\n * Validate that model has first, last, and age properties:\n * ```\n * User.validatesPresenceOf('first', 'last', 'age');\n * ```\n * Example with custom message\n * ```\n * Post.validatesPresenceOf('title', {message: 'Cannot be blank'});\n * ```\n *\n * @param {String} propertyName  One or more property names.\n * @options {Object} errMsg Optional custom error message.  Default is \"can't be blank\"\n * @property {String} message Error message to use instead of default.\n */\nValidatable.validatesPresenceOf = getConfigurator('presence');\n\n/**\n * Validate absence of one or more specified properties.\n * A model should not include a property to be considered valid; fails when validated field not blank.\n *\n * For example, validate absence of reserved\n * ```\n * Post.validatesAbsenceOf('reserved', { unless: 'special' });\n * ```\n * @param {String} propertyName  One or more property names.\n * @options {Object} errMsg Optional custom error message.  Default is \"can't be set\"\n * @property {String} message Error message to use instead of default.\n */\nValidatable.validatesAbsenceOf = getConfigurator('absence');\n\n/**\n * Validate length. Require a property length to be within a specified range.\n * Three kinds of validations: min, max, is.\n *\n * Default error messages:\n *\n * - min: too short\n * - max: too long\n * - is:  length is wrong\n *\n * Example: length validations\n * ```\n * User.validatesLengthOf('password', {min: 7});\n * User.validatesLengthOf('email', {max: 100});\n * User.validatesLengthOf('state', {is: 2});\n * User.validatesLengthOf('nick', {min: 3, max: 15});\n * ```\n * Example: length validations with custom error messages\n * ```\n * User.validatesLengthOf('password', {min: 7, message: {min: 'too weak'}});\n * User.validatesLengthOf('state', {is: 2, message: {is: 'is not valid state name'}});\n * ```\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options See below.\n * @property {Number} is Value that property must equal to validate.\n * @property {Number} min Value that property must be less than to be valid.\n * @property {Number} max Value that property must be less than to be valid.\n * @property {Object} message Optional Object with string properties for custom error message for each validation: is, min, or max\n */\nValidatable.validatesLengthOf = getConfigurator('length');\n\n/**\n * Validate numericality.  Requires a value for property to be either an integer or number.\n *\n * Example\n * ```\n * User.validatesNumericalityOf('age', { message: { number: '...' }});\n * User.validatesNumericalityOf('age', {int: true, message: { int: '...' }});\n * ```\n *\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options See below.\n * @property {Boolean} int If true, then property must be an integer to be valid.\n * @property {Object} message Optional object with string properties for 'int' for integer validation.  Default error messages:\n *\n * - number: is not a number\n * - int: is not an integer\n */\nValidatable.validatesNumericalityOf = getConfigurator('numericality');\n\n/**\n * Validate inclusion in set.  Require a value for property to be in the specified array.\n *\n * Example:\n * ```\n * User.validatesInclusionOf('gender', {in: ['male', 'female']});\n * User.validatesInclusionOf('role', {\n *     in: ['admin', 'moderator', 'user'], message: 'is not allowed'\n * });\n * ```\n *\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options See below\n * @property {Array} inArray Property must match one of the values in the array to be valid.\n * @property {String} message Optional error message if property is not valid.\n * Default error message: \"is not included in the list\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validatesInclusionOf = getConfigurator('inclusion');\n\n/**\n * Validate exclusion.  Require a property value not be in the specified array.\n *\n * Example: `Company.validatesExclusionOf('domain', {in: ['www', 'admin']});`\n *\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options\n * @property {Array} in Property must not match any of the values in the array to be valid.\n * @property {String} message Optional error message if property is not valid.  Default error message: \"is reserved\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validatesExclusionOf = getConfigurator('exclusion');\n\n/**\n * Validate format. Require a model to include a property that matches the given format.\n *\n * Require a model to include a property that matches the given format.  Example:\n * `User.validatesFormatOf('name', {with: /\\w+/});`\n *\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options\n * @property {RegExp} with Regular expression to validate format.\n * @property {String} message Optional error message if property is not valid.  Default error message: \" is invalid\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validatesFormatOf = getConfigurator('format');\n\n/**\n * Validate using custom validation function.\n *\n * Example:\n *\n *     User.validate('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err) {\n *         if (this.name === 'bad') err();\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // true\n *     user.name = 'bad';\n *     user.isValid(); // false\n *\n * @param {String} propertyName  Property name to validate.\n * @param {Function} validatorFn Custom validation function.\n * @options {Object} Options See below.\n * @property {String} message Optional error message if property is not valid.  Default error message: \" is invalid\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validate = getConfigurator('custom');\n\n/**\n * Validate using custom asynchronous validation function.\n *\n *\n * Example:\n *```js\n *     User.validateAsync('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err, done) {\n *         process.nextTick(function () {\n *             if (this.name === 'bad') err();\n *             done();\n *         });\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // false (because async validation setup)\n *     user.isValid(function (isValid) {\n *         isValid; // true\n *     })\n *     user.name = 'bad';\n *     user.isValid(); // false\n *     user.isValid(function (isValid) {\n *         isValid; // false\n *     })\n *```\n * @param {String} propertyName  Property name to validate.\n * @param {Function} validatorFn Custom validation function.\n * @options {Object} Options See below\n * @property {String} message Optional error message if property is not valid.  Default error message: \" is invalid\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validateAsync = getConfigurator('custom', {async: true});\n\n/**\n * Validate uniqueness. Ensure the value for property is unique in the collection of models.\n * Not available for all connectors. Currently supported with these connectors:\n *  - In Memory\n *  - Oracle\n *  - MongoDB\n *\n * ```\n * // The login must be unique across all User instances.\n * User.validatesUniquenessOf('login');\n *\n * // Assuming SiteUser.belongsTo(Site)\n * // The login must be unique within each Site.\n * SiteUser.validateUniquenessOf('login', { scopedTo: ['siteId'] });\n * ```\n\n * @param {String} propertyName  Property name to validate.\n * @options {Object} Options See below.\n * @property {RegExp} with Regular expression to validate format.\n * @property {Array.<String>} scopedTo List of properties defining the scope.\n * @property {String} message Optional error message if property is not valid.  Default error message: \"is not unique\".\n * @property {Boolean} allowNull Whether null values are allowed.\n */\nValidatable.validatesUniquenessOf = getConfigurator('uniqueness', {async: true});\n\n// implementation of validators\n\n/*!\n * Presence validator\n */\nfunction validatePresence(attr, conf, err, options) {\n  if (blank(this[attr])) {\n    err();\n  }\n}\n\n/*!\n * Absence validator\n */\nfunction validateAbsence(attr, conf, err, options) {\n  if (!blank(this[attr])) {\n    err();\n  }\n}\n\n/*!\n * Length validator\n */\nfunction validateLength(attr, conf, err, options) {\n  if (nullCheck.call(this, attr, conf, err)) return;\n\n  var len = this[attr].length;\n  if (conf.min && len < conf.min) {\n    err('min');\n  }\n  if (conf.max && len > conf.max) {\n    err('max');\n  }\n  if (conf.is && len !== conf.is) {\n    err('is');\n  }\n}\n\n/*!\n * Numericality validator\n */\nfunction validateNumericality(attr, conf, err, options) {\n  if (nullCheck.call(this, attr, conf, err)) return;\n\n  if (typeof this[attr] !== 'number' || isNaN(this[attr])) {\n    return err('number');\n  }\n  if (conf.int && this[attr] !== Math.round(this[attr])) {\n    return err('int');\n  }\n}\n\n/*!\n * Inclusion validator\n */\nfunction validateInclusion(attr, conf, err, options) {\n  if (nullCheck.call(this, attr, conf, err)) return;\n\n  if (!~conf.in.indexOf(this[attr])) {\n    err();\n  }\n}\n\n/*!\n * Exclusion validator\n */\nfunction validateExclusion(attr, conf, err, options) {\n  if (nullCheck.call(this, attr, conf, err)) return;\n\n  if (~conf.in.indexOf(this[attr])) {\n    err();\n  }\n}\n\n/*!\n * Format validator\n */\nfunction validateFormat(attr, conf, err, options) {\n  if (nullCheck.call(this, attr, conf, err)) return;\n\n  if (typeof this[attr] === 'string') {\n    if (!this[attr].match(conf['with'])) {\n      err();\n    }\n  } else {\n    err();\n  }\n}\n\n/*!\n * Custom validator\n */\nfunction validateCustom(attr, conf, err, options, done) {\n  if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n  conf.customValidator.call(this, err, done);\n}\n\n/*!\n * Uniqueness validator\n */\nfunction validateUniqueness(attr, conf, err, options, done) {\n  if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n  if (blank(this[attr])) {\n    return process.nextTick(done);\n  }\n  var cond = {where: {}};\n  cond.where[attr] = this[attr];\n\n  if (conf && conf.scopedTo) {\n    conf.scopedTo.forEach(function(k) {\n      var val = this[k];\n      if (val !== undefined)\n        cond.where[k] = this[k];\n    }, this);\n  }\n\n  var idName = this.constructor.definition.idName();\n  var isNewRecord = this.isNewRecord();\n  this.constructor.find(cond, options, function(error, found) {\n    if (error) {\n      err(error);\n    } else if (found.length > 1) {\n      err();\n    } else if (found.length === 1 && idName === attr && isNewRecord) {\n      err();\n    } else if (found.length === 1 && (\n      !this.id || !found[0].id || found[0].id.toString() != this.id.toString()\n    )) {\n      err();\n    }\n    done();\n  }.bind(this));\n}\n\nvar validators = {\n  presence: validatePresence,\n  absence: validateAbsence,\n  length: validateLength,\n  numericality: validateNumericality,\n  inclusion: validateInclusion,\n  exclusion: validateExclusion,\n  format: validateFormat,\n  custom: validateCustom,\n  uniqueness: validateUniqueness,\n};\n\nfunction getConfigurator(name, opts) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = args[1] || {};\n    configure(this, name, args, opts);\n  };\n}\n\n/**\n * This method performs validation and triggers validation hooks.\n * Before validation the `obj.errors` collection is cleaned.\n * Each validation can add errors to `obj.errors` collection.\n * If collection is not blank, validation failed.\n *\n * NOTE: This method can be called as synchronous only when no asynchronous validation is\n * configured. It's strongly recommended to run all validations as asyncronous.\n *\n * Example: ExpressJS controller: render user if valid, show flash otherwise\n * ```\n * user.isValid(function (valid) {\n *     if (valid) res.render({user: user});\n *     else res.flash('error', 'User is not valid'), console.log(user.errors), res.redirect('/users');\n * });\n * ```\n * Another example:\n * ```\n * user.isValid(function (valid) {\n *     if (!valid) {\n *           console.log(user.errors);\n *         // => hash of errors\n *         // => {\n *         // => username: [errmessage, errmessage, ...],\n *         // => email: ...\n *         // => }\n *     }\n * });\n * ```\n * @param {Function} callback called with (valid)\n * @returns {Boolean} True if no asynchronous validation is configured and all properties pass validation.\n */\nValidatable.prototype.isValid = function(callback, data, options) {\n  options = options || {};\n  var valid = true, inst = this, wait = 0, async = false;\n  var validations = this.constructor.validations;\n\n  var reportDiscardedProperties = this.__strict &&\n    this.__unknownProperties && this.__unknownProperties.length;\n\n  // exit with success when no errors\n  if (typeof validations !== 'object' && !reportDiscardedProperties) {\n    cleanErrors(this);\n    if (callback) {\n      this.trigger('validate', function(validationsDone) {\n        validationsDone.call(inst, function() {\n          callback(valid);\n        });\n      }, data, callback);\n    }\n    return valid;\n  }\n\n  Object.defineProperty(this, 'errors', {\n    enumerable: false,\n    configurable: true,\n    value: new Errors,\n  });\n\n  this.trigger('validate', function(validationsDone) {\n    var inst = this,\n      asyncFail = false;\n\n    var attrs = Object.keys(validations || {});\n\n    attrs.forEach(function(attr) {\n      var attrValidations = validations[attr] || [];\n      attrValidations.forEach(function(v) {\n        if (v.options && v.options.async) {\n          async = true;\n          wait += 1;\n          process.nextTick(function() {\n            validationFailed(inst, attr, v, options, done);\n          });\n        } else {\n          if (validationFailed(inst, attr, v)) {\n            valid = false;\n          }\n        }\n      });\n    });\n\n    if (reportDiscardedProperties) {\n      for (var ix in inst.__unknownProperties) {\n        var key = inst.__unknownProperties[ix];\n        var code = 'unknown-property';\n        var msg = defaultMessages[code];\n        inst.errors.add(key, msg, code);\n        valid = false;\n      }\n    }\n\n    if (!async) {\n      validationsDone.call(inst, function() {\n        if (valid) cleanErrors(inst);\n        if (callback) {\n          callback(valid);\n        }\n      });\n    }\n\n    function done(fail) {\n      asyncFail = asyncFail || fail;\n      if (--wait === 0) {\n        validationsDone.call(inst, function() {\n          if (valid && !asyncFail) cleanErrors(inst);\n          if (callback) {\n            callback(valid && !asyncFail);\n          }\n        });\n      }\n    }\n  }, data, callback);\n\n  if (async) {\n    // in case of async validation we should return undefined here,\n    // because not all validations are finished yet\n    return;\n  } else {\n    return valid;\n  }\n};\n\nfunction cleanErrors(inst) {\n  Object.defineProperty(inst, 'errors', {\n    enumerable: false,\n    configurable: true,\n    value: false,\n  });\n}\n\nfunction validationFailed(inst, attr, conf, options, cb) {\n  var opts = conf.options || {};\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (typeof attr !== 'string') return false;\n\n  // here we should check skip validation conditions (if, unless)\n  // that can be specified in conf\n  if (skipValidation(inst, conf, 'if') ||\n      skipValidation(inst, conf, 'unless')) {\n    if (cb) cb(false);\n    return false;\n  }\n\n  var fail = false;\n  var validator = validators[conf.validation];\n  var validatorArguments = [];\n  validatorArguments.push(attr);\n  validatorArguments.push(conf);\n  validatorArguments.push(function onerror(kind) {\n    var message, code = conf.code || conf.validation;\n    if (conf.message) {\n      message = conf.message;\n    }\n    if (!message && defaultMessages[conf.validation]) {\n      message = defaultMessages[conf.validation];\n    }\n    if (!message) {\n      message = 'is invalid';\n    }\n    if (kind) {\n      code += '.' + kind;\n      if (message[kind]) {\n        // get deeper\n        message = message[kind];\n      } else if (defaultMessages.common[kind]) {\n        message = defaultMessages.common[kind];\n      } else {\n        message = 'is invalid';\n      }\n    }\n    if (kind !== false) inst.errors.add(attr, message, code);\n    fail = true;\n  });\n  validatorArguments.push(options);\n  if (cb) {\n    validatorArguments.push(function() {\n      cb(fail);\n    });\n  }\n  validator.apply(inst, validatorArguments);\n  return fail;\n}\n\nfunction skipValidation(inst, conf, kind) {\n  var doValidate = true;\n  if (typeof conf[kind] === 'function') {\n    doValidate = conf[kind].call(inst);\n    if (kind === 'unless') doValidate = !doValidate;\n  } else if (typeof conf[kind] === 'string') {\n    if (typeof inst[conf[kind]] === 'function') {\n      doValidate = inst[conf[kind]].call(inst);\n      if (kind === 'unless') doValidate = !doValidate;\n    } else if (inst.__data.hasOwnProperty(conf[kind])) {\n      doValidate = inst[conf[kind]];\n      if (kind === 'unless') doValidate = !doValidate;\n    } else {\n      doValidate = kind === 'if';\n    }\n  }\n  return !doValidate;\n}\n\nvar defaultMessages = {\n  presence: 'can\\'t be blank',\n  absence: 'can\\'t be set',\n  'unknown-property': 'is not defined in the model',\n  length: {\n    min: 'too short',\n    max: 'too long',\n    is: 'length is wrong',\n  },\n  common: {\n    blank: 'is blank',\n    'null': 'is null',\n  },\n  numericality: {\n    'int': 'is not an integer',\n    'number': 'is not a number',\n  },\n  inclusion: 'is not included in the list',\n  exclusion: 'is reserved',\n  uniqueness: 'is not unique',\n};\n\n/**\n * Checks if attribute is undefined or null. Calls err function with 'blank' or 'null'.\n * See defaultMessages. You can affect this behaviour with conf.allowBlank and conf.allowNull.\n * @param {String} attr Property name of attribute\n * @param {Object} conf conf object for validator\n * @param {Function} err\n * @return {Boolean} returns true if attribute is null or blank\n */\nfunction nullCheck(attr, conf, err) {\n  // First determine if attribute is defined\n  if (typeof this[attr] === 'undefined') {\n    if (!conf.allowBlank) {\n      err('blank');\n    }\n    return true;\n  } else {\n    // Now check if attribute is null\n    if (this[attr] === null) {\n      if (!conf.allowNull) {\n        err('null');\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/*!\n * Return true when v is undefined, blank array, null or empty string\n * otherwise returns false\n *\n * @param {Mix} v\n * Returns true if `v` is blank.\n */\nfunction blank(v) {\n  if (typeof v === 'undefined') return true;\n  if (v instanceof Array && v.length === 0) return true;\n  if (v === null) return true;\n  if (typeof v === 'number' && isNaN(v)) return true;\n  if (typeof v == 'string' && v === '') return true;\n  return false;\n}\n\nfunction configure(cls, validation, args, opts) {\n  if (!cls.validations) {\n    Object.defineProperty(cls, 'validations', {\n      writable: true,\n      configurable: true,\n      enumerable: false,\n      value: {},\n    });\n  }\n  args = [].slice.call(args);\n  var conf;\n  if (typeof args[args.length - 1] === 'object') {\n    conf = args.pop();\n  } else {\n    conf = {};\n  }\n  if (validation === 'custom' && typeof args[args.length - 1] === 'function') {\n    conf.customValidator = args.pop();\n  }\n  conf.validation = validation;\n  args.forEach(function(attr) {\n    if (typeof attr === 'string') {\n      var validation = extend({}, conf);\n      validation.options = opts || {};\n      cls.validations[attr] = cls.validations[attr] || [];\n      cls.validations[attr].push(validation);\n    }\n  });\n}\n\nfunction Errors() {\n  Object.defineProperty(this, 'codes', {\n    enumerable: false,\n    configurable: true,\n    value: {},\n  });\n}\n\nErrors.prototype.add = function(field, message, code) {\n  code = code || 'invalid';\n  if (!this[field]) {\n    this[field] = [];\n    this.codes[field] = [];\n  }\n  this[field].push(message);\n  this.codes[field].push(code);\n};\n\nfunction ErrorCodes(messages) {\n  var c = this;\n  Object.keys(messages).forEach(function(field) {\n    c[field] = messages[field].codes;\n  });\n}\n\n/**\n * ValidationError is raised when the application attempts to save an invalid model instance.\n * Example:\n * ```\n * {\n *   \"name\": \"ValidationError\",\n *   \"status\": 422,\n *   \"message\": \"The Model instance is not valid. \\\n *  See `details` property of the error object for more info.\",\n *   \"statusCode\": 422,\n *   \"details\": {\n *     \"context\": \"user\",\n  *    \"codes\": {\n  *      \"password\": [\n *         \"presence\"\n *       ],\n *       \"email\": [\n *         \"uniqueness\"\n *       ]\n *    },\n *     \"messages\": {\n *       \"password\": [\n *        \"can't be blank\"\n *      ],\n *       \"email\": [\n *         \"Email already exists\"\n *       ]\n *     }\n *   },\n * }\n * ```\n * You might run into situations where you need to raise a validation error yourself, for example in a \"before\" hook or a\n * custom model method.\n * ```\n * MyModel.prototype.preflight = function(changes, callback) {\n *   // Update properties, do not save to db\n *   for (var key in changes) {\n *     model[key] = changes[key];\n *   }\n *\n *   if (model.isValid()) {\n *     return callback(null, { success: true });\n *   }\n *\n *   // This line shows how to create a ValidationError\n *   var err = new MyModel.ValidationError(model);\n *   callback(err);\n * }\n * ```\n*/\nfunction ValidationError(obj) {\n  if (!(this instanceof ValidationError)) return new ValidationError(obj);\n\n  this.name = 'ValidationError';\n\n  var context = obj && obj.constructor && obj.constructor.modelName;\n  this.message = g.f(\n    'The %s instance is not valid. Details: %s.',\n      context ? '`' + context + '`' : 'model',\n      formatErrors(obj.errors, obj.toJSON()) || '(unknown)'\n  );\n\n  this.statusCode = 422;\n\n  this.details = {\n    context: context,\n    codes: obj.errors && obj.errors.codes,\n    messages: obj.errors,\n  };\n\n  if (Error.captureStackTrace) {\n    // V8 (Chrome, Opera, Node)\n    Error.captureStackTrace(this, this.constructor);\n  } else if (errorHasStackProperty) {\n    // Firefox\n    this.stack = (new Error).stack;\n  }\n  // Safari and PhantomJS initializes `error.stack` on throw\n  // Internet Explorer does not support `error.stack`\n}\n\nutil.inherits(ValidationError, Error);\n\nvar errorHasStackProperty = !!(new Error).stack;\n\nValidationError.maxPropertyStringLength = 32;\n\nfunction formatErrors(errors, propertyValues) {\n  var DELIM = '; ';\n  errors = errors || {};\n  return Object.getOwnPropertyNames(errors)\n    .filter(function(propertyName) {\n      return Array.isArray(errors[propertyName]);\n    })\n    .map(function(propertyName) {\n      var messages = errors[propertyName];\n      var propertyValue = propertyValues[propertyName];\n      return messages.map(function(msg) {\n        return formatPropertyError(propertyName, propertyValue, msg);\n      }).join(DELIM);\n    })\n    .join(DELIM);\n}\n\nfunction formatPropertyError(propertyName, propertyValue, errorMessage) {\n  var formattedValue;\n  var valueType = typeof propertyValue;\n  if (valueType === 'string') {\n    formattedValue = JSON.stringify(truncatePropertyString(propertyValue));\n  } else if (propertyValue instanceof Date) {\n    formattedValue = propertyValue.toISOString();\n  } else if (valueType === 'object') {\n    // objects and arrays\n    formattedValue = util.inspect(propertyValue, {\n      showHidden: false,\n      color: false,\n      // show top-level object properties only\n      depth: Array.isArray(propertyValue) ? 1 : 0,\n    });\n    formattedValue = truncatePropertyString(formattedValue);\n  } else {\n    formattedValue = truncatePropertyString('' + propertyValue);\n  }\n  return '`' + propertyName + '` ' + errorMessage +\n    ' (value: ' + formattedValue + ')';\n}\n\nfunction truncatePropertyString(value) {\n  var len = ValidationError.maxPropertyStringLength;\n  if (value.length <= len) return value;\n\n  // preserve few last characters like `}` or `]`, but no more than 3\n  // this way the last `} ]` in the array of objects is included in the message\n  var tail;\n  var m = value.match(/([ \\t})\\]]+)$/);\n  if (m) {\n    tail = m[1].slice(-3);\n    len -= tail.length;\n  } else {\n    tail = value.slice(-3);\n    len -= 3;\n  }\n\n  return value.slice(0, len - 4) + '...' + tail;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/utils.js":"// Copyright IBM Corp. 2012,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nexports.safeRequire = safeRequire;\nexports.fieldsToArray = fieldsToArray;\nexports.selectFields = selectFields;\nexports.removeUndefined = removeUndefined;\nexports.parseSettings = parseSettings;\nexports.mergeSettings = exports.deepMerge = mergeSettings;\nexports.isPlainObject = isPlainObject;\nexports.defineCachedRelations = defineCachedRelations;\nexports.sortObjectsByIds = sortObjectsByIds;\nexports.setScopeValuesFromWhere = setScopeValuesFromWhere;\nexports.mergeQuery = mergeQuery;\nexports.mergeIncludes = mergeIncludes;\nexports.createPromiseCallback = createPromiseCallback;\nexports.uniq = uniq;\nexports.toRegExp = toRegExp;\nexports.hasRegExpFlags = hasRegExpFlags;\nexports.idEquals = idEquals;\nexports.findIndexOf = findIndexOf;\nexports.collectTargetIds = collectTargetIds;\nexports.idName = idName;\n\nvar g = require('strong-globalize')();\nvar traverse = require('traverse');\nvar assert = require('assert');\nvar Promise = require('bluebird');\n\nfunction safeRequire(module) {\n  try {\n    return require(module);\n  } catch (e) {\n    g.log('Run \"{{npm install loopback-datasource-juggler}} %s\" command ',\n      'to use {{loopback-datasource-juggler}} using %s database engine',\n      module, module);\n    process.exit(1);\n  }\n}\n\n/*\n * Extracting fixed property values for the scope from the where clause into\n * the data object\n *\n * @param {Object} The data object\n * @param {Object} The where clause\n */\nfunction setScopeValuesFromWhere(data, where, targetModel) {\n  for (var i in where) {\n    if (i === 'and') {\n      // Find fixed property values from each subclauses\n      for (var w = 0, n = where[i].length; w < n; w++) {\n        setScopeValuesFromWhere(data, where[i][w], targetModel);\n      }\n      continue;\n    }\n    var prop = targetModel.definition.properties[i];\n    if (prop) {\n      var val = where[i];\n      if (typeof val !== 'object' || val instanceof prop.type ||\n          prop.type.name === 'ObjectID') { // MongoDB key\n        // Only pick the {propertyName: propertyValue}\n        data[i] = where[i];\n      }\n    }\n  }\n}\n\n/**\n * Merge include options of default scope with runtime include option.\n * exhibits the _.extend behaviour. Property value of source overrides\n * property value of destination if property name collision occurs\n * @param {String|Array|Object} destination The default value of `include` option\n * @param {String|Array|Object} source The runtime value of `include` option\n * @returns {Object}\n */\nfunction mergeIncludes(destination, source) {\n  var destArray = convertToArray(destination);\n  var sourceArray = convertToArray(source);\n  if (destArray.length === 0) {\n    return sourceArray;\n  }\n  if (sourceArray.length === 0) {\n    return destArray;\n  }\n  var relationNames = [];\n  var resultArray = [];\n  for (var j in sourceArray) {\n    var sourceEntry = sourceArray[j];\n    var sourceEntryRelationName = (typeof (sourceEntry.rel || sourceEntry.relation) === 'string') ?\n      sourceEntry.relation : Object.keys(sourceEntry)[0];\n    relationNames.push(sourceEntryRelationName);\n    resultArray.push(sourceEntry);\n  }\n  for (var i in destArray) {\n    var destEntry = destArray[i];\n    var destEntryRelationName = (typeof (destEntry.rel || destEntry.relation) === 'string') ?\n      destEntry.relation : Object.keys(destEntry)[0];\n    if (relationNames.indexOf(destEntryRelationName) === -1) {\n      resultArray.push(destEntry);\n    }\n  }\n  return resultArray;\n}\n\n/**\n * Converts input parameter into array of objects which wraps the value.\n * \"someValue\" is converted to [{\"someValue\":true}]\n * [\"someValue\"] is converted to [{\"someValue\":true}]\n * {\"someValue\":true} is converted to [{\"someValue\":true}]\n * @param {String|Array|Object} param - Input parameter to be converted\n * @returns {Array}\n */\nfunction convertToArray(include) {\n  if (typeof include === 'string') {\n    const obj = {};\n    obj[include] = true;\n    return [obj];\n  } else if (isPlainObject(include)) {\n    // if include is of the form - {relation:'',scope:''}\n    if (include.rel || include.relation) {\n      return [include];\n    }\n    // Build an array of key/value pairs\n    var newInclude = [];\n    for (var key in include) {\n      const obj = {};\n      obj[key] = include[key];\n      newInclude.push(obj);\n    }\n    return newInclude;\n  } else if (Array.isArray(include)) {\n    var normalized = [];\n    for (var i in include) {\n      var includeEntry = include[i];\n      if (typeof includeEntry === 'string') {\n        const obj = {};\n        obj[includeEntry] = true;\n        normalized.push(obj);\n      } else {\n        normalized.push(includeEntry);\n      }\n    }\n    return normalized;\n  }\n  return [];\n}\n\n/*!\n * Merge query parameters\n * @param {Object} base The base object to contain the merged results\n * @param {Object} update The object containing updates to be merged\n * @param {Object} spec Optionally specifies parameters to exclude (set to false)\n * @returns {*|Object} The base object\n * @private\n */\nfunction mergeQuery(base, update, spec) {\n  if (!update) {\n    return;\n  }\n  spec = spec || {};\n  base = base || {};\n\n  if (update.where && Object.keys(update.where).length > 0) {\n    if (base.where && Object.keys(base.where).length > 0) {\n      base.where = {and: [base.where, update.where]};\n    } else {\n      base.where = update.where;\n    }\n  }\n\n  // Merge inclusion\n  if (spec.include !== false && update.include) {\n    if (!base.include) {\n      base.include = update.include;\n    } else {\n      if (spec.nestedInclude === true) {\n        // specify nestedInclude=true to force nesting of inclusions on scoped\n        // queries. e.g. In physician.patients.getAsync({include: 'address'}),\n        // inclusion should be on patient model, not on physician model.\n        var saved = base.include;\n        base.include = {};\n        base.include[update.include] = saved;\n      } else {\n        // default behaviour of inclusion merge - merge inclusions at the same\n        // level. - https://github.com/strongloop/loopback-datasource-juggler/pull/569#issuecomment-95310874\n        base.include = mergeIncludes(base.include, update.include);\n      }\n    }\n  }\n\n  if (spec.collect !== false && update.collect) {\n    base.collect = update.collect;\n  }\n\n  // Overwrite fields\n  if (spec.fields !== false && update.fields !== undefined) {\n    base.fields = update.fields;\n  } else if (update.fields !== undefined) {\n    base.fields = [].concat(base.fields).concat(update.fields);\n  }\n\n  // set order\n  if ((!base.order || spec.order === false) && update.order) {\n    base.order = update.order;\n  }\n\n  // overwrite pagination\n  if (spec.limit !== false && update.limit !== undefined) {\n    base.limit = update.limit;\n  }\n\n  var skip = spec.skip !== false && spec.offset !== false;\n\n  if (skip && update.skip !== undefined) {\n    base.skip = update.skip;\n  }\n\n  if (skip && update.offset !== undefined) {\n    base.offset = update.offset;\n  }\n\n  return base;\n}\n\n/**\n * Normalize fields to an array of included properties\n * @param {String|String[]|Object} fields Fields filter\n * @param {String[]} properties Property names\n * @param {Boolean} excludeUnknown To exclude fields that are unknown properties\n * @returns {String[]} An array of included property names\n */\nfunction fieldsToArray(fields, properties, excludeUnknown) {\n  if (!fields) return;\n\n  // include all properties by default\n  var result = properties;\n  var i, n;\n\n  if (typeof fields === 'string') {\n    result = [fields];\n  } else if (Array.isArray(fields) && fields.length > 0) {\n    // No empty array, including all the fields\n    result = fields;\n  } else if ('object' === typeof fields) {\n    // { field1: boolean, field2: boolean ... }\n    var included = [];\n    var excluded = [];\n    var keys = Object.keys(fields);\n    if (!keys.length) return;\n\n    for (i = 0, n = keys.length; i < n; i++) {\n      var k = keys[i];\n      if (fields[k]) {\n        included.push(k);\n      } else if ((k in fields) && !fields[k]) {\n        excluded.push(k);\n      }\n    }\n    if (included.length > 0) {\n      result = included;\n    } else if (excluded.length > 0) {\n      for (i = 0, n = excluded.length; i < n; i++) {\n        var index = result.indexOf(excluded[i]);\n        if (index !== -1) result.splice(index, 1); // only when existing field excluded\n      }\n    }\n  }\n\n  var fieldArray = [];\n  if (excludeUnknown) {\n    for (i = 0, n = result.length; i < n; i++) {\n      if (properties.indexOf(result[i]) !== -1) {\n        fieldArray.push(result[i]);\n      }\n    }\n  } else {\n    fieldArray = result;\n  }\n  return fieldArray;\n}\n\nfunction selectFields(fields) {\n  // map function\n  return function(obj) {\n    var result = {};\n    var key;\n\n    for (var i = 0; i < fields.length; i++) {\n      key = fields[i];\n\n      result[key] = obj[key];\n    }\n    return result;\n  };\n}\n\n/**\n * Remove undefined values from the queury object\n * @param query\n * @param handleUndefined {String} either \"nullify\", \"throw\" or \"ignore\" (default: \"ignore\")\n * @returns {exports.map|*}\n */\nfunction removeUndefined(query, handleUndefined) {\n  if (typeof query !== 'object' || query === null) {\n    return query;\n  }\n  // WARNING: [rfeng] Use map() will cause mongodb to produce invalid BSON\n  // as traverse doesn't transform the ObjectId correctly\n  return traverse(query).forEach(function(x) {\n    if (x === undefined) {\n      switch (handleUndefined) {\n        case 'nullify':\n          this.update(null);\n          break;\n        case 'throw':\n          throw new Error(g.f('Unexpected `undefined` in query'));\n          break;\n        case 'ignore':\n        default:\n          this.remove();\n      }\n    }\n\n    if (!Array.isArray(x) && (typeof x === 'object' && x !== null &&\n        x.constructor !== Object)) {\n      // This object is not a plain object\n      this.update(x, true); // Stop navigating into this object\n      return x;\n    }\n\n    return x;\n  });\n}\n\nvar url = require('url');\nvar qs = require('qs');\n\n/**\n * Parse a URL into a settings object\n * @param {String} urlStr The URL for connector settings\n * @returns {Object} The settings object\n */\nfunction parseSettings(urlStr) {\n  if (!urlStr) {\n    return {};\n  }\n  var uri = url.parse(urlStr, false);\n  var settings = {};\n  settings.connector = uri.protocol && uri.protocol.split(':')[0]; // Remove the trailing :\n  settings.host = settings.hostname = uri.hostname;\n  settings.port = uri.port && Number(uri.port); // port is a string\n  settings.user = settings.username = uri.auth && uri.auth.split(':')[0]; // <username>:<password>\n  settings.password = uri.auth && uri.auth.split(':')[1];\n  settings.database = uri.pathname && uri.pathname.split('/')[1];  // remove the leading /\n  settings.url = urlStr;\n  if (uri.query) {\n    var params = qs.parse(uri.query);\n    for (var p in params) {\n      settings[p] = params[p];\n    }\n  }\n  return settings;\n}\n\n/**\n * Merge model settings\n *\n * Folked from https://github.com/nrf110/deepmerge/blob/master/index.js\n *\n * The original function tries to merge array items if they are objects\n *\n * @param {Object} target The target settings object\n * @param {Object} src The source settings object\n * @returns {Object} The merged settings object\n */\nfunction mergeSettings(target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    // Add items from target into dst\n    dst = dst.concat(target);\n    // Add non-existent items from source into dst\n    src.forEach(function(e) {\n      if (dst.indexOf(e) === -1) {\n        dst.push(e);\n      }\n    });\n  } else {\n    if (target != null && typeof target === 'object') {\n      // Add properties from target to dst\n      Object.keys(target).forEach(function(key) {\n        dst[key] = target[key];\n      });\n    }\n    if (src != null && typeof src === 'object') {\n      // Source is an object\n      Object.keys(src).forEach(function(key) {\n        var srcValue = src[key];\n        if (srcValue == null || typeof srcValue !== 'object') {\n          // The source item value is null, undefined or not an object\n          dst[key] = srcValue;\n        } else {\n          // The source item value is an object\n          if (target == null || typeof target !== 'object' ||\n            target[key] == null) {\n            // If target is not an object or target item value\n            dst[key] = srcValue;\n          } else {\n            dst[key] = mergeSettings(target[key], src[key]);\n          }\n        }\n      });\n    }\n  }\n\n  return dst;\n}\n\n/**\n * Define an non-enumerable __cachedRelations property\n * @param {Object} obj The obj to receive the __cachedRelations\n */\nfunction defineCachedRelations(obj) {\n  if (!obj.__cachedRelations) {\n    Object.defineProperty(obj, '__cachedRelations', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: {},\n    });\n  }\n}\n\n/**\n * Check if the argument is plain object\n * @param {*) obj The obj value\n * @returns {boolean}\n */\nfunction isPlainObject(obj) {\n  return (typeof obj === 'object') && (obj !== null) &&\n    (obj.constructor === Object);\n}\n\nfunction sortObjectsByIds(idName, ids, objects, strict) {\n  ids = ids.map(function(id) {\n    return (typeof id === 'object') ? String(id) : id;\n  });\n\n  var indexOf = function(x) {\n    var isObj = (typeof x[idName] === 'object'); // ObjectID\n    var id = isObj ? String(x[idName]) : x[idName];\n    return ids.indexOf(id);\n  };\n\n  var heading = [];\n  var tailing = [];\n\n  objects.forEach(function(x) {\n    if (typeof x === 'object') {\n      var idx = indexOf(x);\n      if (strict && idx === -1) return;\n      idx === -1 ? tailing.push(x) : heading.push(x);\n    }\n  });\n\n  heading.sort(function(x, y) {\n    var a = indexOf(x);\n    var b = indexOf(y);\n    if (a === -1 || b === -1) return 1; // last\n    if (a === b) return 0;\n    if (a > b) return 1;\n    if (a < b) return -1;\n  });\n\n  return heading.concat(tailing);\n};\n\nfunction createPromiseCallback() {\n  var cb;\n  var promise = new Promise(function(resolve, reject) {\n    cb = function(err, data) {\n      if (err) return reject(err);\n      return resolve(data);\n    };\n  });\n  cb.promise = promise;\n  return cb;\n}\n\n/**\n * Dedupe an array\n * @param {Array} an array\n * @returns {Array} an array with unique items\n */\nfunction uniq(a) {\n  var uniqArray = [];\n  if (!a) {\n    return uniqArray;\n  }\n  assert(Array.isArray(a), 'array argument is required');\n  for (var i = 0, n = a.length; i < n; i++) {\n    if (a.indexOf(a[i]) === i) {\n      uniqArray.push(a[i]);\n    }\n  }\n  return uniqArray;\n}\n\n/**\n * Converts a string, regex literal, or a RegExp object to a RegExp object.\n * @param {String|Object} The string, regex literal, or RegExp object to convert\n * @returns {Object} A RegExp object\n */\nfunction toRegExp(regex) {\n  var isString = typeof regex === 'string';\n  var isRegExp = regex instanceof RegExp;\n\n  if (!(isString || isRegExp))\n    return new Error(g.f('Invalid argument, must be a string, {{regex}} literal, or ' +\n        '{{RegExp}} object'));\n\n  if (isRegExp)\n    return regex;\n\n  if (!hasRegExpFlags(regex))\n    return new RegExp(regex);\n\n  // only accept i, g, or m as valid regex flags\n  var flags = regex.split('/').pop().split('');\n  var validFlags = ['i', 'g', 'm'];\n  var invalidFlags = [];\n  flags.forEach(function(flag) {\n    if (validFlags.indexOf(flag) === -1)\n      invalidFlags.push(flag);\n  });\n\n  var hasInvalidFlags = invalidFlags.length > 0;\n  if (hasInvalidFlags)\n    return new Error(g.f('Invalid {{regex}} flags: %s', invalidFlags));\n\n  // strip regex delimiter forward slashes\n  var expression = regex.substr(1, regex.lastIndexOf('/') - 1);\n  return new RegExp(expression, flags.join(''));\n}\n\nfunction hasRegExpFlags(regex) {\n  return regex instanceof RegExp ?\n    regex.toString().split('/').pop() :\n    !!regex.match(/.*\\/.+$/);\n}\n\n// Compare two id values to decide if updateAttributes is trying to change\n// the id value for a given instance\nfunction idEquals(id1, id2) {\n  if (id1 === id2) {\n    return true;\n  }\n  // Allows number/string conversions\n  if ((typeof id1 === 'number' && typeof id2 === 'string') ||\n    (typeof id1 === 'string' && typeof id2 === 'number')) {\n    return id1 == id2;\n  }\n  // For complex id types such as MongoDB ObjectID\n  id1 = JSON.stringify(id1);\n  id2 = JSON.stringify(id2);\n  if (id1 === id2) {\n    return true;\n  }\n\n  return false;\n}\n\n// Defaults to native Array.prototype.indexOf when no idEqual is present\n// Otherwise, returns the lowest index for which isEqual(arr[]index, target) is true\nfunction findIndexOf(arr, target, isEqual) {\n  if (!isEqual) {\n    return arr.indexOf(target);\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    if (isEqual(arr[i], target)) { return i; }\n  };\n\n  return -1;\n}\n\n/**\n * Returns an object that queries targetIds.\n * @param {Array} The array of targetData\n * @param {String} The Id property name of target model\n * @returns {Object} The object that queries targetIds\n */\nfunction collectTargetIds(targetData, idPropertyName) {\n  var targetIds = [];\n  for (var i = 0; i < targetData.length; i++) {\n    var targetId = targetData[i][idPropertyName];\n    targetIds.push(targetId);\n  };\n  var IdQuery = {\n    inq: uniq(targetIds),\n  };\n  return IdQuery;\n}\n\n/**\n * Find the idKey of a Model.\n * @param {ModelConstructor} m - Model Constructor\n * @returns {String}\n */\nfunction idName(m) {\n  return m.definition.idName() || 'id';\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/observer.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar async = require('async');\nvar utils = require('./utils');\n\nmodule.exports = ObserverMixin;\n\n/**\n * ObserverMixin class.  Use to add observe/notifyObserversOf APIs to other\n * classes.\n *\n * @class ObserverMixin\n */\nfunction ObserverMixin() {\n}\n\n/**\n * Register an asynchronous observer for the given operation (event).\n * @param {String} operation The operation name.\n * @callback {function} listener The listener function. It will be invoked with\n * `this` set to the model constructor, e.g. `User`.\n * @param {Object} context Operation-specific context.\n * @param {function(Error=)} next The callback to call when the observer\n *   has finished.\n * @end\n */\nObserverMixin.observe = function(operation, listener) {\n  this._observers = this._observers || {};\n  if (!this._observers[operation]) {\n    this._observers[operation] = [];\n  }\n\n  this._observers[operation].push(listener);\n};\n\n/**\n * Unregister an asynchronous observer for the given operation (event).\n * @param {String} operation The operation name.\n * @callback {function} listener The listener function.\n * @end\n */\nObserverMixin.removeObserver = function(operation, listener) {\n  if (!(this._observers && this._observers[operation])) return;\n\n  var index = this._observers[operation].indexOf(listener);\n  if (index !== -1) {\n    return this._observers[operation].splice(index, 1);\n  }\n};\n\n/**\n * Unregister all asynchronous observers for the given operation (event).\n * @param {String} operation The operation name.\n * @end\n */\nObserverMixin.clearObservers = function(operation) {\n  if (!(this._observers && this._observers[operation])) return;\n\n  this._observers[operation].length = 0;\n};\n\n/**\n * Invoke all async observers for the given operation(s).\n * @param {String|String[]} operation The operation name(s).\n * @param {Object} context Operation-specific context.\n * @param {function(Error=)} callback The callback to call when all observers\n *   has finished.\n */\nObserverMixin.notifyObserversOf = function(operation, context, callback) {\n  var self = this;\n  if (!callback) callback = utils.createPromiseCallback();\n\n  function createNotifier(op) {\n    return function(ctx, done) {\n      if (typeof ctx === 'function' && done === undefined) {\n        done = ctx;\n        ctx = context;\n      }\n      self.notifyObserversOf(op, context, done);\n    };\n  }\n\n  if (Array.isArray(operation)) {\n    var tasks = [];\n    for (var i = 0, n = operation.length; i < n; i++) {\n      tasks.push(createNotifier(operation[i]));\n    }\n    return async.waterfall(tasks, callback);\n  }\n\n  var observers = this._observers && this._observers[operation];\n\n  this._notifyBaseObservers(operation, context, function doNotify(err) {\n    if (err) return callback(err, context);\n    if (!observers || !observers.length) return callback(null, context);\n\n    async.eachSeries(\n      observers,\n      function notifySingleObserver(fn, next) {\n        var retval = fn(context, next);\n        if (retval && typeof retval.then === 'function') {\n          retval.then(\n            function() { next(); return null; },\n            next // error handler\n          );\n        }\n      },\n      function(err) { callback(err, context); }\n    );\n  });\n  return callback.promise;\n};\n\nObserverMixin._notifyBaseObservers = function(operation, context, callback) {\n  if (this.base && this.base.notifyObserversOf)\n    this.base.notifyObserversOf(operation, context, callback);\n  else\n    callback();\n};\n\n/**\n * Run the given function with before/after observers. It's done in three serial\n * steps asynchronously:\n *\n * - Notify the registered observers under 'before ' + operation\n * - Execute the function\n * - Notify the registered observers under 'after ' + operation\n *\n * If an error happens, it fails fast and calls the callback with err.\n *\n * @param {String} operation The operation name\n * @param {Context} context The context object\n * @param {Function} fn The task to be invoked as fn(done) or fn(context, done)\n * @param {Function} callback The callback function\n * @returns {*}\n */\nObserverMixin.notifyObserversAround = function(operation, context, fn, callback) {\n  var self = this;\n  context = context || {};\n  // Add callback to the context object so that an observer can skip other\n  // ones by calling the callback function directly and not calling next\n  if (context.end === undefined) {\n    context.end = callback;\n  }\n  // First notify before observers\n  return self.notifyObserversOf('before ' + operation, context,\n    function(err, context) {\n      if (err) return callback(err);\n\n      function cbForWork(err) {\n        var args = [].slice.call(arguments, 0);\n        if (err) return callback.apply(null, args);\n        // Find the list of params from the callback in addition to err\n        var returnedArgs = args.slice(1);\n        // Set up the array of results\n        context.results = returnedArgs;\n        // Notify after observers\n        self.notifyObserversOf('after ' + operation, context,\n          function(err, context) {\n            if (err) return callback(err, context);\n            var results = returnedArgs;\n            if (context && Array.isArray(context.results)) {\n              // Pickup the results from context\n              results = context.results;\n            }\n            // Build the list of params for final callback\n            var args = [err].concat(results);\n            callback.apply(null, args);\n          });\n      }\n\n      if (fn.length === 1) {\n        // fn(done)\n        fn(cbForWork);\n      } else {\n        // fn(context, done)\n        fn(context, cbForWork);\n      }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/node_modules/async/dist/async.js":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest$1(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Lodash rest function without function.toString()\n// remappings\nfunction rest(func, start) {\n    return overRest$1(func, start, identity);\n}\n\nvar initialParams = function (fn) {\n    return rest(function (args /*..., callback*/) {\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    });\n};\n\nfunction applyEach$1(eachfn) {\n    return rest(function (fns, args) {\n        var go = initialParams(function (args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        } else {\n            return go;\n        }\n    });\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === breakLoop || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array. The iteratee is passed a `callback(err)` which must be called once it\n * has completed. If no error has occurred, the callback should be run without\n * arguments or with an explicit `null` argument. Invoked with\n * (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, iteratee, callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if (++completed === length || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array. The iteratee is passed a `callback(err)` which must be called once it\n * has completed. If no error has occurred, the callback should be run without\n * arguments or with an explicit `null` argument. Invoked with\n * (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function (coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, iteratee, callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, iteratee, callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines)\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of asynchronous functions\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, iteratee, callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a transformed\n * item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of asynchronous functions to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply$2 = rest(function (fn, args) {\n    return rest(function (callArgs) {\n        return fn.apply(null, args.concat(callArgs));\n    });\n});\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2016 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function to convert to an\n * asynchronous function.\n * @returns {Function} An asynchronous wrapper of the `func`. To be invoked with\n * (callback).\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es6 example\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                callback(null, value);\n            }, function (err) {\n                callback(err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the functions in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the functions pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * Functions also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the function itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = task[task.length - 1];\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg) {\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is a function of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (taskFn.length === 1) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            taskFn.apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return rest(function (fn, args) {\n        defer(function () {\n            fn.apply(null, args);\n        });\n    });\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function (node) {\n    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = DLL;\n\nDLL.prototype.insertAfter = function (node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function (node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function (node) {\n    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);\n};\n\nDLL.prototype.push = function (node) {\n    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);\n};\n\nDLL.prototype.shift = function () {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function () {\n    return this.tail && this.removeLink(this.tail);\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    } else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    }\n\n    function _next(tasks) {\n        return rest(function (args) {\n            workers -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n                var index = baseIndexOf(workersList, task, 0);\n                if (index >= 0) {\n                    workersList.splice(index);\n                }\n\n                task.callback.apply(task, args);\n\n                if (args[0] != null) {\n                    q.error(args[0], task.data);\n                }\n            }\n\n            if (workers <= q.concurrency - q.buffer) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        });\n    }\n\n    var workers = 0;\n    var workersList = [];\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated: noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                var tasks = [],\n                    data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    data.push(node.data);\n                }\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n                workers += 1;\n                workersList.push(tasks[0]);\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return workers;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function () {\n            return q._tasks.length + workers === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing an array\n * of queued tasks, which must call its `callback(err)` argument when finished,\n * with an optional `err` argument. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n  return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`. The\n * `key` is the item's key, or index in the case of an array. The iteratee is\n * passed a `callback(err)` which must be called once it has completed. If no\n * error has occurred, the callback should be run without arguments or with an\n * explicit `null` argument. Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {Function} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction. The `iteratee` is passed a\n * `callback(err, reduction)` which accepts an optional error as its first\n * argument, and the state of the reduction as the second. If an error is\n * passed to the callback, the reduction is stopped and the main `callback` is\n * immediately called with the error. Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    eachOfSeries(coll, function (x, i, callback) {\n        iteratee(memo, x, function (err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...Function} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nvar seq$1 = rest(function seq(functions) {\n    return rest(function (args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(functions, args, function (newargs, fn, cb) {\n            fn.apply(that, newargs.concat(rest(function (err, nextargs) {\n                cb(err, nextargs);\n            })));\n        }, function (err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    });\n});\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...Function} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = rest(function (args) {\n  return seq$1.apply(null, args.reverse());\n});\n\nfunction concat$1(eachfn, arr, fn, callback) {\n    var result = [];\n    eachfn(arr, function (x, index, cb) {\n        fn(x, function (err, y) {\n            result = result.concat(y || []);\n            cb(err);\n        });\n    }, function (err) {\n        callback(err, result);\n    });\n}\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, results)` which must be called once\n * it has completed with an error (which can be `null`) and an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doParallel(concat$1);\n\nfunction doSeries(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOfSeries, obj, iteratee, callback);\n    };\n}\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, results)` which must be called once\n * it has completed with an error (which can be `null`) and an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doSeries(concat$1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {Function} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = rest(function (values) {\n    var args = [null].concat(values);\n    return initialParams(function (ignoredArgs, callback) {\n        return callback.apply(this, args);\n    });\n});\n\nfunction _createTester(check, getResult) {\n    return function (eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function (value, _, callback) {\n            iteratee(value, function (err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return rest(function (fn, args) {\n        fn.apply(null, args.concat(rest(function (err, args) {\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        })));\n    });\n}\n\n/**\n * Logs the result of an `async` function to the `console` using `console.dir`\n * to display the properties of the resulting object. Only works in Node.js or\n * in browsers that support `console.dir` and `console.error` (such as FF and\n * Chrome). If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {Function} fn - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occured, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        args.push(check);\n        test.apply(this, args);\n    });\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        fn(next);\n    }\n\n    check(null, true);\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} iteratee - A function which is called each time `test`\n * passes. The function is passed a `callback(err)`, which must be called once\n * it has completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with the non-error callback results of \n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test.apply(this, args)) return iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {Function} fn - A function which is called each time `test` fails.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `fn`. Invoked with the non-error callback results of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(fn, test, callback) {\n    doWhilst(fn, function () {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {Function} fn - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occured, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n\n    function next(err) {\n        if (err) return callback(err);\n        test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        fn(next);\n    }\n\n    test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item\n * in `coll`. The iteratee is passed a `callback(err)` which must be called once\n * it has completed. If no error has occurred, the `callback` should be run\n * without arguments or with an explicit `null` argument. The array index is not\n * passed to the iteratee. Invoked with (item, callback). If you need the index,\n * use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n  eachOf(coll, _withoutIndex(iteratee), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each item in `coll`. The\n * iteratee is passed a `callback(err)` which must be called once it has\n * completed. If no error has occurred, the `callback` should be run without\n * arguments or with an explicit `null` argument. The array index is not passed\n * to the iteratee. Invoked with (item, callback). If you need the index, use\n * `eachOfLimit`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, _withoutIndex(iteratee), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The iteratee is passed a `callback(err)` which must be called\n * once it has completed. If no error has occurred, the `callback` should be run\n * without arguments or with an explicit `null` argument. The array index is\n * not passed to the iteratee. Invoked with (item, callback). If you need the\n * index, use `eachOfSeries`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {Function} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({ index: index, value: x });\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, iteratee, callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the\n * callback then `errback` is called with the error, and execution stops,\n * otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} fn - a function to call repeatedly. Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = ensureAsync(fn);\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each value in `obj`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    eachOfLimit(obj, limit, function (val, key, next) {\n        iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each value and key in\n * `coll`. The iteratee is passed a `callback(err, transformed)` which must be\n * called once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each value in `obj`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an `async` function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {Function} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function () {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            fn.apply(null, args.concat(rest(function (args) {\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            })));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @alias setImmediate\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        task(rest(function (err, args) {\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            results[key] = args;\n            callback(err);\n        }));\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to run.\n * Each function is passed a `callback(err, result)` which it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n  _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Collection} tasks - A collection containing functions to run.\n * Each function is passed a `callback(err, result)` which it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n  _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing a queued\n * task, which must call its `callback(err)` argument when finished, with an\n * optional `error` as an argument.  If you want to handle errors from an\n * individual task, pass a callback to `q.push()`. Invoked with\n * (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n  return queue(function (items, cb) {\n    worker(items[0], cb);\n  }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing a queued\n * task, which must call its `callback(err)` argument when finished, with an\n * optional `error` as an argument.  If you want to handle errors from an\n * individual task, pass a callback to `q.push()`. Invoked with\n * (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function (worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function (data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing functions to run. Each function\n * is passed a `callback(err, result)` which it must call on completion with an\n * error `err` (which can be `null`) and an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        tasks[i](callback);\n    }\n}\n\nvar slice = Array.prototype.slice;\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {Function} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction. The `iteratee` is passed a\n * `callback(err, reduction)` which accepts an optional error as its first\n * argument, and the state of the reduction as the second. If an error is\n * passed to the callback, the reduction is stopped and the main `callback` is\n * immediately called with the error. Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight(array, memo, iteratee, callback) {\n  var reversed = slice.call(array).reverse();\n  reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the function in another function that always returns data even when it\n * errors.\n *\n * The object returned has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(rest(function callback(err, cbArgs) {\n            if (err) {\n                reflectCallback(null, {\n                    error: err\n                });\n            } else {\n                var value = null;\n                if (cbArgs.length === 1) {\n                    value = cbArgs[0];\n                } else if (cbArgs.length > 1) {\n                    value = cbArgs;\n                }\n                reflectCallback(null, {\n                    value: value\n                });\n            }\n        }));\n\n        return fn.apply(this, args);\n    });\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function (value, cb) {\n        iteratee(value, function (err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * A helper function that wraps an array or an object of functions with reflect.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array} tasks - The array of functions to wrap in `async.reflect`.\n * @returns {Array} Returns an array of functions, each function wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function (task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {Function} task - A function which receives two arguments: (1) a\n * `callback(err, result)` which must be called when finished, passing `err`\n * (which can be `null`) and the `result` of the function's execution, and (2)\n * a `results` object, containing the results of the previously executed\n * functions (if nested inside another control flow). Invoked with\n * (callback, results).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retry(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var attempt = 1;\n    function retryAttempt() {\n        task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method wraps a task and makes it\n * retryable, rather than immediately calling it with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {Function} task - the asynchronous function to wrap\n * @returns {Functions} The wrapped function, which when invoked, will retry on\n * an error, based on the parameters specified in `opts`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to run, each\n * function is passed a `callback(err, result)` it must call on completion with\n * an error `err` (which can be `null`) and an optional `result` value.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n  _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, sortValue)` which must be called once\n * it has completed with an error (which can be `null`) and a value to use as\n * the sort criteria. Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy(coll, iteratee, callback) {\n    map(coll, function (x, callback) {\n        iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, { value: x, criteria: criteria });\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria,\n            b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} asyncFn - The asynchronous function you want to set the\n * time limit.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {Function} Returns a wrapped function that can be used with any of\n * the control flow functions. Invoke this function with the same\n * parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    return initialParams(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        asyncFn.apply(null, args.concat(injectedCallback));\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax$1 = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n  mapLimit(baseRange(0, count, 1), limit, iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {Function} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator. The `iteratee` is\n * passed a `callback(err)` which accepts an optional error as its first\n * argument. If an error is passed to the callback, the transform is stopped\n * and the main `callback` is immediately called with the error.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length === 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n\n    eachOf(coll, function (v, k, cb) {\n        iteratee(accumulator, v, k, cb);\n    }, function (err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {Function} fn - the memoized function\n * @returns {Function} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {Function} iteratee - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    if (!test()) return callback(null);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test()) return iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    iteratee(next);\n}\n\n/**\n * Repeatedly call `fn` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `fn`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `fn`. Invoked with ().\n * @param {Function} fn - A function which is called each time `test` fails.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, fn, callback) {\n    whilst(function () {\n        return !test.apply(this, arguments);\n    }, fn, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of functions to run, each function is passed\n * a `callback(err, result1, result2, ...)` it must call on completion. The\n * first argument is an error (which can be `null`) and any further arguments\n * will be passed as arguments in order to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function (tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        if (taskIndex === tasks.length) {\n            return callback.apply(null, [null].concat(args));\n        }\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            if (err) {\n                return callback.apply(null, [err].concat(args));\n            }\n            nextTask(args);\n        }));\n\n        args.push(taskCallback);\n\n        var task = tasks[taskIndex++];\n        task.apply(null, args);\n    }\n\n    nextTask([]);\n};\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n */\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\nvar index = {\n  applyEach: applyEach,\n  applyEachSeries: applyEachSeries,\n  apply: apply$2,\n  asyncify: asyncify,\n  auto: auto,\n  autoInject: autoInject,\n  cargo: cargo,\n  compose: compose,\n  concat: concat,\n  concatSeries: concatSeries,\n  constant: constant,\n  detect: detect,\n  detectLimit: detectLimit,\n  detectSeries: detectSeries,\n  dir: dir,\n  doDuring: doDuring,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  during: during,\n  each: eachLimit,\n  eachLimit: eachLimit$1,\n  eachOf: eachOf,\n  eachOfLimit: eachOfLimit,\n  eachOfSeries: eachOfSeries,\n  eachSeries: eachSeries,\n  ensureAsync: ensureAsync,\n  every: every,\n  everyLimit: everyLimit,\n  everySeries: everySeries,\n  filter: filter,\n  filterLimit: filterLimit,\n  filterSeries: filterSeries,\n  forever: forever,\n  log: log,\n  map: map,\n  mapLimit: mapLimit,\n  mapSeries: mapSeries,\n  mapValues: mapValues,\n  mapValuesLimit: mapValuesLimit,\n  mapValuesSeries: mapValuesSeries,\n  memoize: memoize,\n  nextTick: nextTick,\n  parallel: parallelLimit,\n  parallelLimit: parallelLimit$1,\n  priorityQueue: priorityQueue,\n  queue: queue$1,\n  race: race,\n  reduce: reduce,\n  reduceRight: reduceRight,\n  reflect: reflect,\n  reflectAll: reflectAll,\n  reject: reject,\n  rejectLimit: rejectLimit,\n  rejectSeries: rejectSeries,\n  retry: retry,\n  retryable: retryable,\n  seq: seq$1,\n  series: series,\n  setImmediate: setImmediate$1,\n  some: some,\n  someLimit: someLimit,\n  someSeries: someSeries,\n  sortBy: sortBy,\n  timeout: timeout,\n  times: times,\n  timesLimit: timeLimit,\n  timesSeries: timesSeries,\n  transform: transform,\n  unmemoize: unmemoize,\n  until: until,\n  waterfall: waterfall,\n  whilst: whilst,\n\n  // aliases\n  all: every,\n  any: some,\n  forEach: eachLimit,\n  forEachSeries: eachSeries,\n  forEachLimit: eachLimit$1,\n  forEachOf: eachOf,\n  forEachOfSeries: eachOfSeries,\n  forEachOfLimit: eachOfLimit,\n  inject: reduce,\n  foldl: reduce,\n  foldr: reduceRight,\n  select: filter,\n  selectLimit: filterLimit,\n  selectSeries: filterSeries,\n  wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.apply = apply$2;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq$1;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/model-definition.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar assert = require('assert');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar traverse = require('traverse');\nvar ModelBaseClass = require('./model');\nvar ModelBuilder = require('./model-builder');\n\n/**\n * Model definition\n */\nmodule.exports = ModelDefinition;\n\n/**\n * Constructor for ModelDefinition\n * @param {ModelBuilder} modelBuilder A model builder instance\n * @param {String|Object} name The model name or the schema object\n * @param {Object} properties The model properties, optional\n * @param {Object} settings The model settings, optional\n * @returns {ModelDefinition}\n * @constructor\n *\n */\nfunction ModelDefinition(modelBuilder, name, properties, settings) {\n  if (!(this instanceof ModelDefinition)) {\n    // Allow to call ModelDefinition without new\n    return new ModelDefinition(modelBuilder, name, properties, settings);\n  }\n  this.modelBuilder = modelBuilder || ModelBuilder.defaultInstance;\n  assert(name, 'name is missing');\n\n  if (arguments.length === 2 && typeof name === 'object') {\n    var schema = name;\n    this.name = schema.name;\n    this.rawProperties = schema.properties || {}; // Keep the raw property definitions\n    this.settings = schema.settings || {};\n  } else {\n    assert(typeof name === 'string', 'name must be a string');\n    this.name = name;\n    this.rawProperties = properties || {}; // Keep the raw property definitions\n    this.settings = settings || {};\n  }\n  this.relations = [];\n  this.properties = null;\n  this.build();\n}\n\nutil.inherits(ModelDefinition, EventEmitter);\n\n// Set up types\nrequire('./types')(ModelDefinition);\n\n/**\n * Return table name for specified `modelName`\n * @param {String} connectorType The connector type, such as 'oracle' or 'mongodb'\n */\nModelDefinition.prototype.tableName = function(connectorType) {\n  var settings = this.settings;\n  if (settings[connectorType]) {\n    return settings[connectorType].table || settings[connectorType].tableName || this.name;\n  } else {\n    return this.name;\n  }\n};\n\n/**\n * Return column name for specified modelName and propertyName\n * @param {String} connectorType The connector type, such as 'oracle' or 'mongodb'\n * @param propertyName The property name\n * @returns {String} columnName\n */\nModelDefinition.prototype.columnName = function(connectorType, propertyName) {\n  if (!propertyName) {\n    return propertyName;\n  }\n  this.build();\n  var property = this.properties[propertyName];\n  if (property && property[connectorType]) {\n    return property[connectorType].column || property[connectorType].columnName || propertyName;\n  } else {\n    return propertyName;\n  }\n};\n\n/**\n * Return column metadata for specified modelName and propertyName\n * @param {String} connectorType The connector type, such as 'oracle' or 'mongodb'\n * @param propertyName The property name\n * @returns {Object} column metadata\n */\nModelDefinition.prototype.columnMetadata = function(connectorType, propertyName) {\n  if (!propertyName) {\n    return propertyName;\n  }\n  this.build();\n  var property = this.properties[propertyName];\n  if (property && property[connectorType]) {\n    return property[connectorType];\n  } else {\n    return null;\n  }\n};\n\n/**\n * Return column names for specified modelName\n * @param {String} connectorType The connector type, such as 'oracle' or 'mongodb'\n * @returns {String[]} column names\n */\nModelDefinition.prototype.columnNames = function(connectorType) {\n  this.build();\n  var props = this.properties;\n  var cols = [];\n  for (var p in props) {\n    if (props[p][connectorType]) {\n      cols.push(props[p][connectorType].column || props[p][connectorType].columnName || p);\n    } else {\n      cols.push(p);\n    }\n  }\n  return cols;\n};\n\n/**\n * Find the ID properties sorted by the index\n * @returns {Object[]} property name/index for IDs\n */\nModelDefinition.prototype.ids = function() {\n  if (this._ids) {\n    return this._ids;\n  }\n  var ids = [];\n  this.build();\n  var props = this.properties;\n  for (var key in props) {\n    var id = props[key].id;\n    if (!id) {\n      continue;\n    }\n    if (typeof id !== 'number') {\n      id = 1;\n    }\n    ids.push({name: key, id: id, property: props[key]});\n  }\n  ids.sort(function(a, b) {\n    return a.id - b.id;\n  });\n  this._ids = ids;\n  return ids;\n};\n\n/**\n * Find the ID column name\n * @param {String} modelName The model name\n * @returns {String} columnName for ID\n */\nModelDefinition.prototype.idColumnName = function(connectorType) {\n  return this.columnName(connectorType, this.idName());\n};\n\n/**\n * Find the ID property name\n * @returns {String} property name for ID\n */\nModelDefinition.prototype.idName = function() {\n  var id = this.ids()[0];\n  if (this.properties.id && this.properties.id.id) {\n    return 'id';\n  } else {\n    return id && id.name;\n  }\n};\n\n/**\n * Find the ID property names sorted by the index\n * @returns {String[]} property names for IDs\n */\nModelDefinition.prototype.idNames = function() {\n  var ids = this.ids();\n  var names = ids.map(function(id) {\n    return id.name;\n  });\n  return names;\n};\n\n/**\n *\n * @returns {{}}\n */\nModelDefinition.prototype.indexes = function() {\n  this.build();\n  var indexes = {};\n  if (this.settings.indexes) {\n    for (var i in this.settings.indexes) {\n      indexes[i] = this.settings.indexes[i];\n    }\n  }\n  for (var p in this.properties) {\n    if (this.properties[p].index) {\n      indexes[p + '_index'] = this.properties[p].index;\n    }\n  }\n  return indexes;\n};\n\n/**\n * Build a model definition\n * @param {Boolean} force Forcing rebuild\n */\nModelDefinition.prototype.build = function(forceRebuild) {\n  if (forceRebuild) {\n    this.properties = null;\n    this.relations = [];\n    this._ids = null;\n    this.json = null;\n  }\n  if (this.properties) {\n    return this.properties;\n  }\n  this.properties = {};\n  for (var p in this.rawProperties) {\n    var prop = this.rawProperties[p];\n    var type = this.modelBuilder.resolveType(prop);\n    if (typeof type === 'string') {\n      this.relations.push({\n        source: this.name,\n        target: type,\n        type: Array.isArray(prop) ? 'hasMany' : 'belongsTo',\n        as: p,\n      });\n    } else {\n      var typeDef = {\n        type: type,\n      };\n      if (typeof prop === 'object' && prop !== null) {\n        for (var a in prop) {\n          // Skip the type property but don't delete it Model.extend() shares same instances of the properties from the base class\n          if (a !== 'type') {\n            typeDef[a] = prop[a];\n          }\n        }\n      }\n      this.properties[p] = typeDef;\n    }\n  }\n  return this.properties;\n};\n\n/**\n * Define a property\n * @param {String} propertyName The property name\n * @param {Object} propertyDefinition The property definition\n */\nModelDefinition.prototype.defineProperty = function(propertyName, propertyDefinition) {\n  this.rawProperties[propertyName] = propertyDefinition;\n  this.build(true);\n};\n\nfunction isModelClass(cls) {\n  if (!cls) {\n    return false;\n  }\n  return cls.prototype instanceof ModelBaseClass;\n}\n\nModelDefinition.prototype.toJSON = function(forceRebuild) {\n  if (forceRebuild) {\n    this.json = null;\n  }\n  if (this.json) {\n    return this.json;\n  }\n  var json = {\n    name: this.name,\n    properties: {},\n    settings: this.settings,\n  };\n  this.build(forceRebuild);\n\n  var mapper = function(val) {\n    if (val === undefined || val === null) {\n      return val;\n    }\n    if ('function' === typeof val.toJSON) {\n      // The value has its own toJSON() object\n      return val.toJSON();\n    }\n    if ('function' === typeof val) {\n      if (isModelClass(val)) {\n        if (val.settings && val.settings.anonymous) {\n          return val.definition && val.definition.toJSON().properties;\n        } else {\n          return val.modelName;\n        }\n      }\n      return val.name;\n    } else {\n      return val;\n    }\n  };\n  for (var p in this.properties) {\n    json.properties[p] = traverse(this.properties[p]).map(mapper);\n  }\n  this.json = json;\n  return json;\n};\n\nModelDefinition.prototype.hasPK = function() {\n  return this.ids().length > 0;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/geo.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar assert = require('assert');\n\n/*!\n * Get a near filter from a given where object. For connector use only.\n */\n\nexports.nearFilter = function nearFilter(where) {\n  function nearSearch(clause, parentKeys) {\n    if (typeof clause !== 'object') {\n      return false;\n    }\n    parentKeys = parentKeys || [];\n\n    Object.keys(clause).forEach(function(clauseKey) {\n      if (Array.isArray(clause[clauseKey])) {\n        clause[clauseKey].forEach(function(el, index) {\n          var ret = nearSearch(el, parentKeys.concat(clauseKey).concat(index));\n          if (ret) return ret;\n        });\n      } else {\n        if (clause[clauseKey].hasOwnProperty('near')) {\n          var result = clause[clauseKey];\n          nearResults.push({\n            near: result.near,\n            maxDistance: result.maxDistance,\n            minDistance: result.minDistance,\n            unit: result.unit,\n            // If key is at root, define a single string, otherwise append it to the full path array\n            mongoKey: parentKeys.length ? parentKeys.concat(clauseKey) : clauseKey,\n            key: clauseKey,\n          });\n        }\n      }\n    });\n  }\n  var nearResults = [];\n  nearSearch(where);\n\n  return (!nearResults.length ? false : nearResults);\n};\n\n/*!\n * Filter a set of results using the given filters returned by `nearFilter()`.\n * Can support multiple locations, but will include results from all of them.\n *\n * WARNING: \"or\" operator with GeoPoint does not work as expected, eg:\n * {where: {or: [{location: {near: (29,-90)}},{name:'Sean'}]}}\n * Will actually work as if you had used \"and\".  This is because geo filtering\n * takes place outside of the SQL query, so the result set of \"name = Sean\" is\n * returned by the database, and then the location filtering happens in the app\n * logic.  So the \"near\" operator is always an \"and\" of the SQL filters, and \"or\"\n * of other GeoPoint filters.\n *\n * Additionally, since this step occurs after the SQL result set is returned,\n * if using GeoPoints with pagination the result set may be smaller than the\n * page size.  The page size is enforced at the DB level, and then we may\n * remove results at the Geo-app level.  If we \"limit: 25\", but 4 of those results\n * do not have a matching geopoint field, the request will only return 21 results.\n * This may make it erroneously look like a given page is the end of the result set.\n */\n\nexports.filter = function(rawResults, filters) {\n  var distances = {};\n  var results = [];\n\n  filters.forEach(function(filter) {\n    var origin = filter.near;\n    var max = filter.maxDistance > 0 ? filter.maxDistance : false;\n    var min = filter.minDistance > 0 ? filter.minDistance : false;\n    var unit = filter.unit;\n    var key = filter.key;\n\n    // create distance index\n    rawResults.forEach(function(result) {\n      var loc = result[key];\n\n      // filter out results without locations\n      if (!loc) return;\n\n      if (!(loc instanceof GeoPoint)) loc = GeoPoint(loc);\n\n      if (typeof loc.lat !== 'number') return;\n      if (typeof loc.lng !== 'number') return;\n\n      var d = GeoPoint.distanceBetween(origin, loc, {type: unit});\n\n      // filter result if distance is either < minDistance or > maxDistance\n      if ((min && d < min) || (max && d > max)) return;\n\n      distances[result.id] = d;\n      results.push(result);\n    });\n\n    results.sort(function(resA, resB) {\n      var a = resA[key];\n      var b = resB[key];\n\n      if (a && b) {\n        var da = distances[resA.id];\n        var db = distances[resB.id];\n\n        if (db === da) return 0;\n        return da > db ? 1 : -1;\n      } else {\n        return 0;\n      }\n    });\n  });\n\n  return results;\n};\n\nexports.GeoPoint = GeoPoint;\n\n/**\n * The GeoPoint object represents a physical location.\n *\n * For example:\n *\n * ```js\n * var loopback = require(loopback);\n * var here = new loopback.GeoPoint({lat: 10.32424, lng: 5.84978});\n * ```\n *\n * Embed a latitude / longitude point in a model.\n *\n * ```js\n * var CoffeeShop = loopback.createModel('coffee-shop', {\n *   location: 'GeoPoint'\n * });\n * ```\n *\n * You can query LoopBack models with a GeoPoint property and an attached data source using geo-spatial filters and\n * sorting. For example, the following code finds the three nearest coffee shops.\n *\n * ```js\n * CoffeeShop.attachTo(oracle);\n * var here = new GeoPoint({lat: 10.32424, lng: 5.84978});\n * CoffeeShop.find( {where: {location: {near: here}}, limit:3}, function(err, nearbyShops) {\n *   console.info(nearbyShops); // [CoffeeShop, ...]\n * });\n * ```\n * @class GeoPoint\n * @property {Number} lat The latitude in degrees.\n * @property {Number} lng The longitude in degrees.\n *\n * @options {Object} Options Object with two Number properties: lat and long.\n * @property {Number} lat The latitude point in degrees. Range: -90 to 90.\n * @property {Number} lng The longitude point in degrees. Range: -180 to 180.\n *\n * @options {Array} Options Array with two Number entries: [lat,long].\n * @property {Number} lat The latitude point in degrees. Range: -90 to 90.\n * @property {Number} lng The longitude point in degrees. Range: -180 to 180.\n */\n\nfunction GeoPoint(data) {\n  if (!(this instanceof GeoPoint)) {\n    return new GeoPoint(data);\n  }\n\n  if (arguments.length === 2) {\n    data = {\n      lat: arguments[0],\n      lng: arguments[1],\n    };\n  }\n\n  assert(Array.isArray(data) || typeof data === 'object' || typeof data === 'string',\n    'must provide valid geo-coordinates array [lat, lng] or object or a \"lat, lng\" string');\n\n  if (typeof data === 'string') {\n    try {\n      data = JSON.parse(data);\n    } catch (err) {\n      data = data.split(/,\\s*/);\n      assert(data.length === 2, 'must provide a string \"lat,lng\" creating a GeoPoint with a string');\n    }\n  }\n  if (Array.isArray(data)) {\n    data = {\n      lat: Number(data[0]),\n      lng: Number(data[1]),\n    };\n  } else {\n    data.lng = Number(data.lng);\n    data.lat = Number(data.lat);\n  }\n\n  assert(typeof data === 'object', 'must provide a lat and lng object when creating a GeoPoint');\n  assert(typeof data.lat === 'number' && !isNaN(data.lat), 'lat must be a number when creating a GeoPoint');\n  assert(typeof data.lng === 'number' && !isNaN(data.lng), 'lng must be a number when creating a GeoPoint');\n  assert(data.lng <= 180, 'lng must be <= 180');\n  assert(data.lng >= -180, 'lng must be >= -180');\n  assert(data.lat <= 90, 'lat must be <= 90');\n  assert(data.lat >= -90, 'lat must be >= -90');\n\n  this.lat = data.lat;\n  this.lng = data.lng;\n}\n\n/**\n * Determine the spherical distance between two GeoPoints.\n *\n * @param  {GeoPoint} pointA Point A\n * @param  {GeoPoint} pointB Point B\n * @options  {Object} options Options object with one key, 'type'.  See below.\n * @property {String} type Unit of measurement, one of:\n *\n * - `miles` (default)\n * - `radians`\n * - `kilometers`\n * - `meters`\n * - `miles`\n * - `feet`\n * - `degrees`\n */\n\nGeoPoint.distanceBetween = function distanceBetween(a, b, options) {\n  if (!(a instanceof GeoPoint)) {\n    a = GeoPoint(a);\n  }\n  if (!(b instanceof GeoPoint)) {\n    b = GeoPoint(b);\n  }\n\n  var x1 = a.lat;\n  var y1 = a.lng;\n\n  var x2 = b.lat;\n  var y2 = b.lng;\n\n  return geoDistance(x1, y1, x2, y2, options);\n};\n\n/**\n * Determine the spherical distance to the given point.\n * Example:\n * ```js\n * var loopback = require(loopback);\n *\n * var here = new loopback.GeoPoint({lat: 10, lng: 10});\n * var there = new loopback.GeoPoint({lat: 5, lng: 5});\n *\n * loopback.GeoPoint.distanceBetween(here, there, {type: 'miles'}) // 438\n * ```\n * @param {Object} point GeoPoint object to which to measure distance.\n * @options  {Object} options Options object with one key, 'type'.  See below.\n * @property {String} type Unit of measurement, one of:\n *\n * - `miles` (default)\n * - `radians`\n * - `kilometers`\n * - `meters`\n * - `miles`\n * - `feet`\n * - `degrees`\n */\n\nGeoPoint.prototype.distanceTo = function(point, options) {\n  return GeoPoint.distanceBetween(this, point, options);\n};\n\n/**\n * Simple serialization.\n */\n\nGeoPoint.prototype.toString = function() {\n  return this.lat + ',' + this.lng;\n};\n\n/**\n * @property {Number} DEG2RAD - Factor to convert degrees to radians.\n * @property {Number} RAD2DEG - Factor to convert radians to degrees.\n * @property {Object} EARTH_RADIUS - Radius of the earth.\n*/\n\n// factor to convert degrees to radians\nvar DEG2RAD = 0.01745329252;\n\n// factor to convert radians degrees to degrees\nvar RAD2DEG = 57.29577951308;\n\n// radius of the earth\nvar EARTH_RADIUS = {\n  kilometers: 6370.99056,\n  meters: 6370990.56,\n  miles: 3958.75,\n  feet: 20902200,\n  radians: 1,\n  degrees: RAD2DEG,\n};\n\nfunction geoDistance(x1, y1, x2, y2, options) {\n  var type = (options && options.type) || 'miles';\n\n  // Convert to radians\n  x1 = x1 * DEG2RAD;\n  y1 = y1 * DEG2RAD;\n  x2 = x2 * DEG2RAD;\n  y2 = y2 * DEG2RAD;\n\n  // use the haversine formula to calculate distance for any 2 points on a sphere.\n  // ref http://en.wikipedia.org/wiki/Haversine_formula\n  var haversine = function(a) {\n    return Math.pow(Math.sin(a / 2.0), 2);\n  };\n\n  var f = Math.sqrt(haversine(x2 - x1) + Math.cos(x2) * Math.cos(x1) * haversine(y2 - y1));\n\n  return 2 * Math.asin(f) * EARTH_RADIUS[type];\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/mixins.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar debug = require('debug')('loopback:mixin');\nvar assert = require('assert');\nvar DefaultModelBaseClass = require('./model.js');\n\nfunction isModelClass(cls) {\n  if (!cls) {\n    return false;\n  }\n  return cls.prototype instanceof DefaultModelBaseClass;\n}\n\nmodule.exports = MixinProvider;\n\nfunction MixinProvider(modelBuilder) {\n  this.modelBuilder = modelBuilder;\n  this.mixins = {};\n}\n\n/**\n * Apply named mixin to the model class\n * @param {Model} modelClass\n * @param {String} name\n * @param {Object} options\n */\nMixinProvider.prototype.applyMixin = function applyMixin(modelClass, name, options) {\n  var fn = this.mixins[name];\n  if (typeof fn === 'function') {\n    if (modelClass.dataSource) {\n      fn(modelClass, options || {});\n    } else {\n      modelClass.once('dataSourceAttached', function() {\n        fn(modelClass, options || {});\n      });\n    }\n  } else {\n    // Try model name\n    var model = this.modelBuilder.getModel(name);\n    if (model) {\n      debug('Mixin is resolved to a model: %s', name);\n      modelClass.mixin(model, options);\n    } else {\n      var errMsg = 'Model \"' + modelClass.modelName + '\" uses unknown mixin: ' + name;\n      debug(errMsg);\n      throw new Error(errMsg);\n    }\n  }\n};\n\n/**\n * Define a mixin with name\n * @param {String} name Name of the mixin\n * @param {*) mixin The mixin function or a model\n */\nMixinProvider.prototype.define = function defineMixin(name, mixin) {\n  assert(typeof mixin === 'function', 'The mixin must be a function or model class');\n  if (this.mixins[name]) {\n    debug('Duplicate mixin: %s', name);\n  } else {\n    debug('Defining mixin: %s', name);\n  }\n  if (isModelClass(mixin)) {\n    this.mixins[name] = function(Model, options) {\n      Model.mixin(mixin, options);\n    };\n  } else if (typeof mixin === 'function') {\n    this.mixins[name] = mixin;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/introspection.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nmodule.exports = function getIntrospector(ModelBuilder) {\n  function introspectType(value) {\n    // Unknown type, using Any\n    if (value === null || value === undefined) {\n      return ModelBuilder.Any;\n    }\n\n    // Check registered schemaTypes\n    for (var t in ModelBuilder.schemaTypes) {\n      var st = ModelBuilder.schemaTypes[t];\n      if (st !== Object && st !== Array && (value instanceof st)) {\n        return t;\n      }\n    }\n\n    var type = typeof value;\n    if (type === 'string' || type === 'number' || type === 'boolean') {\n      return type;\n    }\n\n    if (value instanceof Date) {\n      return 'date';\n    }\n\n    var itemType;\n    if (Array.isArray(value)) {\n      for (var i = 0; i < value.length; i++) {\n        if (value[i] === null || value[i] === undefined) {\n          continue;\n        }\n        itemType = introspectType(value[i]);\n        if (itemType) {\n          return [itemType];\n        }\n      }\n      return 'array';\n    }\n\n    if (type === 'function') {\n      return value.constructor.name;\n    }\n\n    var properties = {};\n    for (var p in value) {\n      itemType = introspectType(value[p]);\n      if (itemType) {\n        properties[p] = itemType;\n      }\n    }\n    if (Object.keys(properties).length === 0) {\n      return 'object';\n    }\n    return properties;\n  }\n\n  ModelBuilder.introspect = introspectType;\n  return introspectType;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/datasource.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n// Turning on strict for this file breaks lots of test cases;\n// disabling strict for this file\n/* eslint-disable strict */\n\n/*!\n * Module dependencies\n */\nvar ModelBuilder = require('./model-builder.js').ModelBuilder;\nvar ModelDefinition = require('./model-definition.js');\nvar RelationDefinition = require('./relation-definition.js');\nvar OberserverMixin = require('./observer');\nvar jutil = require('./jutil');\nvar utils = require('./utils');\nvar ModelBaseClass = require('./model.js');\nvar DataAccessObject = require('./dao.js');\nvar defineScope = require('./scope.js').defineScope;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar assert = require('assert');\nvar async = require('async');\nvar traverse = require('traverse');\nvar g = require('strong-globalize')();\nvar juggler = require('..');\n\nif (process.env.DEBUG === 'loopback') {\n  // For back-compatibility\n  process.env.DEBUG = 'loopback:*';\n}\nvar debug = require('debug')('loopback:datasource');\n\n/*!\n * Export public API\n */\nexports.DataSource = DataSource;\n\n/*!\n * Helpers\n */\nvar slice = Array.prototype.slice;\n\n/**\n * LoopBack models can manipulate data via the DataSource object.\n * Attaching a `DataSource` to a `Model` adds instance methods and static methods to the `Model`.\n *\n * Define a data source to persist model data.\n * To create a DataSource programmatically, call `createDataSource()` on the LoopBack object; for example:\n * ```js\n * var oracle = loopback.createDataSource({\n *   connector: 'oracle',\n *   host: '111.22.333.44',\n *   database: 'MYDB',\n *   username: 'username',\n *   password: 'password'\n * });\n * ```\n *\n * All classes in single dataSource share same the connector type and\n * one database connection.\n *\n * For example, the following creates a DataSource, and waits for a connection callback.\n *\n * ```\n * var dataSource = new DataSource('mysql', { database: 'myapp_test' });\n * dataSource.define(...);\n * dataSource.on('connected', function () {\n *     // work with database\n * });\n * ```\n * @class DataSource\n * @param {String} [name] Optional name for datasource.\n * @options {Object} settings Database-specific settings to establish connection (settings depend on specific connector).\n * The table below lists a typical set for a relational database.\n * @property {String} connector Database connector to use.  For any supported connector, can be any of:\n *\n * - The connector module from `require(connectorName)`.\n * - The full name of the connector module, such as 'loopback-connector-oracle'.\n * - The short name of the connector module, such as 'oracle'.\n * - A local module under `./connectors/` folder.\n * @property {String} host Database server host name.\n * @property {String} port Database server port number.\n * @property {String} username Database user name.\n * @property {String} password Database password.\n * @property {String} database Name of the database to use.\n * @property {Boolean} debug Display debugging information. Default is false.\n */\nfunction DataSource(name, settings, modelBuilder) {\n  if (!(this instanceof DataSource)) {\n    return new DataSource(name, settings);\n  }\n\n  // Check if the settings object is passed as the first argument\n  if (typeof name === 'object' && settings === undefined) {\n    settings = name;\n    name = undefined;\n  }\n\n  // Check if the first argument is a URL\n  if (typeof name === 'string' && name.indexOf('://') !== -1) {\n    name = utils.parseSettings(name);\n  }\n\n  // Check if the settings is in the form of URL string\n  if (typeof settings === 'string' && settings.indexOf('://') !== -1) {\n    settings = utils.parseSettings(settings);\n  }\n\n  this.modelBuilder = modelBuilder || new ModelBuilder();\n  this.models = this.modelBuilder.models;\n  this.definitions = this.modelBuilder.definitions;\n  this.juggler = juggler;\n\n  // operation metadata\n  // Initialize it before calling setup as the connector might register operations\n  this._operations = {};\n\n  this.setup(name, settings);\n\n  this._setupConnector();\n\n  // connector\n  var connector = this.connector;\n\n  // DataAccessObject - connector defined or supply the default\n  var dao = (connector && connector.DataAccessObject) || this.constructor.DataAccessObject;\n  this.DataAccessObject = function() {\n  };\n\n  // define DataAccessObject methods\n  Object.keys(dao).forEach(function(name) {\n    var fn = dao[name];\n    this.DataAccessObject[name] = fn;\n\n    if (typeof fn === 'function') {\n      this.defineOperation(name, {\n        accepts: fn.accepts,\n        'returns': fn.returns,\n        http: fn.http,\n        remoteEnabled: fn.shared ? true : false,\n        scope: this.DataAccessObject,\n        fnName: name,\n      });\n    }\n  }.bind(this));\n\n  // define DataAccessObject.prototype methods\n  Object.keys(dao.prototype).forEach(function(name) {\n    var fn = dao.prototype[name];\n    this.DataAccessObject.prototype[name] = fn;\n    if (typeof fn === 'function') {\n      this.defineOperation(name, {\n        prototype: true,\n        accepts: fn.accepts,\n        'returns': fn.returns,\n        http: fn.http,\n        remoteEnabled: fn.shared ? true : false,\n        scope: this.DataAccessObject.prototype,\n        fnName: name,\n      });\n    }\n  }.bind(this));\n}\n\nutil.inherits(DataSource, EventEmitter);\n\n// allow child classes to supply a data access object\nDataSource.DataAccessObject = DataAccessObject;\n\n/**\n * Set up the connector instance for backward compatibility with JugglingDB schema/adapter\n * @private\n */\nDataSource.prototype._setupConnector = function() {\n  this.connector = this.connector || this.adapter; // The legacy JugglingDB adapter will set up `adapter` property\n  this.adapter = this.connector; // Keep the adapter as an alias to connector\n  if (this.connector) {\n    if (!this.connector.dataSource) {\n      // Set up the dataSource if the connector doesn't do so\n      this.connector.dataSource = this;\n    }\n    var dataSource = this;\n    this.connector.log = function(query, start) {\n      dataSource.log(query, start);\n    };\n\n    this.connector.logger = function(query) {\n      var t1 = Date.now();\n      var log = this.log;\n      return function(q) {\n        log(q || query, t1);\n      };\n    };\n    // Configure the connector instance to mix in observer functions\n    jutil.mixin(this.connector, OberserverMixin);\n  }\n};\n\n// List possible connector module names\nfunction connectorModuleNames(name) {\n  var names = []; // Check the name as is\n  if (!name.match(/^\\//)) {\n    names.push('./connectors/' + name); // Check built-in connectors\n    if (name.indexOf('loopback-connector-') !== 0) {\n      names.push('loopback-connector-' + name); // Try loopback-connector-<name>\n    }\n  }\n  // Only try the short name if the connector is not from StrongLoop\n  if (['mongodb', 'oracle', 'mysql', 'postgresql', 'mssql', 'rest', 'soap', 'db2', 'cloudant']\n      .indexOf(name) === -1) {\n    names.push(name);\n  }\n  return names;\n}\n\n// testable with DI\nfunction tryModules(names, loader) {\n  var mod;\n  loader = loader || require;\n  for (var m = 0; m < names.length; m++) {\n    try {\n      mod = loader(names[m]);\n    } catch (e) {\n      var notFound = e.code === 'MODULE_NOT_FOUND' &&\n        e.message && e.message.indexOf(names[m]) > 0;\n\n      if (notFound) {\n        debug('Module %s not found, will try another candidate.', names[m]);\n        continue;\n      }\n\n      debug('Cannot load connector %s: %s', names[m], e.stack || e);\n      throw e;\n    }\n    if (mod) {\n      break;\n    }\n  }\n  return mod;\n}\n\n/*!\n * Resolve a connector by name\n * @param name The connector name\n * @returns {*}\n * @private\n */\nDataSource._resolveConnector = function(name, loader) {\n  var names = connectorModuleNames(name);\n  var connector = tryModules(names, loader);\n  var error = null;\n  if (!connector) {\n    error = g.f('\\nWARNING: {{LoopBack}} connector \"%s\" is not installed ' +\n      'as any of the following modules:\\n\\n %s\\n\\nTo fix, run:\\n\\n    {{npm install %s --save}}\\n',\n      name, names.join('\\n'), names[names.length - 1]);\n  }\n  return {\n    connector: connector,\n    error: error,\n  };\n};\n\n/**\n * Connect to the data source\n * @param callback\n */\nDataSource.prototype.connect = function(callback) {\n  callback = callback || utils.createPromiseCallback();\n  var self = this;\n  if (this.connected) {\n    // The data source is already connected, return immediately\n    process.nextTick(callback);\n    return callback.promise;\n  }\n  if (typeof this.connector.connect !== 'function') {\n    // Connector doesn't have the connect function\n    // Assume no connect is needed\n    self.connected = true;\n    self.connecting = false;\n    process.nextTick(function() {\n      self.emit('connected');\n      callback();\n    });\n    return callback.promise;\n  }\n\n  // Queue the callback\n  this.pendingConnectCallbacks = this.pendingConnectCallbacks || [];\n  this.pendingConnectCallbacks.push(callback);\n\n  // The connect is already in progress\n  if (this.connecting) return callback.promise;\n  // Set connecting flag to be true\n  this.connecting = true;\n  this.connector.connect(function(err, result) {\n    self.connecting = false;\n    if (!err) self.connected = true;\n    var cbs = self.pendingConnectCallbacks;\n    self.pendingConnectCallbacks = [];\n    if (!err) {\n      self.emit('connected');\n    } else {\n      self.emit('error', err);\n    }\n    // Invoke all pending callbacks\n    async.each(cbs, function(cb, done) {\n      try {\n        cb(err);\n      } catch (e) {\n        // Ignore error to make sure all callbacks are invoked\n        debug('Uncaught error raised by connect callback function: ', e);\n      } finally {\n        done();\n      }\n    }, function(err) {\n      if (err) throw err; // It should not happen\n    });\n  });\n  return callback.promise;\n};\n\n/**\n * Set up the data source\n * @param {String} name The name\n * @param {Object} settings The settings\n * @returns {*}\n * @private\n */\nDataSource.prototype.setup = function(name, settings) {\n  var dataSource = this;\n  var connector;\n\n  // support single settings object\n  if (name && typeof name === 'object' && !settings) {\n    settings = name;\n    name = undefined;\n  }\n\n  if (typeof settings === 'object') {\n    if (settings.initialize) {\n      connector = settings;\n    } else if (settings.connector) {\n      connector = settings.connector;\n    } else if (settings.adapter) {\n      connector = settings.adapter;\n    }\n  }\n\n  // just save everything we get\n  this.settings = settings || {};\n\n  this.settings.debug = this.settings.debug || debug.enabled;\n\n  if (this.settings.debug) {\n    debug('Settings: %j', this.settings);\n  }\n\n  // Disconnected by default\n  this.connected = false;\n  this.connecting = false;\n\n  if (typeof connector === 'string') {\n    name = connector;\n    connector = undefined;\n  }\n  name = name || (connector && connector.name);\n  this.name = name;\n\n  if (name && !connector) {\n    if (typeof name === 'object') {\n      // The first argument might be the connector itself\n      connector = name;\n      this.name = connector.name;\n    } else {\n      // The connector has not been resolved\n      var result = DataSource._resolveConnector(name);\n      connector = result.connector;\n      if (!connector) {\n        console.error(result.error);\n        this.emit('error', new Error(result.error));\n        return;\n      }\n    }\n  }\n\n  if (connector) {\n    var postInit = function postInit(err, result) {\n      this._setupConnector();\n      // we have an connector now?\n      if (!this.connector) {\n        throw new Error(g.f('Connector is not defined correctly: ' +\n          'it should create `{{connector}}` member of dataSource'));\n      }\n      this.connected = !err; // Connected now\n      if (this.connected) {\n        this.emit('connected');\n      } else {\n        // The connection fails, let's report it and hope it will be recovered in the next call\n        g.error('Connection fails: %s\\nIt will be retried for the next request.', err);\n        this.emit('error', err);\n        this.connecting = false;\n      }\n    }.bind(this);\n\n    try {\n      if ('function' === typeof connector.initialize) {\n        // Call the async initialize method\n        connector.initialize(this, postInit);\n      } else if ('function' === typeof connector) {\n        // Use the connector constructor directly\n        this.connector = new connector(this.settings);\n        postInit();\n      }\n    } catch (err) {\n      if (err.message) {\n        err.message = 'Cannot initialize connector ' +\n          JSON.stringify(connector.name || name)  + ': ' +\n          err.message;\n      }\n      throw err;\n    }\n  }\n};\n\nfunction isModelClass(cls) {\n  if (!cls) {\n    return false;\n  }\n  return cls.prototype instanceof ModelBaseClass;\n}\n\nDataSource.relationTypes = Object.keys(RelationDefinition.RelationTypes);\n\nfunction isModelDataSourceAttached(model) {\n  return model && (!model.settings.unresolved) && (model.dataSource instanceof DataSource);\n}\n\n/*!\n * Define scopes for the model class from the scopes object\n * @param modelClass\n * @param scopes\n */\nDataSource.prototype.defineScopes = function(modelClass, scopes) {\n  if (scopes) {\n    for (var s in scopes) {\n      defineScope(modelClass, modelClass, s, scopes[s], {}, scopes[s].options);\n    }\n  }\n};\n\n/*!\n * Define relations for the model class from the relations object\n * @param modelClass\n * @param relations\n */\nDataSource.prototype.defineRelations = function(modelClass, relations) {\n  var self = this;\n\n  // Create a function for the closure in the loop\n  var createListener = function(name, relation, targetModel, throughModel) {\n    if (!isModelDataSourceAttached(targetModel)) {\n      targetModel.once('dataAccessConfigured', function(model) {\n        // Check if the through model doesn't exist or resolved\n        if (!throughModel || isModelDataSourceAttached(throughModel)) {\n          // The target model is resolved\n          var params = traverse(relation).clone();\n          params.as = name;\n          params.model = model;\n          if (throughModel) {\n            params.through = throughModel;\n          }\n          modelClass[relation.type].call(modelClass, name, params);\n        }\n      });\n    }\n\n    if (throughModel && !isModelDataSourceAttached(throughModel)) {\n      // Set up a listener to the through model\n      throughModel.once('dataAccessConfigured', function(model) {\n        if (isModelDataSourceAttached(targetModel)) {\n          // The target model is resolved\n          var params = traverse(relation).clone();\n          params.as = name;\n          params.model = targetModel;\n          params.through = model;\n          modelClass[relation.type].call(modelClass, name, params);\n        }\n      });\n    }\n  };\n\n  // Set up the relations\n  if (relations) {\n    Object.keys(relations).forEach(function(rn) {\n      var r = relations[rn];\n      assert(DataSource.relationTypes.indexOf(r.type) !== -1, 'Invalid relation type: ' + r.type);\n      assert(isValidRelationName(rn), 'Invalid relation name: ' + rn);\n\n      var targetModel, polymorphicName;\n\n      if (r.polymorphic && r.type !== 'belongsTo' && !r.model) {\n        throw new Error(g.f('No model specified for {{polymorphic}} %s: %s', r.type, rn));\n      }\n\n      if (r.polymorphic) {\n        polymorphicName = typeof r.model === 'string' ? r.model : rn;\n        if (typeof r.polymorphic === 'string') {\n          polymorphicName = r.polymorphic;\n        } else if (typeof r.polymorphic === 'object' && typeof r.polymorphic.as === 'string') {\n          polymorphicName = r.polymorphic.as;\n        }\n      }\n\n      if (r.model) {\n        targetModel = isModelClass(r.model) ? r.model : self.getModel(r.model, true);\n      }\n\n      var throughModel = null;\n      if (r.through) {\n        throughModel = isModelClass(r.through) ? r.through : self.getModel(r.through, true);\n      }\n\n      if ((targetModel && !isModelDataSourceAttached(targetModel)) ||\n          (throughModel && !isModelDataSourceAttached(throughModel))) {\n        // Create a listener to defer the relation set up\n        createListener(rn, r, targetModel, throughModel);\n      } else {\n        // The target model is resolved\n        var params = traverse(r).clone();\n        params.as = rn;\n        params.model = polymorphicName || targetModel;\n        if (throughModel) {\n          params.through = throughModel;\n        }\n        modelClass[r.type].call(modelClass, rn, params);\n      }\n    });\n  }\n};\n\nfunction isValidRelationName(relationName) {\n  var invalidRelationNames = ['trigger'];\n\n  return invalidRelationNames.indexOf(relationName) === -1;\n}\n\n/*!\n * Set up the data access functions from the data source\n * @param {Model} modelClass The model class\n * @param {Object} settings The settings object\n */\nDataSource.prototype.setupDataAccess = function(modelClass, settings) {\n  if (this.connector) {\n    // Check if the id property should be generated\n    var idName = modelClass.definition.idName();\n    var idProp = modelClass.definition.rawProperties[idName];\n    if (idProp && idProp.generated && this.connector.getDefaultIdType) {\n      // Set the default id type from connector's ability\n      var idType = this.connector.getDefaultIdType() || String;\n      idProp.type = idType;\n      modelClass.definition.rawProperties[idName].type = idType;\n      modelClass.definition.properties[idName].type = idType;\n      var forceId = settings.forceId;\n      if (idProp.generated && forceId !== false) {\n        forceId = true;\n      }\n      if (forceId) {\n        modelClass.validatesAbsenceOf(idName, {if: 'isNewRecord'});\n      }\n    }\n    if (this.connector.define) {\n      // pass control to connector\n      this.connector.define({\n        model: modelClass,\n        properties: modelClass.definition.properties,\n        settings: settings,\n      });\n    }\n  }\n\n  // add data access objects\n  this.mixin(modelClass);\n\n  // define relations from LDL (options.relations)\n  var relations = settings.relationships || settings.relations;\n  this.defineRelations(modelClass, relations);\n\n  // Emit the dataAccessConfigured event to indicate all the methods for data\n  // access have been mixed into the model class\n  modelClass.emit('dataAccessConfigured', modelClass);\n\n  // define scopes from LDL (options.relations)\n  var scopes = settings.scopes || {};\n  this.defineScopes(modelClass, scopes);\n};\n\n/**\n * Define a model class.  Returns newly created model object.\n * The first (String) argument specifying the model name is required.\n * You can provide one or two JSON object arguments, to provide configuration options.\n * See [Model definition reference](http://docs.strongloop.com/display/DOC/Model+definition+reference) for details.\n *\n * Simple example:\n * ```\n * var User = dataSource.createModel('User', {\n *     email: String,\n *     password: String,\n *     birthDate: Date,\n *     activated: Boolean\n * });\n * ```\n * More advanced example\n * ```\n * var User = dataSource.createModel('User', {\n *     email: { type: String, limit: 150, index: true },\n *     password: { type: String, limit: 50 },\n *     birthDate: Date,\n *     registrationDate: {type: Date, default: function () { return new Date }},\n *     activated: { type: Boolean, default: false }\n * });\n * ```\n * You can also define an ACL when you create a new data source with the `DataSource.create()` method. For example:\n *\n * ```js\n * var Customer = ds.createModel('Customer', {\n *       name: {\n *         type: String,\n *         acls: [\n *           {principalType: ACL.USER, principalId: 'u001', accessType: ACL.WRITE, permission: ACL.DENY},\n *           {principalType: ACL.USER, principalId: 'u001', accessType: ACL.ALL, permission: ACL.ALLOW}\n *         ]\n *       }\n *     }, {\n *       acls: [\n *         {principalType: ACL.USER, principalId: 'u001', accessType: ACL.ALL, permission: ACL.ALLOW}\n *       ]\n *     });\n * ```\n *\n * @param {String} className Name of the model to create.\n * @param {Object} properties Hash of model properties in format `{property: Type, property2: Type2, ...}` or `{property: {type: Type}, property2: {type: Type2}, ...}`\n * @options {Object} properties Other configuration options.  This corresponds to the options key in the config object.\n *\n */\n\nDataSource.prototype.createModel =\nDataSource.prototype.define = function defineClass(className, properties, settings) {\n  var args = slice.call(arguments);\n\n  if (!className) {\n    throw new Error(g.f('Class name required'));\n  }\n  if (args.length === 1) {\n    properties = {};\n    args.push(properties);\n  }\n  if (args.length === 2) {\n    settings = {};\n    args.push(settings);\n  }\n\n  properties = properties || {};\n  settings = settings || {};\n\n  if (this.isRelational()) {\n    // Set the strict mode to be true for relational DBs by default\n    if (settings.strict === undefined || settings.strict === null) {\n      settings.strict = true;\n    }\n    if (settings.strict === false) {\n      settings.strict = 'throw';\n    }\n  }\n\n  var modelClass = this.modelBuilder.define(className, properties, settings);\n  modelClass.dataSource = this;\n\n  if (settings.unresolved) {\n    return modelClass;\n  }\n\n  this.setupDataAccess(modelClass, settings);\n  modelClass.emit('dataSourceAttached', modelClass);\n\n  return modelClass;\n};\n\n/**\n * Mixin DataAccessObject methods.\n *\n * @param {Function} ModelCtor The model constructor\n * @private\n */\n\nDataSource.prototype.mixin = function(ModelCtor) {\n  var ops = this.operations();\n  var DAO = this.DataAccessObject;\n\n  // mixin DAO\n  jutil.mixin(ModelCtor, DAO, {proxyFunctions: true, override: true});\n\n  // decorate operations as alias functions\n  Object.keys(ops).forEach(function(name) {\n    var op = ops[name];\n    var scope;\n\n    if (op.enabled) {\n      scope = op.prototype ? ModelCtor.prototype : ModelCtor;\n      // var sfn = scope[name] = function () {\n      //   op.scope[op.fnName].apply(self, arguments);\n      // }\n      Object.keys(op)\n        .filter(function(key) {\n          // filter out the following keys\n          return ~[\n            'scope',\n            'fnName',\n            'prototype',\n          ].indexOf(key);\n        })\n        .forEach(function(key) {\n          if (typeof op[key] !== 'undefined') {\n            op.scope[op.fnName][key] = op[key];\n          }\n        });\n    }\n  });\n};\n\n/**\n * See ModelBuilder.getModel\n */\nDataSource.prototype.getModel = function(name, forceCreate) {\n  return this.modelBuilder.getModel(name, forceCreate);\n};\n\n/**\n * See ModelBuilder.getModelDefinition\n */\nDataSource.prototype.getModelDefinition = function(name) {\n  return this.modelBuilder.getModelDefinition(name);\n};\n\n/**\n * Get the data source types\n * @returns {String[]} The data source type, such as ['db', 'nosql', 'mongodb'],\n * ['rest'], or ['db', 'rdbms', 'mysql']\n */\nDataSource.prototype.getTypes = function() {\n  var getTypes = this.connector && this.connector.getTypes;\n  var types = getTypes && getTypes() || [];\n  if (typeof types === 'string') {\n    types = types.split(/[\\s,\\/]+/);\n  }\n  return types;\n};\n\n/**\n * Check the data source supports the specified types.\n * @param {String} types Type name or an array of type names.  Can also be array of Strings.\n * @returns {Boolean} true if all types are supported by the data source\n */\nDataSource.prototype.supportTypes = function(types) {\n  var supportedTypes = this.getTypes();\n  if (Array.isArray(types)) {\n    // Check each of the types\n    for (var i = 0; i < types.length; i++) {\n      if (supportedTypes.indexOf(types[i]) === -1) {\n        // Not supported\n        return false;\n      }\n    }\n    return true;\n  } else {\n    // The types is a string\n    return supportedTypes.indexOf(types) !== -1;\n  }\n};\n\n/**\n * Attach an existing model to a data source.\n *\n * @param {Function} modelClass The model constructor\n */\n\nDataSource.prototype.attach = function(modelClass) {\n  if (modelClass.dataSource === this) {\n    // Already attached to the data source\n    return modelClass;\n  }\n\n  if (modelClass.modelBuilder !== this.modelBuilder) {\n    this.modelBuilder.definitions[modelClass.modelName] = modelClass.definition;\n    this.modelBuilder.models[modelClass.modelName] = modelClass;\n    // reset the modelBuilder\n    modelClass.modelBuilder = this.modelBuilder;\n  }\n\n  // redefine the dataSource\n  modelClass.dataSource = this;\n\n  this.setupDataAccess(modelClass, modelClass.settings);\n  modelClass.emit('dataSourceAttached', modelClass);\n  return modelClass;\n};\n\n/**\n * Define single property named `prop` on `model`\n *\n * @param {String} model Name of model\n * @param {String} prop Name of property\n * @param {Object} params Property settings\n */\nDataSource.prototype.defineProperty = function(model, prop, params) {\n  this.modelBuilder.defineProperty(model, prop, params);\n\n  var resolvedProp = this.getModelDefinition(model).properties[prop];\n  if (this.connector && this.connector.defineProperty) {\n    this.connector.defineProperty(model, prop, resolvedProp);\n  }\n};\n\n/**\n * Drop each model table and re-create.\n * This method applies only to database connectors.  For MongoDB, it drops and creates indexes.\n *\n * **WARNING**: Calling this function deletes all data! Use `autoupdate()` to preserve data.\n *\n * @param {String} model Model to migrate.  If not present, apply to all models.  Can also be an array of Strings.\n * @param {Function} [callback] Callback function. Optional.\n *\n\n */\nDataSource.prototype.automigrate = function(models, cb) {\n  this.freeze();\n\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n\n  cb = cb || utils.createPromiseCallback();\n\n  if (!this.connector.automigrate) {\n    // NOOP\n    process.nextTick(cb);\n    return cb.promise;\n  }\n\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  var attachedModels = this.connector._models;\n\n  if (attachedModels && typeof attachedModels === 'object') {\n    models = models || Object.keys(attachedModels);\n\n    if (models.length === 0) {\n      process.nextTick(cb);\n      return cb.promise;\n    }\n\n    var invalidModels = models.filter(function(m) {\n      return !(m in attachedModels);\n    });\n\n    if (invalidModels.length) {\n      process.nextTick(function() {\n        cb(new Error(g.f('Cannot migrate models not attached to this datasource: %s',\n          invalidModels.join(' '))));\n      });\n      return cb.promise;\n    }\n  }\n\n  this.connector.automigrate(models, cb);\n  return cb.promise;\n};\n\n/**\n * Update existing database tables.\n * This method applies only to database connectors.\n *\n * @param {String} model Model to migrate.  If not present, apply to all models.  Can also be an array of Strings.\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.autoupdate = function(models, cb) {\n  this.freeze();\n\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n\n  cb = cb || utils.createPromiseCallback();\n\n  if (!this.connector.autoupdate) {\n    // NOOP\n    process.nextTick(cb);\n    return cb.promise;\n  }\n\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  var attachedModels = this.connector._models;\n\n  if (attachedModels && typeof attachedModels === 'object') {\n    models = models || Object.keys(attachedModels);\n\n    if (models.length === 0) {\n      process.nextTick(cb);\n      return cb.promise;\n    }\n\n    var invalidModels = models.filter(function(m) {\n      return !(m in attachedModels);\n    });\n\n    if (invalidModels.length) {\n      process.nextTick(function() {\n        cb(new Error(g.f('Cannot migrate models not attached to this datasource: %s',\n        invalidModels.join(' '))));\n      });\n      return cb.promise;\n    }\n  }\n\n  this.connector.autoupdate(models, cb);\n  return cb.promise;\n};\n\n/**\n * Discover existing database tables.\n * This method returns an array of model objects, including {type, name, onwer}\n *\n * @param {Object} options The options\n * @param {Function} Callback function.  Optional.\n * @options {Object} options Discovery options.  See below.\n * @property {String} owner/schema The owner or schema to discover from.\n * @property {Boolean} all If true, discover all models; if false, discover only models owned by the current user.\n * @property {Boolean} views If true, include views; if false, only tables.\n * @property {Number} limit Page size\n * @property {Number} offset Starting index\n *\n */\nDataSource.prototype.discoverModelDefinitions = function(options, cb) {\n  this.freeze();\n\n  if (cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  if (this.connector.discoverModelDefinitions) {\n    this.connector.discoverModelDefinitions(options, cb);\n  } else if (cb) {\n    process.nextTick(cb);\n  }\n  return cb.promise;\n};\n\n/**\n * The synchronous version of discoverModelDefinitions.\n * @options {Object} options The options\n * @property {Boolean} all If true, discover all models; if false, discover only models owned by the current user.\n * @property {Boolean} views If true, nclude views; if false, only tables.\n * @property {Number} limit Page size\n * @property {Number} offset Starting index\n * @returns {*}\n */\nDataSource.prototype.discoverModelDefinitionsSync = function(options) {\n  this.freeze();\n  if (this.connector.discoverModelDefinitionsSync) {\n    return this.connector.discoverModelDefinitionsSync(options);\n  }\n  return null;\n};\n\n/**\n * Discover properties for a given model.\n *\n * Callback function return value is an object that can have the following properties:\n *\n *| Key | Type | Description |\n *|-----|------|-------------|\n *|owner | String | Database owner or schema|\n *|tableName | String | Table/view name|\n *|columnName | String | Column name|\n *|dataType | String | Data type|\n *|dataLength | Number | Data length|\n *|dataPrecision | Number | Numeric data precision|\n *|dataScale |Number | Numeric data scale|\n *|nullable |Boolean | If true, then the data can be null|\n *\n * @param {String} modelName The table/view name\n * @options {Object} options The options\n * @property {String} owner|schema The database owner or schema\n * @param {Function} cb Callback function. Optional\n *\n */\nDataSource.prototype.discoverModelProperties = function(modelName, options, cb) {\n  this.freeze();\n\n  if (cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  if (this.connector.discoverModelProperties) {\n    this.connector.discoverModelProperties(modelName, options, cb);\n  } else if (cb) {\n    process.nextTick(cb);\n  }\n  return cb.promise;\n};\n\n/**\n * The synchronous version of discoverModelProperties\n * @param {String} modelName The table/view name\n * @param {Object} options The options\n * @returns {*}\n */\nDataSource.prototype.discoverModelPropertiesSync = function(modelName, options) {\n  this.freeze();\n  if (this.connector.discoverModelPropertiesSync) {\n    return this.connector.discoverModelPropertiesSync(modelName, options);\n  }\n  return null;\n};\n\n/**\n * Discover primary keys for a given owner/modelName.\n * Callback function return value is an object that can have the following properties:\n *\n *| Key | Type | Description |\n *|-----|------|-------------|\n *| owner |String | Table schema or owner (may be null). Owner defaults to current user.\n *| tableName |String| Table name\n *| columnName |String| Column name\n *| keySeq |Number| Sequence number within primary key (1 indicates the first column in the primary key; 2 indicates the second column in the primary key).\n *| pkName |String| Primary key name (may be null)\n *\n * @param {String} modelName The model name\n * @options {Object} options The options\n * @property {String} owner|schema The database owner or schema\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.discoverPrimaryKeys = function(modelName, options, cb) {\n  this.freeze();\n\n  if (cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  if (this.connector.discoverPrimaryKeys) {\n    this.connector.discoverPrimaryKeys(modelName, options, cb);\n  } else if (cb) {\n    process.nextTick(cb);\n  }\n  return cb.promise;\n};\n\n/**\n * The synchronous version of discoverPrimaryKeys\n * @param {String} modelName The model name\n * @options {Object} options The options\n * @property {String} owner|schema The database owner orschema\n * @returns {*}\n */\nDataSource.prototype.discoverPrimaryKeysSync = function(modelName, options) {\n  this.freeze();\n  if (this.connector.discoverPrimaryKeysSync) {\n    return this.connector.discoverPrimaryKeysSync(modelName, options);\n  }\n  return null;\n};\n\n/**\n * Discover foreign keys for a given owner/modelName\n *\n * Callback function return value is an object that can have the following properties:\n *\n *| Key | Type | Description |\n *|-----|------|-------------|\n *|fkOwner |String | Foreign key table schema (may be null)\n *|fkName |String | Foreign key name (may be null)\n *|fkTableName |String | Foreign key table name\n *|fkColumnName |String | Foreign key column name\n *|keySeq |Number | Sequence number within a foreign key( a value of 1 represents the first column of the foreign key, a value of 2 would represent the second column within the foreign key).\n *|pkOwner |String | Primary key table schema being imported (may be null)\n *|pkName |String | Primary key name (may be null)\n *|pkTableName |String | Primary key table name being imported\n *|pkColumnName |String | Primary key column name being imported\n *\n * @param {String} modelName The model name\n * @options {Object} options The options\n * @property {String} owner|schema The database owner or schema\n * @param {Function} [cb] The callback function\n *\n */\nDataSource.prototype.discoverForeignKeys = function(modelName, options, cb) {\n  this.freeze();\n\n  if (cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  if (this.connector.discoverForeignKeys) {\n    this.connector.discoverForeignKeys(modelName, options, cb);\n  } else if (cb) {\n    process.nextTick(cb);\n  }\n  return cb.promise;\n};\n\n/**\n * The synchronous version of discoverForeignKeys\n *\n * @param {String} modelName The model name\n * @param {Object} options The options\n * @returns {*}\n */\nDataSource.prototype.discoverForeignKeysSync = function(modelName, options) {\n  this.freeze();\n  if (this.connector.discoverForeignKeysSync) {\n    return this.connector.discoverForeignKeysSync(modelName, options);\n  }\n  return null;\n};\n\n/**\n * Retrieves a description of the foreign key columns that reference the given table's primary key columns\n * (the foreign keys exported by a table), ordered by fkTableOwner, fkTableName, and keySeq.\n *\n * Callback function return value is an object that can have the following properties:\n *\n *| Key | Type | Description |\n *|-----|------|-------------|\n *|fkOwner |String | Foreign key table schema (may be null)\n *|fkName |String | Foreign key name (may be null)\n *|fkTableName |String | Foreign key table name\n *|fkColumnName |String | Foreign key column name\n *|keySeq |Number | Sequence number within a foreign key( a value of 1 represents the first column of the foreign key, a value of 2 would represent the second column within the foreign key).\n *|pkOwner |String | Primary key table schema being imported (may be null)\n *|pkName |String | Primary key name (may be null)\n *|pkTableName |String | Primary key table name being imported\n *|pkColumnName |String | Primary key column name being imported\n *\n * @param {String} modelName The model name\n * @options {Object} options The options\n * @property {String} owner|schema The database owner or schema\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.discoverExportedForeignKeys = function(modelName, options, cb) {\n  this.freeze();\n\n  if (cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  if (this.connector.discoverExportedForeignKeys) {\n    this.connector.discoverExportedForeignKeys(modelName, options, cb);\n  } else if (cb) {\n    process.nextTick(cb);\n  }\n  return cb.promise;\n};\n\n/**\n * The synchronous version of discoverExportedForeignKeys\n * @param {String} modelName The model name\n * @param {Object} options The options\n * @returns {*}\n */\nDataSource.prototype.discoverExportedForeignKeysSync = function(modelName, options) {\n  this.freeze();\n  if (this.connector.discoverExportedForeignKeysSync) {\n    return this.connector.discoverExportedForeignKeysSync(modelName, options);\n  }\n  return null;\n};\n\nfunction capitalize(str) {\n  if (!str) {\n    return str;\n  }\n  return str.charAt(0).toUpperCase() + ((str.length > 1) ? str.slice(1).toLowerCase() : '');\n}\n\nfunction fromDBName(dbName, camelCase) {\n  if (!dbName) {\n    return dbName;\n  }\n  var parts = dbName.split(/-|_/);\n  parts[0] = camelCase ? parts[0].toLowerCase() : capitalize(parts[0]);\n\n  for (var i = 1; i < parts.length; i++) {\n    parts[i] = capitalize(parts[i]);\n  }\n  return parts.join('');\n}\n\n/**\n * Discover one schema from the given model without following the relations.\n **Example schema from oracle connector:**\n *\n * ```js\n *     {\n *       \"name\": \"Product\",\n *       \"options\": {\n *         \"idInjection\": false,\n *         \"oracle\": {\n *           \"schema\": \"BLACKPOOL\",\n *           \"table\": \"PRODUCT\"\n *         }\n *       },\n *       \"properties\": {\n *         \"id\": {\n *           \"type\": \"String\",\n *           \"required\": true,\n *           \"length\": 20,\n *           \"id\": 1,\n *           \"oracle\": {\n *             \"columnName\": \"ID\",\n *             \"dataType\": \"VARCHAR2\",\n *             \"dataLength\": 20,\n *             \"nullable\": \"N\"\n *           }\n *         },\n *         \"name\": {\n *           \"type\": \"String\",\n *           \"required\": false,\n *           \"length\": 64,\n *           \"oracle\": {\n *             \"columnName\": \"NAME\",\n *             \"dataType\": \"VARCHAR2\",\n *             \"dataLength\": 64,\n *             \"nullable\": \"Y\"\n *           }\n *         },\n * ...\n *         \"fireModes\": {\n *           \"type\": \"String\",\n *           \"required\": false,\n *           \"length\": 64,\n *           \"oracle\": {\n *             \"columnName\": \"FIRE_MODES\",\n *             \"dataType\": \"VARCHAR2\",\n *             \"dataLength\": 64,\n *             \"nullable\": \"Y\"\n *           }\n *         }\n *       }\n *     }\n * ```\n *\n * @param {String} modelName The model name\n * @param {Object} [options] The options\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.discoverSchema = function(modelName, options, cb) {\n  options = options || {};\n\n  if (!cb && 'function' === typeof options) {\n    cb = options;\n    options = {};\n  }\n  options.visited = {};\n  options.relations = false;\n\n  cb = cb || utils.createPromiseCallback();\n\n  this.discoverSchemas(modelName, options, function(err, schemas) {\n    if (err || !schemas) {\n      cb && cb(err, schemas);\n      return;\n    }\n    for (var s in schemas) {\n      cb && cb(null, schemas[s]);\n      return;\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Discover schema from a given modelName/view.\n *\n * @param {String} modelName The model name.\n * @options {Object} [options] Options; see below.\n * @property {String} owner|schema Database owner or schema name.\n * @property {Boolean} relations True if relations (primary key/foreign key) are navigated; false otherwise.\n * @property {Boolean} all True if all owners are included; false otherwise.\n * @property {Boolean} views True if views are included; false otherwise.\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.discoverSchemas = function(modelName, options, cb) {\n  options = options || {};\n\n  if (!cb && 'function' === typeof options) {\n    cb = options;\n    options = {};\n  }\n\n  cb = cb || utils.createPromiseCallback();\n\n  var self = this;\n  var dbType = this.connector.name || this.name;\n\n  var nameMapper;\n  if (options.nameMapper === null) {\n    // No mapping\n    nameMapper = function(type, name) {\n      return name;\n    };\n  } else if (typeof options.nameMapper === 'function') {\n    // Custom name mapper\n    nameMapper = options.nameMapper;\n  } else {\n    // Default name mapper\n    nameMapper = function mapName(type, name) {\n      if (type === 'table' || type === 'model') {\n        return fromDBName(name, false);\n      } else if (type == 'fk') {\n        return fromDBName(name + 'Rel', true);\n      } else {\n        return fromDBName(name, true);\n      }\n    };\n  }\n\n  if (this.connector.discoverSchemas) {\n    // Delegate to the connector implementation\n    this.connector.discoverSchemas(modelName, options, cb);\n    return cb.promise;\n  }\n\n  var tasks = [\n    this.discoverModelProperties.bind(this, modelName, options),\n    this.discoverPrimaryKeys.bind(this, modelName, options)];\n\n  var followingRelations = options.associations || options.relations;\n  if (followingRelations) {\n    tasks.push(this.discoverForeignKeys.bind(this, modelName, options));\n  }\n\n  async.parallel(tasks, function(err, results) {\n    if (err) {\n      cb(err);\n      return cb.promise;\n    }\n\n    var columns = results[0];\n    if (!columns || columns.length === 0) {\n      cb(new Error(g.f('Table \\'%s\\' does not exist.', modelName)));\n      return cb.promise;\n    }\n\n    // Handle primary keys\n    var primaryKeys = results[1] || [];\n    var pks = {};\n    primaryKeys.forEach(function(pk) {\n      pks[pk.columnName] = pk.keySeq;\n    });\n\n    if (self.settings.debug) {\n      debug('Primary keys: ', pks);\n    }\n\n    var schema = {\n      name: nameMapper('table', modelName),\n      options: {\n        idInjection: false, // DO NOT add id property\n      },\n      properties: {},\n    };\n\n    schema.options[dbType] = {\n      schema: columns[0].owner,\n      table: modelName,\n    };\n\n    columns.forEach(function(item) {\n      var propName = nameMapper('column', item.columnName);\n      schema.properties[propName] = {\n        type: item.type,\n        required: (item.nullable === 'N' || item.nullable === 'NO' ||\n          item.nullable === 0 || item.nullable === false),\n        length: item.dataLength,\n        precision: item.dataPrecision,\n        scale: item.dataScale,\n      };\n\n      if (pks[item.columnName]) {\n        schema.properties[propName].id = pks[item.columnName];\n      }\n      var dbSpecific = schema.properties[propName][dbType] = {\n        columnName: item.columnName,\n        dataType: item.dataType,\n        dataLength: item.dataLength,\n        dataPrecision: item.dataPrecision,\n        dataScale: item.dataScale,\n        nullable: item.nullable,\n      };\n      // merge connector-specific properties\n      if (item[dbType]) {\n        for (var k in item[dbType]) {\n          dbSpecific[k] = item[dbType][k];\n        }\n      }\n    });\n\n    // Add current modelName to the visited tables\n    options.visited = options.visited || {};\n    var schemaKey = columns[0].owner + '.' + modelName;\n    if (!options.visited.hasOwnProperty(schemaKey)) {\n      if (self.settings.debug) {\n        debug('Adding schema for ' + schemaKey);\n      }\n      options.visited[schemaKey] = schema;\n    }\n\n    var otherTables = {};\n    if (followingRelations) {\n      // Handle foreign keys\n      var fks = {};\n      var foreignKeys = results[2] || [];\n      foreignKeys.forEach(function(fk) {\n        var fkInfo = {\n          keySeq: fk.keySeq,\n          owner: fk.pkOwner,\n          tableName: fk.pkTableName,\n          columnName: fk.pkColumnName,\n        };\n        if (fks[fk.fkName]) {\n          fks[fk.fkName].push(fkInfo);\n        } else {\n          fks[fk.fkName] = [fkInfo];\n        }\n      });\n\n      if (self.settings.debug) {\n        debug('Foreign keys: ', fks);\n      }\n\n      schema.options.relations = {};\n      foreignKeys.forEach(function(fk) {\n        var propName = nameMapper('fk', (fk.fkName || fk.pkTableName));\n        schema.options.relations[propName] = {\n          model: nameMapper('table', fk.pkTableName),\n          type: 'belongsTo',\n          foreignKey: nameMapper('column', fk.fkColumnName),\n        };\n\n        var key = fk.pkOwner + '.' + fk.pkTableName;\n        if (!options.visited.hasOwnProperty(key) && !otherTables.hasOwnProperty(key)) {\n          otherTables[key] = {owner: fk.pkOwner, tableName: fk.pkTableName};\n        }\n      });\n    }\n\n    if (Object.keys(otherTables).length === 0) {\n      cb(null, options.visited);\n    } else {\n      var moreTasks = [];\n      for (var t in otherTables) {\n        if (self.settings.debug) {\n          debug('Discovering related schema for ' + schemaKey);\n        }\n        var newOptions = {};\n        for (var key in options) {\n          newOptions[key] = options[key];\n        }\n        newOptions.owner = otherTables[t].owner;\n\n        moreTasks.push(DataSource.prototype.discoverSchemas.bind(self, otherTables[t].tableName, newOptions));\n      }\n      async.parallel(moreTasks, function(err, results) {\n        var result = results && results[0];\n        cb(err, result);\n      });\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Discover schema from a given table/view synchronously\n *\n * @param {String} modelName The model name\n * @options {Object} [options] Options; see below.\n * @property {String} owner|schema Database owner or schema name.\n * @property {Boolean} relations True if relations (primary key/foreign key) are navigated; false otherwise.\n * @property {Boolean} all True if all owners are included; false otherwise.\n * @property {Boolean} views True if views are included; false otherwise.\n */\nDataSource.prototype.discoverSchemasSync = function(modelName, options) {\n  var self = this;\n  var dbType = this.name || this.connector.name;\n\n  var columns = this.discoverModelPropertiesSync(modelName, options);\n  if (!columns || columns.length === 0) {\n    return [];\n  }\n\n  var nameMapper = options.nameMapper || function mapName(type, name) {\n    if (type === 'table' || type === 'model') {\n      return fromDBName(name, false);\n    } else {\n      return fromDBName(name, true);\n    }\n  };\n\n  // Handle primary keys\n  var primaryKeys = this.discoverPrimaryKeysSync(modelName, options);\n  var pks = {};\n  primaryKeys.forEach(function(pk) {\n    pks[pk.columnName] = pk.keySeq;\n  });\n\n  if (self.settings.debug) {\n    debug('Primary keys: ', pks);\n  }\n\n  var schema = {\n    name: nameMapper('table', modelName),\n    options: {\n      idInjection: false, // DO NOT add id property\n    },\n    properties: {},\n  };\n\n  schema.options[dbType] = {\n    schema: columns.length > 0 && columns[0].owner,\n    table: modelName,\n  };\n\n  columns.forEach(function(item) {\n    var i = item;\n\n    var propName = nameMapper('column', item.columnName);\n    schema.properties[propName] = {\n      type: item.type,\n      required: (item.nullable === 'N'),\n      length: item.dataLength,\n      precision: item.dataPrecision,\n      scale: item.dataScale,\n    };\n\n    if (pks[item.columnName]) {\n      schema.properties[propName].id = pks[item.columnName];\n    }\n    schema.properties[propName][dbType] = {\n      columnName: i.columnName,\n      dataType: i.dataType,\n      dataLength: i.dataLength,\n      dataPrecision: item.dataPrecision,\n      dataScale: item.dataScale,\n      nullable: i.nullable,\n    };\n  });\n\n  // Add current modelName to the visited tables\n  options.visited = options.visited || {};\n  var schemaKey = columns[0].owner + '.' + modelName;\n  if (!options.visited.hasOwnProperty(schemaKey)) {\n    if (self.settings.debug) {\n      debug('Adding schema for ' + schemaKey);\n    }\n    options.visited[schemaKey] = schema;\n  }\n\n  var otherTables = {};\n  var followingRelations = options.associations || options.relations;\n  if (followingRelations) {\n    // Handle foreign keys\n    var fks = {};\n    var foreignKeys = this.discoverForeignKeysSync(modelName, options);\n    foreignKeys.forEach(function(fk) {\n      var fkInfo = {\n        keySeq: fk.keySeq,\n        owner: fk.pkOwner,\n        tableName: fk.pkTableName,\n        columnName: fk.pkColumnName,\n      };\n      if (fks[fk.fkName]) {\n        fks[fk.fkName].push(fkInfo);\n      } else {\n        fks[fk.fkName] = [fkInfo];\n      }\n    });\n\n    if (self.settings.debug) {\n      debug('Foreign keys: ', fks);\n    }\n\n    schema.options.relations = {};\n    foreignKeys.forEach(function(fk) {\n      var propName = nameMapper('column', fk.pkTableName);\n      schema.options.relations[propName] = {\n        model: nameMapper('table', fk.pkTableName),\n        type: 'belongsTo',\n        foreignKey: nameMapper('column', fk.fkColumnName),\n      };\n\n      var key = fk.pkOwner + '.' + fk.pkTableName;\n      if (!options.visited.hasOwnProperty(key) && !otherTables.hasOwnProperty(key)) {\n        otherTables[key] = {owner: fk.pkOwner, tableName: fk.pkTableName};\n      }\n    });\n  }\n\n  if (Object.keys(otherTables).length === 0) {\n    return options.visited;\n  } else {\n    var moreTasks = [];\n    for (var t in otherTables) {\n      if (self.settings.debug) {\n        debug('Discovering related schema for ' + schemaKey);\n      }\n      var newOptions = {};\n      for (var key in options) {\n        newOptions[key] = options[key];\n      }\n      newOptions.owner = otherTables[t].owner;\n      self.discoverSchemasSync(otherTables[t].tableName, newOptions);\n    }\n    return options.visited;\n  }\n};\n\n/**\n * Discover and build models from the specified owner/modelName.\n *\n * @param {String} modelName The model name.\n * @options {Object} [options] Options; see below.\n * @property {String} owner|schema Database owner or schema name.\n * @property {Boolean} relations True if relations (primary key/foreign key) are navigated; false otherwise.\n * @property {Boolean} all True if all owners are included; false otherwise.\n * @property {Boolean} views True if views are included; false otherwise.\n * @param {Function} [cb] The callback function\n */\nDataSource.prototype.discoverAndBuildModels = function(modelName, options, cb) {\n  var self = this;\n  options = options || {};\n  this.discoverSchemas(modelName, options, function(err, schemas) {\n    if (err) {\n      cb && cb(err, schemas);\n      return;\n    }\n\n    var schemaList = [];\n    for (var s in schemas) {\n      var schema = schemas[s];\n      if (options.base) {\n        schema.options = schema.options || {};\n        schema.options.base = options.base;\n      }\n      schemaList.push(schema);\n    }\n\n    var models = self.modelBuilder.buildModels(schemaList,\n      self.createModel.bind(self));\n\n    cb && cb(err, models);\n  });\n};\n\n/**\n * Discover and build models from the given owner/modelName synchronously.\n *\n * @param {String} modelName The model name.\n * @options {Object} [options] Options; see below.\n * @property {String} owner|schema Database owner or schema name.\n * @property {Boolean} relations True if relations (primary key/foreign key) are navigated; false otherwise.\n * @property {Boolean} all True if all owners are included; false otherwise.\n * @property {Boolean} views True if views are included; false otherwise.\n\n * @param {String} modelName The model name\n * @param {Object} [options] The options\n */\nDataSource.prototype.discoverAndBuildModelsSync = function(modelName, options) {\n  options = options || {};\n  var schemas = this.discoverSchemasSync(modelName, options);\n\n  var schemaList = [];\n  for (var s in schemas) {\n    var schema = schemas[s];\n    if (options.base) {\n      schema.options = schema.options || {};\n      schema.options.base = options.base;\n    }\n    schemaList.push(schema);\n  }\n\n  var models = this.modelBuilder.buildModels(schemaList,\n    this.createModel.bind(this));\n\n  return models;\n};\n\n/**\n * Introspect a JSON object and build a model class\n * @param {String} name Name of the model\n * @param {Object} json The json object representing a model instance\n * @param {Object} options Options\n * @returns {*}\n */\nDataSource.prototype.buildModelFromInstance = function(name, json, options) {\n  // Introspect the JSON document to generate a schema\n  var schema = ModelBuilder.introspect(json);\n\n  // Create a model for the generated schema\n  return this.createModel(name, schema, options);\n};\n\n/**\n * Check whether migrations needed\n * This method applies only to SQL connectors.\n * @param {String|String[]} [models] A model name or an array of model names. If not present, apply to all models.\n */\nDataSource.prototype.isActual = function(models, cb) {\n  this.freeze();\n  if (this.connector.isActual) {\n    this.connector.isActual(models, cb);\n  } else {\n    if ((!cb) && ('function' === typeof models)) {\n      cb = models;\n      models = undefined;\n    }\n    if (cb) {\n      process.nextTick(function() {\n        cb(null, true);\n      });\n    }\n  }\n};\n\n/**\n * Log benchmarked message. Do not redefine this method, if you need to grab\n * chema logs, use `dataSource.on('log', ...)` emitter event\n *\n * @private used by connectors\n */\nDataSource.prototype.log = function(sql, t) {\n  debug(sql, t);\n  this.emit('log', sql, t);\n};\n\n/**\n * Freeze dataSource. Behavior depends on connector\n */\nDataSource.prototype.freeze = function freeze() {\n  if (!this.connector) {\n    throw new Error(g.f('The connector has not been initialized.'));\n  }\n  if (this.connector.freezeDataSource) {\n    this.connector.freezeDataSource();\n  }\n  if (this.connector.freezeSchema) {\n    this.connector.freezeSchema();\n  }\n};\n\n/**\n * Return table name for specified `modelName`\n * @param {String} modelName The model name\n */\nDataSource.prototype.tableName = function(modelName) {\n  return this.getModelDefinition(modelName).tableName(this.connector.name);\n};\n\n/**\n * Return column name for specified modelName and propertyName\n * @param {String} modelName The model name\n * @param {String} propertyName The property name\n * @returns {String} columnName The column name.\n */\nDataSource.prototype.columnName = function(modelName, propertyName) {\n  return this.getModelDefinition(modelName).columnName(this.connector.name, propertyName);\n};\n\n/**\n * Return column metadata for specified modelName and propertyName\n * @param {String} modelName The model name\n * @param {String} propertyName The property name\n * @returns {Object} column metadata\n */\nDataSource.prototype.columnMetadata = function(modelName, propertyName) {\n  return this.getModelDefinition(modelName).columnMetadata(this.connector.name, propertyName);\n};\n\n/**\n * Return column names for specified modelName\n * @param {String} modelName The model name\n * @returns {String[]} column names\n */\nDataSource.prototype.columnNames = function(modelName) {\n  return this.getModelDefinition(modelName).columnNames(this.connector.name);\n};\n\n/**\n * Find the ID column name\n * @param {String} modelName The model name\n * @returns {String} columnName for ID\n */\nDataSource.prototype.idColumnName = function(modelName) {\n  return this.getModelDefinition(modelName).idColumnName(this.connector.name);\n};\n\n/**\n * Find the ID property name\n * @param {String} modelName The model name\n * @returns {String} property name for ID\n */\nDataSource.prototype.idName = function(modelName) {\n  if (!this.getModelDefinition(modelName).idName) {\n    g.error('No {{id}} name %s', this.getModelDefinition(modelName));\n  }\n  return this.getModelDefinition(modelName).idName();\n};\n\n/**\n * Find the ID property names sorted by the index\n * @param {String} modelName The model name\n * @returns {String[]} property names for IDs\n */\nDataSource.prototype.idNames = function(modelName) {\n  return this.getModelDefinition(modelName).idNames();\n};\n\n/**\n * Find the id property definition\n * @param {String} modelName The model name\n * @returns {Object} The id property definition\n */\nDataSource.prototype.idProperty = function(modelName) {\n  var def = this.getModelDefinition(modelName);\n  var idProps = def && def.ids();\n  return idProps && idProps[0] && idProps[0].property;\n};\n\n/**\n * Define foreign key to another model\n * @param {String} className The model name that owns the key\n * @param {String} key Name of key field\n * @param {String} foreignClassName The foreign model name\n * @param {String} pkName (optional) primary key used for foreignKey\n */\nDataSource.prototype.defineForeignKey = function defineForeignKey(className, key, foreignClassName, pkName) {\n  var pkType = null;\n  var foreignModel = this.getModelDefinition(foreignClassName);\n  pkName = pkName || foreignModel && foreignModel.idName();\n  if (pkName) {\n    pkType = foreignModel.properties[pkName].type;\n  }\n  var model = this.getModelDefinition(className);\n  if (model.properties[key]) {\n    if (pkType) {\n      // Reset the type of the foreign key\n      model.rawProperties[key].type = model.properties[key].type = pkType;\n    }\n    return;\n  }\n\n  var fkDef = {type: pkType};\n  var foreignMeta = this.columnMetadata(foreignClassName, pkName);\n  if (foreignMeta && (foreignMeta.dataType || foreignMeta.dataLength)) {\n    fkDef[this.connector.name] = {};\n    if (foreignMeta.dataType) {\n      fkDef[this.connector.name].dataType = foreignMeta.dataType;\n    }\n    if (foreignMeta.dataLength) {\n      fkDef[this.connector.name].dataLength = foreignMeta.dataLength;\n    }\n  }\n  if (this.connector.defineForeignKey) {\n    var cb = function(err, keyType) {\n      if (err) throw err;\n      fkDef.type = keyType || pkType;\n      // Add the foreign key property to the data source _models\n      this.defineProperty(className, key, fkDef);\n    }.bind(this);\n    switch (this.connector.defineForeignKey.length) {\n      case 4:\n        this.connector.defineForeignKey(className, key, foreignClassName, cb);\n        break;\n      default:\n      case 3:\n        this.connector.defineForeignKey(className, key, cb);\n        break;\n    }\n  } else {\n    // Add the foreign key property to the data source _models\n    this.defineProperty(className, key, fkDef);\n  }\n};\n\n/**\n * Close database connection\n * @param {Function} [cb] The callback function. Optional.\n */\nDataSource.prototype.disconnect = function disconnect(cb) {\n  var self = this;\n  if (this.connected && (typeof this.connector.disconnect === 'function')) {\n    this.connector.disconnect(function(err, result) {\n      self.connected = false;\n      cb && cb(err, result);\n    });\n  } else {\n    process.nextTick(function() {\n      self.connected = false;\n      cb && cb();\n    });\n  }\n};\n\n/**\n * Copy the model from Master.\n * @param {Function} Master The model constructor\n * @returns {Function} The copy of the model constructor\n *\n * @private\n */\nDataSource.prototype.copyModel = function copyModel(Master) {\n  var dataSource = this;\n  var className = Master.modelName;\n  var md = Master.modelBuilder.getModelDefinition(className);\n  var Slave = function SlaveModel() {\n    Master.apply(this, [].slice.call(arguments));\n  };\n\n  util.inherits(Slave, Master);\n\n  // Delegating static properties\n  Slave.__proto__ = Master;\n\n  hiddenProperty(Slave, 'dataSource', dataSource);\n  hiddenProperty(Slave, 'modelName', className);\n  hiddenProperty(Slave, 'relations', Master.relations);\n\n  if (!(className in dataSource.modelBuilder.models)) {\n    // store class in model pool\n    dataSource.modelBuilder.models[className] = Slave;\n    dataSource.modelBuilder.definitions[className] =\n      new ModelDefinition(dataSource.modelBuilder, md.name, md.properties, md.settings);\n\n    if ((!dataSource.isTransaction) && dataSource.connector && dataSource.connector.define) {\n      dataSource.connector.define({\n        model: Slave,\n        properties: md.properties,\n        settings: md.settings,\n      });\n    }\n  }\n\n  return Slave;\n};\n\n/**\n *\n * @returns {EventEmitter}\n * @private\n */\nDataSource.prototype.transaction = function() {\n  var dataSource = this;\n  var transaction = new EventEmitter();\n\n  for (var p in dataSource) {\n    transaction[p] = dataSource[p];\n  }\n\n  transaction.isTransaction = true;\n  transaction.origin = dataSource;\n  transaction.name = dataSource.name;\n  transaction.settings = dataSource.settings;\n  transaction.connected = false;\n  transaction.connecting = false;\n  transaction.connector = dataSource.connector.transaction();\n\n  // create blank models pool\n  transaction.modelBuilder = new ModelBuilder();\n  transaction.models = transaction.modelBuilder.models;\n  transaction.definitions = transaction.modelBuilder.definitions;\n\n  for (var i in dataSource.modelBuilder.models) {\n    dataSource.copyModel.call(transaction, dataSource.modelBuilder.models[i]);\n  }\n\n  transaction.exec = function(cb) {\n    transaction.connector.exec(cb);\n  };\n\n  return transaction;\n};\n\n/**\n * Enable remote access to a data source operation. Each [connector](#connector) has its own set of set\n * remotely enabled and disabled operations. To list the operations, call `dataSource.operations()`.\n * @param {String} operation The operation name\n */\n\nDataSource.prototype.enableRemote = function(operation) {\n  var op = this.getOperation(operation);\n  if (op) {\n    op.remoteEnabled = true;\n  } else {\n    throw new Error(g.f('%s is not provided by the attached connector', operation));\n  }\n};\n\n/**\n * Disable remote access to a data source operation. Each [connector](#connector) has its own set of set enabled\n * and disabled operations. To list the operations, call `dataSource.operations()`.\n *\n *```js\n * var oracle = loopback.createDataSource({\n *   connector: require('loopback-connector-oracle'),\n *   host: '...',\n *   ...\n * });\n * oracle.disableRemote('destroyAll');\n * ```\n * **Notes:**\n *\n * - Disabled operations will not be added to attached models.\n * - Disabling the remoting for a method only affects client access (it will still be available from server models).\n * - Data sources must enable / disable operations before attaching or creating models.\n * @param {String} operation The operation name\n */\n\nDataSource.prototype.disableRemote = function(operation) {\n  var op = this.getOperation(operation);\n  if (op) {\n    op.remoteEnabled = false;\n  } else {\n    throw new Error(g.f('%s is not provided by the attached connector', operation));\n  }\n};\n\n/**\n * Get an operation's metadata.\n * @param {String} operation The operation name\n */\n\nDataSource.prototype.getOperation = function(operation) {\n  var ops = this.operations();\n  var opKeys = Object.keys(ops);\n\n  for (var i = 0; i < opKeys.length; i++) {\n    var op = ops[opKeys[i]];\n\n    if (op.name === operation) {\n      return op;\n    }\n  }\n};\n\n/**\n * Return JSON object describing all operations.\n *\n * Example return value:\n * ```js\n * {\n *  find: {\n *    remoteEnabled: true,\n *    accepts: [...],\n *    returns: [...]\n *    enabled: true\n * },\n *  save: {\n *    remoteEnabled: true,\n *    prototype: true,\n *    accepts: [...],\n *    returns: [...],\n *    enabled: true\n *  },\n *  ...\n * }\n * ```\n */\nDataSource.prototype.operations = function() {\n  return this._operations;\n};\n\n/**\n * Define an operation to the data source\n * @param {String} name The operation name\n * @param {Object} options The options\n * @param {Function} fn The function\n */\nDataSource.prototype.defineOperation = function(name, options, fn) {\n  options.fn = fn;\n  options.name = name;\n  this._operations[name] = options;\n};\n\n/**\n * Check if the backend is a relational DB\n * @returns {Boolean}\n */\nDataSource.prototype.isRelational = function() {\n  return this.connector && this.connector.relational;\n};\n\n/*!\n * Check if the data source is ready.\n * Returns a Boolean value.\n * @param {Object} obj  ?\n * @param {Object} args  ?\n */\nDataSource.prototype.ready = function(obj, args) {\n  var self = this;\n  if (this.connected) {\n    // Connected\n    return false;\n  }\n\n  var method = args.callee;\n  // Set up a callback after the connection is established to continue the method call\n\n  var onConnected = null, onError = null, timeoutHandle = null;\n  onConnected = function() {\n    // Remove the error handler\n    self.removeListener('error', onError);\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle);\n    }\n    var params = [].slice.call(args);\n    try {\n      method.apply(obj, params);\n    } catch (err) {\n      // Catch the exception and report it via callback\n      var cb = params.pop();\n      if (typeof cb === 'function') {\n        process.nextTick(function() {\n          cb(err);\n        });\n      } else {\n        throw err;\n      }\n    }\n  };\n  onError = function(err) {\n    // Remove the connected listener\n    self.removeListener('connected', onConnected);\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle);\n    }\n    var params = [].slice.call(args);\n    var cb = params.pop();\n    if (typeof cb === 'function') {\n      process.nextTick(function() {\n        cb(err);\n      });\n    }\n  };\n  this.once('connected', onConnected);\n  this.once('error', onError);\n\n  // Set up a timeout to cancel the invocation\n  var timeout = this.settings.connectionTimeout || 5000;\n  timeoutHandle = setTimeout(function() {\n    self.removeListener('error', onError);\n    self.removeListener('connected', onConnected);\n    var params = [].slice.call(args);\n    var cb = params.pop();\n    if (typeof cb === 'function') {\n      cb(new Error(g.f('Timeout in connecting after %s ms', timeout)));\n    }\n  }, timeout);\n\n  if (!this.connecting) {\n    this.connect();\n  }\n  return true;\n};\n\n/**\n * Ping the underlying connector to test the connections\n * @param {Function} [cb] Callback function\n */\nDataSource.prototype.ping = function(cb) {\n  var self = this;\n  if (self.connector.ping) {\n    this.connector.ping(cb);\n  } else if (self.connector.discoverModelProperties) {\n    self.discoverModelProperties('dummy', {}, cb);\n  } else {\n    process.nextTick(function() {\n      var err = self.connected ? null : new Error(g.f('Not connected'));\n      cb(err);\n    });\n  }\n};\n\n/**\n * Define a hidden property\n * @param {Object} obj The property owner\n * @param {String} key The property name\n * @param {Mixed} value The default value\n */\nfunction hiddenProperty(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    writable: false,\n    enumerable: false,\n    configurable: false,\n    value: value,\n  });\n}\n\n/**\n * Define readonly property on object\n *\n * @param {Object} obj The property owner\n * @param {String} key The property name\n * @param {Mixed} value The default value\n */\nfunction defineReadonlyProp(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    writable: false,\n    enumerable: true,\n    configurable: true,\n    value: value,\n  });\n}\n\n// Carry over a few properties/methods from the ModelBuilder as some tests use them\nDataSource.Text = ModelBuilder.Text;\nDataSource.JSON = ModelBuilder.JSON;\nDataSource.Any = ModelBuilder.Any;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/relation-definition.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\n/*!\n * Dependencies\n */\nvar assert = require('assert');\nvar util = require('util');\nvar async = require('async');\nvar utils = require('./utils');\nvar i8n = require('inflection');\nvar defineScope = require('./scope.js').defineScope;\nvar g = require('strong-globalize')();\nvar mergeQuery = utils.mergeQuery;\nvar idEquals = utils.idEquals;\nvar ModelBaseClass = require('./model.js');\nvar applyFilter = require('./connectors/memory').applyFilter;\nvar ValidationError = require('./validations.js').ValidationError;\nvar debug = require('debug')('loopback:relations');\n\nvar RelationTypes = {\n  belongsTo: 'belongsTo',\n  hasMany: 'hasMany',\n  hasOne: 'hasOne',\n  hasAndBelongsToMany: 'hasAndBelongsToMany',\n  referencesMany: 'referencesMany',\n  embedsOne: 'embedsOne',\n  embedsMany: 'embedsMany',\n};\n\nvar RelationClasses = {\n  belongsTo: BelongsTo,\n  hasMany: HasMany,\n  hasManyThrough: HasManyThrough,\n  hasOne: HasOne,\n  hasAndBelongsToMany: HasAndBelongsToMany,\n  referencesMany: ReferencesMany,\n  embedsOne: EmbedsOne,\n  embedsMany: EmbedsMany,\n};\n\nexports.Relation = Relation;\nexports.RelationDefinition = RelationDefinition;\n\nexports.RelationTypes = RelationTypes;\nexports.RelationClasses = RelationClasses;\n\nexports.HasMany = HasMany;\nexports.HasManyThrough = HasManyThrough;\nexports.HasOne = HasOne;\nexports.HasAndBelongsToMany = HasAndBelongsToMany;\nexports.BelongsTo = BelongsTo;\nexports.ReferencesMany = ReferencesMany;\nexports.EmbedsOne = EmbedsOne;\nexports.EmbedsMany = EmbedsMany;\n\nfunction normalizeType(type) {\n  if (!type) {\n    return type;\n  }\n  var t1 = type.toLowerCase();\n  for (var t2 in RelationTypes) {\n    if (t2.toLowerCase() === t1) {\n      return t2;\n    }\n  }\n  return null;\n};\n\nfunction extendScopeMethods(definition, scopeMethods, ext) {\n  var customMethods = [];\n  var relationClass = RelationClasses[definition.type];\n  if (definition.type === RelationTypes.hasMany && definition.modelThrough) {\n    relationClass = RelationClasses.hasManyThrough;\n  }\n  if (typeof ext === 'function') {\n    customMethods = ext.call(definition, scopeMethods, relationClass);\n  } else if (typeof ext === 'object') {\n    function createFunc(definition, relationMethod) {\n      return function() {\n        var relation = new relationClass(definition, this);\n        return relationMethod.apply(relation, arguments);\n      };\n    };\n    for (var key in ext) {\n      var relationMethod = ext[key];\n      var method = scopeMethods[key] = createFunc(definition, relationMethod);\n      if (relationMethod.shared) {\n        sharedMethod(definition, key, method, relationMethod);\n      }\n      customMethods.push(key);\n    }\n  }\n  return [].concat(customMethods || []);\n};\n\nfunction bindRelationMethods(relation, relationMethod, definition) {\n  var methods = definition.methods || {};\n  Object.keys(methods).forEach(function(m) {\n    if (typeof methods[m] !== 'function') return;\n    relationMethod[m] = methods[m].bind(relation);\n  });\n};\n\n/**\n * Relation definition class.  Use to define relationships between models.\n * @param {Object} definition\n * @class RelationDefinition\n */\nfunction RelationDefinition(definition) {\n  if (!(this instanceof RelationDefinition)) {\n    return new RelationDefinition(definition);\n  }\n  definition = definition || {};\n  this.name = definition.name;\n  assert(this.name, 'Relation name is missing');\n  this.type = normalizeType(definition.type);\n  assert(this.type, 'Invalid relation type: ' + definition.type);\n  this.modelFrom = definition.modelFrom;\n  assert(this.modelFrom, 'Source model is required');\n  this.keyFrom = definition.keyFrom;\n  this.modelTo = definition.modelTo;\n  this.keyTo = definition.keyTo;\n  this.polymorphic = definition.polymorphic;\n  if (typeof this.polymorphic !== 'object') {\n    assert(this.modelTo, 'Target model is required');\n  }\n  this.modelThrough = definition.modelThrough;\n  this.keyThrough = definition.keyThrough;\n  this.multiple = definition.multiple;\n  this.properties = definition.properties || {};\n  this.options = definition.options || {};\n  this.scope = definition.scope;\n  this.embed = definition.embed === true;\n  this.methods = definition.methods || {};\n}\n\nRelationDefinition.prototype.toJSON = function() {\n  var polymorphic = typeof this.polymorphic === 'object';\n\n  var modelToName = this.modelTo && this.modelTo.modelName;\n  if (!modelToName && polymorphic && this.type === 'belongsTo') {\n    modelToName = '<polymorphic>';\n  }\n\n  var json = {\n    name: this.name,\n    type: this.type,\n    modelFrom: this.modelFrom.modelName,\n    keyFrom: this.keyFrom,\n    modelTo: modelToName,\n    keyTo: this.keyTo,\n    multiple: this.multiple,\n  };\n  if (this.modelThrough) {\n    json.modelThrough = this.modelThrough.modelName;\n    json.keyThrough = this.keyThrough;\n  }\n  if (polymorphic) {\n    json.polymorphic = this.polymorphic;\n  }\n  return json;\n};\n\n/**\n * Define a relation scope method\n * @param {String} name of the method\n * @param {Function} function to define\n */\nRelationDefinition.prototype.defineMethod = function(name, fn) {\n  var relationClass = RelationClasses[this.type];\n  var relationName = this.name;\n  var modelFrom = this.modelFrom;\n  var definition = this;\n  var method;\n  if (definition.multiple) {\n    var scope = this.modelFrom.scopes[this.name];\n    if (!scope) throw new Error(g.f('Unknown relation {{scope}}: %s', this.name));\n    method = scope.defineMethod(name, function() {\n      var relation = new relationClass(definition, this);\n      return fn.apply(relation, arguments);\n    });\n  } else {\n    definition.methods[name] = fn;\n    method = function() {\n      var rel = this[relationName];\n      return rel[name].apply(rel, arguments);\n    };\n  }\n  if (method && fn.shared) {\n    sharedMethod(definition, name, method, fn);\n    modelFrom.prototype['__' + name + '__' + relationName] = method;\n  }\n  return method;\n};\n\n/**\n * Apply the configured scope to the filter/query object.\n * @param {Object} modelInstance\n * @param {Object} filter (where, order, limit, fields, ...)\n */\nRelationDefinition.prototype.applyScope = function(modelInstance, filter) {\n  filter = filter || {};\n  filter.where = filter.where || {};\n  if ((this.type !== 'belongsTo' || this.type === 'hasOne') &&\n      typeof this.polymorphic === 'object') { // polymorphic\n    var discriminator = this.polymorphic.discriminator;\n    if (this.polymorphic.invert) {\n      filter.where[discriminator] = this.modelTo.modelName;\n    } else {\n      filter.where[discriminator] = this.modelFrom.modelName;\n    }\n  }\n  var scope;\n  if (typeof this.scope === 'function') {\n    scope = this.scope.call(this, modelInstance, filter);\n  } else {\n    scope = this.scope;\n  }\n  if (typeof scope === 'object') {\n    mergeQuery(filter, scope);\n  }\n};\n\n/**\n * Apply the configured properties to the target object.\n * @param {Object} modelInstance\n * @param {Object} target\n */\nRelationDefinition.prototype.applyProperties = function(modelInstance, obj) {\n  var source = modelInstance, target = obj;\n  if (this.options.invertProperties) {\n    source = obj;\n    target = modelInstance;\n  }\n  if (this.options.embedsProperties) {\n    target = target.__data[this.name] = {};\n    target[this.keyTo] = source[this.keyTo];\n  }\n  var k, key;\n  if (typeof this.properties === 'function') {\n    var data = this.properties.call(this, source, target);\n    for (k in data) {\n      target[k] = data[k];\n    }\n  } else if (Array.isArray(this.properties)) {\n    for (k = 0; k < this.properties.length; k++) {\n      key = this.properties[k];\n      target[key] = source[key];\n    }\n  } else if (typeof this.properties === 'object') {\n    for (k in this.properties) {\n      key = this.properties[k];\n      target[key] = source[k];\n    }\n  }\n  if ((this.type !== 'belongsTo' || this.type === 'hasOne') &&\n      typeof this.polymorphic === 'object') { // polymorphic\n    var discriminator = this.polymorphic.discriminator;\n    if (this.polymorphic.invert) {\n      target[discriminator] = this.modelTo.modelName;\n    } else {\n      target[discriminator] = this.modelFrom.modelName;\n    }\n  }\n};\n\n/**\n * A relation attaching to a given model instance\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {Relation}\n * @constructor\n * @class Relation\n */\nfunction Relation(definition, modelInstance) {\n  if (!(this instanceof Relation)) {\n    return new Relation(definition, modelInstance);\n  }\n  if (!(definition instanceof RelationDefinition)) {\n    definition = new RelationDefinition(definition);\n  }\n  this.definition = definition;\n  this.modelInstance = modelInstance;\n}\n\nRelation.prototype.resetCache = function(cache) {\n  cache = cache || undefined;\n  this.modelInstance.__cachedRelations[this.definition.name] = cache;\n};\n\nRelation.prototype.getCache = function() {\n  return this.modelInstance.__cachedRelations[this.definition.name];\n};\n\nRelation.prototype.callScopeMethod = function(methodName) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  var modelInstance = this.modelInstance;\n  var rel = modelInstance[this.definition.name];\n  if (rel && typeof rel[methodName] === 'function') {\n    return rel[methodName].apply(rel, args);\n  } else {\n    throw new Error(g.f('Unknown scope method: %s', methodName));\n  }\n};\n\n/**\n * Fetch the related model(s) - this is a helper method to unify access.\n * @param (Boolean|Object} condOrRefresh refresh or conditions object\n * @param {Object} [options] Options\n * @param {Function} cb callback\n */\nRelation.prototype.fetch = function(condOrRefresh, options, cb) {\n  this.modelInstance[this.definition.name].apply(this.modelInstance, arguments);\n};\n\n/**\n * HasMany subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {HasMany}\n * @constructor\n * @class HasMany\n */\nfunction HasMany(definition, modelInstance) {\n  if (!(this instanceof HasMany)) {\n    return new HasMany(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.hasMany);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(HasMany, Relation);\n\nHasMany.prototype.removeFromCache = function(id) {\n  var cache = this.modelInstance.__cachedRelations[this.definition.name];\n  var idName = this.definition.modelTo.definition.idName();\n  if (Array.isArray(cache)) {\n    for (var i = 0, n = cache.length; i < n; i++) {\n      if (idEquals(cache[i][idName], id)) {\n        return cache.splice(i, 1);\n      }\n    }\n  }\n  return null;\n};\n\nHasMany.prototype.addToCache = function(inst) {\n  if (!inst) {\n    return;\n  }\n  var cache = this.modelInstance.__cachedRelations[this.definition.name];\n  if (cache === undefined) {\n    cache = this.modelInstance.__cachedRelations[this.definition.name] = [];\n  }\n  var idName = this.definition.modelTo.definition.idName();\n  if (Array.isArray(cache)) {\n    for (var i = 0, n = cache.length; i < n; i++) {\n      if (idEquals(cache[i][idName], inst[idName])) {\n        cache[i] = inst;\n        return;\n      }\n    }\n    cache.push(inst);\n  }\n};\n\n/**\n * HasManyThrough subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {HasManyThrough}\n * @constructor\n * @class HasManyThrough\n */\nfunction HasManyThrough(definition, modelInstance) {\n  if (!(this instanceof HasManyThrough)) {\n    return new HasManyThrough(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.hasMany);\n  assert(definition.modelThrough);\n  HasMany.apply(this, arguments);\n}\n\nutil.inherits(HasManyThrough, HasMany);\n\n/**\n * BelongsTo subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {BelongsTo}\n * @constructor\n * @class BelongsTo\n */\nfunction BelongsTo(definition, modelInstance) {\n  if (!(this instanceof BelongsTo)) {\n    return new BelongsTo(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.belongsTo);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(BelongsTo, Relation);\n\n/**\n * HasAndBelongsToMany subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {HasAndBelongsToMany}\n * @constructor\n * @class HasAndBelongsToMany\n */\nfunction HasAndBelongsToMany(definition, modelInstance) {\n  if (!(this instanceof HasAndBelongsToMany)) {\n    return new HasAndBelongsToMany(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.hasAndBelongsToMany);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(HasAndBelongsToMany, Relation);\n\n/**\n * HasOne subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {HasOne}\n * @constructor\n * @class HasOne\n */\nfunction HasOne(definition, modelInstance) {\n  if (!(this instanceof HasOne)) {\n    return new HasOne(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.hasOne);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(HasOne, Relation);\n\n/**\n * EmbedsOne subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {EmbedsOne}\n * @constructor\n * @class EmbedsOne\n */\nfunction EmbedsOne(definition, modelInstance) {\n  if (!(this instanceof EmbedsOne)) {\n    return new EmbedsOne(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.embedsOne);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(EmbedsOne, Relation);\n\n/**\n * EmbedsMany subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {EmbedsMany}\n * @constructor\n * @class EmbedsMany\n */\nfunction EmbedsMany(definition, modelInstance) {\n  if (!(this instanceof EmbedsMany)) {\n    return new EmbedsMany(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.embedsMany);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(EmbedsMany, Relation);\n\n/**\n * ReferencesMany subclass\n * @param {RelationDefinition|Object} definition\n * @param {Object} modelInstance\n * @returns {ReferencesMany}\n * @constructor\n * @class ReferencesMany\n */\nfunction ReferencesMany(definition, modelInstance) {\n  if (!(this instanceof ReferencesMany)) {\n    return new ReferencesMany(definition, modelInstance);\n  }\n  assert(definition.type === RelationTypes.referencesMany);\n  Relation.apply(this, arguments);\n}\n\nutil.inherits(ReferencesMany, Relation);\n\n/*!\n * Find the relation by foreign key\n * @param {*} foreignKey The foreign key\n * @returns {Array} The array of matching relation objects\n */\nfunction findBelongsTo(modelFrom, modelTo, keyTo) {\n  return Object.keys(modelFrom.relations)\n    .map(function(k) { return modelFrom.relations[k]; })\n    .filter(function(rel) {\n      return (rel.type === RelationTypes.belongsTo &&\n              rel.modelTo === modelTo &&\n              (keyTo === undefined || rel.keyTo === keyTo));\n    })\n    .map(function(rel) {\n      return rel.keyFrom;\n    });\n}\n\n/*!\n * Look up a model by name from the list of given models\n * @param {Object} models Models keyed by name\n * @param {String} modelName The model name\n * @returns {*} The matching model class\n */\nfunction lookupModel(models, modelName) {\n  if (models[modelName]) {\n    return models[modelName];\n  }\n  var lookupClassName = modelName.toLowerCase();\n  for (var name in models) {\n    if (name.toLowerCase() === lookupClassName) {\n      return models[name];\n    }\n  }\n}\n\nfunction lookupModelTo(modelFrom, modelTo, params, singularize) {\n  if ('string' === typeof modelTo) {\n    var modelToName;\n    params.as = params.as || modelTo;\n    modelTo = params.model || modelTo;\n    if (typeof modelTo === 'string') {\n      modelToName = (singularize ? i8n.singularize(modelTo) : modelTo).toLowerCase();\n      modelTo = lookupModel(modelFrom.dataSource.modelBuilder.models, modelToName) || modelTo;\n    }\n    if (typeof modelTo === 'string') {\n      modelToName = (singularize ? i8n.singularize(params.as) : params.as).toLowerCase();\n      modelTo = lookupModel(modelFrom.dataSource.modelBuilder.models, modelToName) || modelTo;\n    }\n    if (typeof modelTo !== 'function') {\n      throw new Error(g.f('Could not find \"%s\" relation for %s', params.as, modelFrom.modelName));\n    }\n  }\n  return modelTo;\n}\n\n/*!\n * Normalize polymorphic parameters\n * @param {Object|String} params Name of the polymorphic relation or params\n * @returns {Object} The normalized parameters\n */\nfunction polymorphicParams(params, as) {\n  if (typeof params === 'string') params = {as: params};\n  if (typeof params.as !== 'string') params.as = as || 'reference'; // default\n  params.foreignKey = params.foreignKey || i8n.camelize(params.as + '_id', true);\n  params.discriminator = params.discriminator || i8n.camelize(params.as + '_type', true);\n  return params;\n}\n\n/**\n * Define a \"one to many\" relationship by specifying the model name\n *\n * Examples:\n * ```\n * User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});\n * ```\n *\n * ```\n * Book.hasMany(Chapter);\n * ```\n * Or, equivalently:\n * ```\n * Book.hasMany('chapters', {model: Chapter});\n * ```\n * @param {Model} modelFrom Source model class\n * @param {Object|String} modelTo Model object (or String name of model) to which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationDefinition.hasMany = function hasMany(modelFrom, modelTo, params) {\n  var thisClassName = modelFrom.modelName;\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params, true);\n\n  var relationName = params.as || i8n.camelize(modelTo.pluralModelName, true);\n  var fk = params.foreignKey || i8n.camelize(thisClassName + '_id', true);\n  var keyThrough = params.keyThrough || i8n.camelize(modelTo.modelName + '_id', true);\n\n  var pkName = params.primaryKey || modelFrom.dataSource.idName(modelFrom.modelName) || 'id';\n  var discriminator, polymorphic;\n\n  if (params.polymorphic) {\n    polymorphic = polymorphicParams(params.polymorphic);\n    if (params.invert) {\n      polymorphic.invert = true;\n      keyThrough = polymorphic.foreignKey;\n    }\n    discriminator = polymorphic.discriminator;\n    if (!params.invert) {\n      fk = polymorphic.foreignKey;\n    }\n    if (!params.through) {\n      modelTo.dataSource.defineProperty(modelTo.modelName, discriminator, {type: 'string', index: true});\n    }\n  }\n\n  var definition = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.hasMany,\n    modelFrom: modelFrom,\n    keyFrom: pkName,\n    keyTo: fk,\n    modelTo: modelTo,\n    multiple: true,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n    keyThrough: keyThrough,\n    polymorphic: polymorphic,\n  });\n\n  definition.modelThrough = params.through;\n\n  modelFrom.relations[relationName] = definition;\n\n  if (!params.through) {\n    // obviously, modelTo should have attribute called `fk`\n    // for polymorphic relations, it is assumed to share the same fk type for all\n    // polymorphic models\n    modelTo.dataSource.defineForeignKey(modelTo.modelName, fk, modelFrom.modelName, pkName);\n  }\n\n  var scopeMethods = {\n    findById: scopeMethod(definition, 'findById'),\n    destroy: scopeMethod(definition, 'destroyById'),\n    updateById: scopeMethod(definition, 'updateById'),\n    exists: scopeMethod(definition, 'exists'),\n  };\n\n  var findByIdFunc = scopeMethods.findById;\n  modelFrom.prototype['__findById__' + relationName] = findByIdFunc;\n\n  var destroyByIdFunc = scopeMethods.destroy;\n  modelFrom.prototype['__destroyById__' + relationName] = destroyByIdFunc;\n\n  var updateByIdFunc = scopeMethods.updateById;\n  modelFrom.prototype['__updateById__' + relationName] = updateByIdFunc;\n\n  var existsByIdFunc = scopeMethods.exists;\n  modelFrom.prototype['__exists__' + relationName] = existsByIdFunc;\n\n  if (definition.modelThrough) {\n    scopeMethods.create = scopeMethod(definition, 'create');\n    scopeMethods.add = scopeMethod(definition, 'add');\n    scopeMethods.remove = scopeMethod(definition, 'remove');\n\n    var addFunc = scopeMethods.add;\n    modelFrom.prototype['__link__' + relationName] = addFunc;\n\n    var removeFunc = scopeMethods.remove;\n    modelFrom.prototype['__unlink__' + relationName] = removeFunc;\n  } else {\n    scopeMethods.create = scopeMethod(definition, 'create');\n    scopeMethods.build = scopeMethod(definition, 'build');\n  }\n\n  var customMethods = extendScopeMethods(definition, scopeMethods, params.scopeMethods);\n\n  for (var i = 0; i < customMethods.length; i++) {\n    var methodName = customMethods[i];\n    var method = scopeMethods[methodName];\n    if (typeof method === 'function' && method.shared === true) {\n      modelFrom.prototype['__' + methodName + '__' + relationName] = method;\n    }\n  };\n\n  // Mix the property and scoped methods into the prototype class\n  defineScope(modelFrom.prototype, params.through || modelTo, relationName, function() {\n    var filter = {};\n    filter.where = {};\n    filter.where[fk] = this[pkName];\n\n    definition.applyScope(this, filter);\n\n    if (definition.modelThrough) {\n      var throughRelationName;\n\n      // find corresponding belongsTo relations from through model as collect\n      for (var r in definition.modelThrough.relations) {\n        var relation = definition.modelThrough.relations[r];\n\n        // should be a belongsTo and match modelTo and keyThrough\n        // if relation is polymorphic then check keyThrough only\n        if (relation.type === RelationTypes.belongsTo &&\n          (relation.polymorphic && !relation.modelTo || relation.modelTo === definition.modelTo) &&\n          (relation.keyFrom === definition.keyThrough)\n          ) {\n          throughRelationName = relation.name;\n          break;\n        }\n      }\n\n      if (definition.polymorphic && definition.polymorphic.invert) {\n        filter.collect = definition.polymorphic.as;\n        filter.include = filter.collect;\n      } else {\n        filter.collect = throughRelationName || i8n.camelize(modelTo.modelName, true);\n        filter.include = filter.collect;\n      }\n    }\n\n    return filter;\n  }, scopeMethods, definition.options);\n\n  return definition;\n};\n\nfunction scopeMethod(definition, methodName) {\n  var relationClass = RelationClasses[definition.type];\n  if (definition.type === RelationTypes.hasMany && definition.modelThrough) {\n    relationClass = RelationClasses.hasManyThrough;\n  }\n  var method = function() {\n    var relation = new relationClass(definition, this);\n    return relation[methodName].apply(relation, arguments);\n  };\n\n  var relationMethod = relationClass.prototype[methodName];\n  if (relationMethod.shared) {\n    sharedMethod(definition, methodName, method, relationMethod);\n  }\n  return method;\n}\n\nfunction sharedMethod(definition, methodName, method, relationMethod) {\n  method.shared = true;\n  method.accepts = relationMethod.accepts;\n  method.returns = relationMethod.returns;\n  method.http = relationMethod.http;\n  method.description = relationMethod.description;\n}\n\n/**\n * Find a related item by foreign key\n * @param {*} fkId The foreign key\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasMany.prototype.findById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var modelTo = this.definition.modelTo;\n  var modelFrom = this.definition.modelFrom;\n  var fk = this.definition.keyTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  var idName = this.definition.modelTo.definition.idName();\n  var filter = {};\n  filter.where = {};\n  filter.where[idName] = fkId;\n  filter.where[fk] = modelInstance[pk];\n\n  cb = cb || utils.createPromiseCallback();\n\n  if (filter.where[fk] === undefined) {\n    // Foreign key is undefined\n    process.nextTick(cb);\n    return cb.promise;\n  }\n  this.definition.applyScope(modelInstance, filter);\n\n  modelTo.findOne(filter, options, function(err, inst) {\n    if (err) {\n      return cb(err);\n    }\n    if (!inst) {\n      err = new Error(g.f('No instance with {{id}} %s found for %s', fkId, modelTo.modelName));\n      err.statusCode = 404;\n      return cb(err);\n    }\n    // Check if the foreign key matches the primary key\n    if (inst[fk] != null && idEquals(inst[fk], modelInstance[pk])) {\n      cb(null, inst);\n    } else {\n      err = new Error(g.f('Key mismatch: %s.%s: %s, %s.%s: %s',\n        modelFrom.modelName, pk, modelInstance[pk], modelTo.modelName, fk, inst[fk]));\n      err.statusCode = 400;\n      cb(err);\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Find a related item by foreign key\n * @param {*} fkId The foreign key\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasMany.prototype.exists = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var fk = this.definition.keyTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n  cb = cb || utils.createPromiseCallback();\n\n  this.findById(fkId, function(err, inst) {\n    if (err) {\n      return cb(err);\n    }\n    if (!inst) {\n      return cb(null, false);\n    }\n    // Check if the foreign key matches the primary key\n    if (inst[fk] && inst[fk].toString() === modelInstance[pk].toString()) {\n      cb(null, true);\n    } else {\n      cb(null, false);\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Update a related item by foreign key\n * @param {*} fkId The foreign key\n * @param {Object} Changes to the data\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasMany.prototype.updateById = function(fkId, data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  this.findById(fkId, options, function(err, inst) {\n    if (err) {\n      return cb && cb(err);\n    }\n    inst.updateAttributes(data, options, cb);\n  });\n  return cb.promise;\n};\n\n/**\n * Delete a related item by foreign key\n * @param {*} fkId The foreign key\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasMany.prototype.destroyById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  var self = this;\n  this.findById(fkId, options, function(err, inst) {\n    if (err) {\n      return cb(err);\n    }\n    self.removeFromCache(fkId);\n    inst.destroy(options, cb);\n  });\n  return cb.promise;\n};\n\nvar throughKeys = function(definition) {\n  var modelThrough = definition.modelThrough;\n  var pk2 = definition.modelTo.definition.idName();\n\n  let fk1, fk2;\n  if (typeof definition.polymorphic === 'object') { // polymorphic\n    fk1 = definition.keyTo;\n    if (definition.polymorphic.invert) {\n      fk2 = definition.polymorphic.foreignKey;\n    } else {\n      fk2 = definition.keyThrough;\n    }\n  } else if (definition.modelFrom === definition.modelTo) {\n    return findBelongsTo(modelThrough, definition.modelTo, pk2).\n      sort(function(fk1, fk2) {\n        // Fix for bug - https://github.com/strongloop/loopback-datasource-juggler/issues/571\n        // Make sure that first key is mapped to modelFrom\n        // & second key to modelTo. Order matters\n        return (definition.keyTo === fk1) ? -1 : 1;\n      });\n  } else {\n    fk1 = findBelongsTo(modelThrough, definition.modelFrom,\n                            definition.keyFrom)[0];\n    fk2 = findBelongsTo(modelThrough, definition.modelTo, pk2)[0];\n  }\n  return [fk1, fk2];\n};\n\n/**\n * Find a related item by foreign key\n * @param {*} fkId The foreign key value\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasManyThrough.prototype.findById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n  var modelThrough = this.definition.modelThrough;\n\n  cb = cb || utils.createPromiseCallback();\n\n  self.exists(fkId, options, function(err, exists) {\n    if (err || !exists) {\n      if (!err) {\n        err = new Error(g.f('No relation found in %s' +\n          ' for (%s.%s,%s.%s)',\n          modelThrough.modelName, self.definition.modelFrom.modelName,\n          modelInstance[pk], modelTo.modelName, fkId));\n        err.statusCode = 404;\n      }\n      return cb(err);\n    }\n    modelTo.findById(fkId, options, function(err, inst) {\n      if (err) {\n        return cb(err);\n      }\n      if (!inst) {\n        err = new Error(g.f('No instance with id %s found for %s', fkId, modelTo.modelName));\n        err.statusCode = 404;\n        return cb(err);\n      }\n      cb(err, inst);\n    });\n  });\n  return cb.promise;\n};\n\n/**\n * Delete a related item by foreign key\n * @param {*} fkId The foreign key\n * @param {Object} [options] Options\n * @param {Function} cb The callback function\n */\nHasManyThrough.prototype.destroyById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n  var modelThrough = this.definition.modelThrough;\n\n  cb = cb || utils.createPromiseCallback();\n\n  self.exists(fkId, options, function(err, exists) {\n    if (err || !exists) {\n      if (!err) {\n        err = new Error(g.f('No record found in %s for (%s.%s ,%s.%s)',\n          modelThrough.modelName, self.definition.modelFrom.modelName,\n          modelInstance[pk], modelTo.modelName, fkId));\n        err.statusCode = 404;\n      }\n      return cb(err);\n    }\n    self.remove(fkId, options, function(err) {\n      if (err) {\n        return cb(err);\n      }\n      modelTo.deleteById(fkId, options, cb);\n    });\n  });\n  return cb.promise;\n};\n\n// Create an instance of the target model and connect it to the instance of\n// the source model by creating an instance of the through model\nHasManyThrough.prototype.create = function create(data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var definition = this.definition;\n  var modelTo = definition.modelTo;\n  var modelThrough = definition.modelThrough;\n\n  if (typeof data === 'function' && !cb) {\n    cb = data;\n    data = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n\n  var modelInstance = this.modelInstance;\n\n  // First create the target model\n  modelTo.create(data, options, function(err, to) {\n    if (err) {\n      return cb(err, to);\n    }\n    // The primary key for the target model\n    var pk2 = definition.modelTo.definition.idName();\n    var keys = throughKeys(definition);\n    var fk1 = keys[0];\n    var fk2 = keys[1];\n\n    function createRelation(to, next) {\n      var d = {}, q = {}, filter = {where: q};\n      d[fk1] = q[fk1] = modelInstance[definition.keyFrom];\n      d[fk2] = q[fk2] = to[pk2];\n      definition.applyProperties(modelInstance, d);\n      definition.applyScope(modelInstance, filter);\n\n      // Then create the through model\n      modelThrough.findOrCreate(filter, d, options, function(e, through) {\n        if (e) {\n          // Undo creation of the target model\n          to.destroy(options, function() {\n            next(e);\n          });\n        } else {\n          self.addToCache(to);\n          next(err, to);\n        }\n      });\n    }\n\n    // process array or single item\n    if (!Array.isArray(to))\n      createRelation(to, cb);\n    else\n      async.map(to, createRelation, cb);\n  });\n  return cb.promise;\n};\n\n/**\n * Add the target model instance to the 'hasMany' relation\n * @param {Object|ID} acInst The actual instance or id value\n * @param {Object} [data] Optional data object for the through model to be created\n * @param {Object} [options] Options\n * @param {Function} [cb] Callback function\n */\nHasManyThrough.prototype.add = function(acInst, data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var definition = this.definition;\n  var modelThrough = definition.modelThrough;\n  var pk1 = definition.keyFrom;\n\n  if (typeof data === 'function') {\n    cb = data;\n    data = {};\n  }\n  var query = {};\n\n  data = data || {};\n  cb = cb || utils.createPromiseCallback();\n\n  // The primary key for the target model\n  var pk2 = definition.modelTo.definition.idName();\n\n  var keys = throughKeys(definition);\n  var fk1 = keys[0];\n  var fk2 = keys[1];\n\n  query[fk1] = this.modelInstance[pk1];\n  query[fk2] = (acInst instanceof definition.modelTo) ? acInst[pk2] : acInst;\n\n  var filter = {where: query};\n\n  definition.applyScope(this.modelInstance, filter);\n\n  data[fk1] = this.modelInstance[pk1];\n  data[fk2] = (acInst instanceof definition.modelTo) ? acInst[pk2] : acInst;\n\n  definition.applyProperties(this.modelInstance, data);\n\n  // Create an instance of the through model\n  modelThrough.findOrCreate(filter, data, options, function(err, ac) {\n    if (!err) {\n      if (acInst instanceof definition.modelTo) {\n        self.addToCache(acInst);\n      }\n    }\n    cb(err, ac);\n  });\n  return cb.promise;\n};\n\n/**\n * Check if the target model instance is related to the 'hasMany' relation\n * @param {Object|ID} acInst The actual instance or id value\n */\nHasManyThrough.prototype.exists = function(acInst, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var definition = this.definition;\n  var modelThrough = definition.modelThrough;\n  var pk1 = definition.keyFrom;\n\n  var query = {};\n\n  // The primary key for the target model\n  var pk2 = definition.modelTo.definition.idName();\n\n  var keys = throughKeys(definition);\n  var fk1 = keys[0];\n  var fk2 = keys[1];\n\n  query[fk1] = this.modelInstance[pk1];\n  query[fk2] = (acInst instanceof definition.modelTo) ? acInst[pk2] : acInst;\n\n  var filter = {where: query};\n\n  definition.applyScope(this.modelInstance, filter);\n\n  cb = cb || utils.createPromiseCallback();\n\n  modelThrough.count(filter.where, options, function(err, ac) {\n    cb(err, ac > 0);\n  });\n  return cb.promise;\n};\n\n/**\n * Remove the target model instance from the 'hasMany' relation\n * @param {Object|ID) acInst The actual instance or id value\n */\nHasManyThrough.prototype.remove = function(acInst, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var definition = this.definition;\n  var modelThrough = definition.modelThrough;\n  var pk1 = definition.keyFrom;\n\n  var query = {};\n\n  // The primary key for the target model\n  var pk2 = definition.modelTo.definition.idName();\n\n  var keys = throughKeys(definition);\n  var fk1 = keys[0];\n  var fk2 = keys[1];\n\n  query[fk1] = this.modelInstance[pk1];\n  query[fk2] = (acInst instanceof definition.modelTo) ? acInst[pk2] : acInst;\n\n  var filter = {where: query};\n\n  definition.applyScope(this.modelInstance, filter);\n\n  cb = cb || utils.createPromiseCallback();\n\n  modelThrough.deleteAll(filter.where, options, function(err) {\n    if (!err) {\n      self.removeFromCache(query[fk2]);\n    }\n    cb(err);\n  });\n  return cb.promise;\n};\n\n/**\n * Declare \"belongsTo\" relation that sets up a one-to-one connection with\n * another model, such that each instance of the declaring model \"belongs to\"\n * one instance of the other model.\n *\n * For example, if an application includes users and posts, and each post can\n * be written by exactly one user. The following code specifies that `Post` has\n * a reference called `author` to the `User` model via the `userId` property of\n * `Post` as the foreign key.\n * ```\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n * ```\n *\n * This optional parameter default value is false, so the related object will\n * be loaded from cache if available.\n *\n * @param {Class|String} modelTo Model object (or String name of model) to\n * which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n * corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Name of foreign key property.\n *\n */\nRelationDefinition.belongsTo = function(modelFrom, modelTo, params) {\n  var discriminator, polymorphic;\n  params = params || {};\n  if ('string' === typeof modelTo && !params.polymorphic) {\n    modelTo = lookupModelTo(modelFrom, modelTo, params);\n  }\n\n  var pkName, relationName, fk;\n  if (params.polymorphic) {\n    relationName = params.as || (typeof modelTo === 'string' ? modelTo : null); // initially\n\n    if (params.polymorphic === true) {\n      // modelTo arg will be the name of the polymorphic relation (string)\n      polymorphic = polymorphicParams(modelTo, relationName);\n    } else {\n      polymorphic = polymorphicParams(params.polymorphic, relationName);\n    }\n\n    modelTo = null; // will lookup dynamically\n\n    pkName = params.primaryKey || params.idName || 'id';\n    relationName = params.as || polymorphic.as; // finally\n    fk = polymorphic.foreignKey;\n    discriminator = polymorphic.discriminator;\n\n    if (polymorphic.idType) { // explicit key type\n      modelFrom.dataSource.defineProperty(modelFrom.modelName, fk, {type: polymorphic.idType, index: true});\n    } else { // try to use the same foreign key type as modelFrom\n      modelFrom.dataSource.defineForeignKey(modelFrom.modelName, fk, modelFrom.modelName, pkName);\n    }\n\n    modelFrom.dataSource.defineProperty(modelFrom.modelName, discriminator, {type: 'string', index: true});\n  } else {\n    pkName = params.primaryKey || modelTo.dataSource.idName(modelTo.modelName) || 'id';\n    relationName = params.as || i8n.camelize(modelTo.modelName, true);\n    fk = params.foreignKey || relationName + 'Id';\n\n    modelFrom.dataSource.defineForeignKey(modelFrom.modelName, fk, modelTo.modelName, pkName);\n  }\n\n  var definition = modelFrom.relations[relationName] = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.belongsTo,\n    modelFrom: modelFrom,\n    keyFrom: fk,\n    keyTo: pkName,\n    modelTo: modelTo,\n    multiple: false,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n    polymorphic: polymorphic,\n    methods: params.methods,\n  });\n\n  // Define a property for the scope so that we have 'this' for the scoped methods\n  Object.defineProperty(modelFrom.prototype, relationName, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      var relation = new BelongsTo(definition, this);\n      var relationMethod = relation.related.bind(relation);\n      relationMethod.getAsync = relation.getAsync.bind(relation);\n      relationMethod.update = relation.update.bind(relation);\n      relationMethod.destroy = relation.destroy.bind(relation);\n      if (!polymorphic) {\n        relationMethod.create = relation.create.bind(relation);\n        relationMethod.build = relation.build.bind(relation);\n        relationMethod._targetClass = definition.modelTo.modelName;\n      }\n      bindRelationMethods(relation, relationMethod, definition);\n      return relationMethod;\n    },\n  });\n\n  // FIXME: [rfeng] Wrap the property into a function for remoting\n  // so that it can be accessed as /api/<model>/<id>/<belongsToRelationName>\n  // For example, /api/orders/1/customer\n  var fn = function() {\n    var f = this[relationName];\n    f.apply(this, arguments);\n  };\n  modelFrom.prototype['__get__' + relationName] = fn;\n\n  return definition;\n};\n\nBelongsTo.prototype.create = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var fk = this.definition.keyFrom;\n  var pk = this.definition.keyTo;\n  var modelInstance = this.modelInstance;\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n\n  this.definition.applyProperties(modelInstance, targetModelData || {});\n\n  modelTo.create(targetModelData, options, function(err, targetModel) {\n    if (!err) {\n      modelInstance[fk] = targetModel[pk];\n      if (modelInstance.isNewRecord()) {\n        self.resetCache(targetModel);\n        cb && cb(err, targetModel);\n      } else {\n        modelInstance.save(options, function(err, inst) {\n          if (cb && err) return cb && cb(err);\n          self.resetCache(targetModel);\n          cb && cb(err, targetModel);\n        });\n      }\n    } else {\n      cb && cb(err);\n    }\n  });\n  return cb.promise;\n};\n\nBelongsTo.prototype.build = function(targetModelData) {\n  var modelTo = this.definition.modelTo;\n  this.definition.applyProperties(this.modelInstance, targetModelData || {});\n  return new modelTo(targetModelData);\n};\n\nBelongsTo.prototype.update = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  var definition = this.definition;\n  this.fetch(options, function(err, inst) {\n    if (inst instanceof ModelBaseClass) {\n      inst.updateAttributes(targetModelData, options, cb);\n    } else {\n      cb(new Error(g.f('{{BelongsTo}} relation %s is empty', definition.name)));\n    }\n  });\n  return cb.promise;\n};\n\nBelongsTo.prototype.destroy = function(options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n\n  var definition = this.definition;\n  var modelInstance = this.modelInstance;\n  var fk = definition.keyFrom;\n\n  cb = cb || utils.createPromiseCallback();\n\n  this.fetch(options, function(err, targetModel) {\n    if (targetModel instanceof ModelBaseClass) {\n      modelInstance[fk] = null;\n      modelInstance.save(options, function(err, targetModel) {\n        if (cb && err) return cb && cb(err);\n        cb && cb(err, targetModel);\n      });\n    } else {\n      cb(new Error(g.f('{{BelongsTo}} relation %s is empty', definition.name)));\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Define the method for the belongsTo relation itself\n * It will support one of the following styles:\n * - order.customer(refresh, options, callback): Load the target model instance asynchronously\n * - order.customer(customer): Synchronous setter of the target model instance\n * - order.customer(): Synchronous getter of the target model instance\n *\n * @param refresh\n * @param params\n * @returns {*}\n */\nBelongsTo.prototype.related = function(condOrRefresh, options, cb) {\n  var self = this;\n  var modelFrom = this.definition.modelFrom;\n  var modelTo = this.definition.modelTo;\n  var pk = this.definition.keyTo;\n  var fk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n  var discriminator;\n  var scopeQuery = null;\n  var newValue;\n\n  if ((condOrRefresh instanceof ModelBaseClass) &&\n    options === undefined && cb === undefined) {\n    // order.customer(customer)\n    newValue = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // order.customer(cb)\n    cb = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof options === 'function' && cb === undefined) {\n    // order.customer(condOrRefresh, cb)\n    cb = options;\n    options = {};\n  }\n  if (!newValue) {\n    scopeQuery = condOrRefresh;\n  }\n\n  if (typeof this.definition.polymorphic === 'object') {\n    discriminator = this.definition.polymorphic.discriminator;\n  }\n\n  var cachedValue;\n  if (!condOrRefresh) {\n    cachedValue = self.getCache();\n  }\n  if (newValue) { // acts as setter\n    modelInstance[fk] = newValue[pk];\n\n    if (discriminator) {\n      modelInstance[discriminator] = newValue.constructor.modelName;\n    }\n\n    this.definition.applyProperties(modelInstance, newValue);\n\n    self.resetCache(newValue);\n  } else if (typeof cb === 'function') { // acts as async getter\n    if (discriminator) {\n      var modelToName = modelInstance[discriminator];\n      if (typeof modelToName !== 'string') {\n        throw new Error(g.f('{{Polymorphic}} model not found: `%s` not set', discriminator));\n      }\n      modelToName = modelToName.toLowerCase();\n      modelTo = lookupModel(modelFrom.dataSource.modelBuilder.models, modelToName);\n      if (!modelTo) {\n        throw new Error(g.f('{{Polymorphic}} model not found: `%s`', modelToName));\n      }\n    }\n\n    if (cachedValue === undefined || !(cachedValue instanceof ModelBaseClass)) {\n      var query = {where: {}};\n      query.where[pk] = modelInstance[fk];\n\n      if (query.where[pk] === undefined || query.where[pk] === null) {\n        // Foreign key is undefined\n        return process.nextTick(cb);\n      }\n\n      this.definition.applyScope(modelInstance, query);\n\n      if (scopeQuery) mergeQuery(query, scopeQuery);\n\n      if (Array.isArray(query.fields) && query.fields.indexOf(pk) === -1) {\n        query.fields.push(pk); // always include the pk\n      }\n\n      modelTo.findOne(query, options, function(err, inst) {\n        if (err) {\n          return cb(err);\n        }\n        if (!inst) {\n          return cb(null, null);\n        }\n        // Check if the foreign key matches the primary key\n        if (inst[pk] != null && modelInstance[fk] != null &&\n            inst[pk].toString() === modelInstance[fk].toString()) {\n          self.resetCache(inst);\n          cb(null, inst);\n        } else {\n          err = new Error(g.f('Key mismatch: %s.%s: %s, %s.%s: %s',\n            self.definition.modelFrom.modelName, fk, modelInstance[fk],\n            modelTo.modelName, pk, inst[pk]));\n          err.statusCode = 400;\n          cb(err);\n        }\n      });\n      return modelInstance[fk];\n    } else {\n      cb(null, cachedValue);\n      return cachedValue;\n    }\n  } else if (condOrRefresh === undefined) { // acts as sync getter\n    return cachedValue;\n  } else { // setter\n    modelInstance[fk] = newValue;\n    self.resetCache();\n  }\n};\n\n/**\n * Define a Promise-based method for the belongsTo relation itself\n * - order.customer.get(cb): Load the target model instance asynchronously\n *\n * @param {Function} cb Callback of the form function (err, inst)\n * @returns {Promise | Undefined} returns promise if callback is omitted\n */\nBelongsTo.prototype.getAsync = function(options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.customer.getAsync(cb)\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  this.related(true, options, cb);\n  return cb.promise;\n};\n\n/**\n * A hasAndBelongsToMany relation creates a direct many-to-many connection with\n * another model, with no intervening model. For example, if your application\n * includes users and groups, with each group having many users and each user\n * appearing in many groups, you could declare the models this way:\n * ```\n *  User.hasAndBelongsToMany('groups', {model: Group, foreignKey: 'groupId'});\n * ```\n *\n * @param {String|Object} modelTo Model object (or String name of model) to\n * which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n * corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationDefinition.hasAndBelongsToMany = function hasAndBelongsToMany(modelFrom, modelTo, params) {\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params, true);\n\n  var models = modelFrom.dataSource.modelBuilder.models;\n\n  if (!params.through) {\n    if (params.polymorphic) throw new Error(g.f('{{Polymorphic}} relations need a through model'));\n\n    if (params.throughTable) {\n      params.through = modelFrom.dataSource.define(params.throughTable);\n    } else {\n      var name1 = modelFrom.modelName + modelTo.modelName;\n      var name2 = modelTo.modelName + modelFrom.modelName;\n      params.through = lookupModel(models, name1) || lookupModel(models, name2) ||\n        modelFrom.dataSource.define(name1);\n    }\n  }\n\n  var options = {as: params.as, through: params.through};\n  options.properties = params.properties;\n  options.scope = params.scope;\n\n  // Forward relation options like \"disableInclude\"\n  options.options = params.options;\n\n  if (params.polymorphic) {\n    var polymorphic = polymorphicParams(params.polymorphic);\n    options.polymorphic = polymorphic; // pass through\n    var accessor = params.through.prototype[polymorphic.as];\n    if (typeof accessor !== 'function') { // declare once\n      // use the name of the polymorphic rel, not modelTo\n      params.through.belongsTo(polymorphic.as, {polymorphic: true});\n    }\n  } else {\n    params.through.belongsTo(modelFrom);\n  }\n\n  params.through.belongsTo(modelTo);\n\n  return this.hasMany(modelFrom, modelTo, options);\n};\n\n/**\n * A HasOne relation creates a one-to-one connection from modelFrom to modelTo.\n * This relation indicates that each instance of a model contains or possesses\n * one instance of another model. For example, each supplier in your application\n * has only one account.\n *\n * @param {Function} modelFrom The declaring model class\n * @param {String|Function} modelTo Model object (or String name of model) to\n * which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n * corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationDefinition.hasOne = function(modelFrom, modelTo, params) {\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params);\n\n  var pk = params.primaryKey || modelFrom.dataSource.idName(modelFrom.modelName) || 'id';\n  var relationName = params.as || i8n.camelize(modelTo.modelName, true);\n\n  var fk = params.foreignKey || i8n.camelize(modelFrom.modelName + '_id', true);\n  var discriminator, polymorphic;\n\n  if (params.polymorphic) {\n    polymorphic = polymorphicParams(params.polymorphic);\n    fk = polymorphic.foreignKey;\n    discriminator = polymorphic.discriminator;\n    if (!params.through) {\n      modelTo.dataSource.defineProperty(modelTo.modelName, discriminator, {type: 'string', index: true});\n    }\n  }\n\n  var definition = modelFrom.relations[relationName] = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.hasOne,\n    modelFrom: modelFrom,\n    keyFrom: pk,\n    keyTo: fk,\n    modelTo: modelTo,\n    multiple: false,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n    polymorphic: polymorphic,\n    methods: params.methods,\n  });\n\n  modelTo.dataSource.defineForeignKey(modelTo.modelName, fk, modelFrom.modelName, pk);\n\n  // Define a property for the scope so that we have 'this' for the scoped methods\n  Object.defineProperty(modelFrom.prototype, relationName, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      var relation = new HasOne(definition, this);\n      var relationMethod = relation.related.bind(relation);\n      relationMethod.getAsync = relation.getAsync.bind(relation);\n      relationMethod.create = relation.create.bind(relation);\n      relationMethod.build = relation.build.bind(relation);\n      relationMethod.update = relation.update.bind(relation);\n      relationMethod.destroy = relation.destroy.bind(relation);\n      relationMethod._targetClass = definition.modelTo.modelName;\n      bindRelationMethods(relation, relationMethod, definition);\n      return relationMethod;\n    },\n  });\n\n  // FIXME: [rfeng] Wrap the property into a function for remoting\n  // so that it can be accessed as /api/<model>/<id>/<hasOneRelationName>\n  // For example, /api/orders/1/customer\n  modelFrom.prototype['__get__' + relationName] = function() {\n    var f = this[relationName];\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__create__' + relationName] = function() {\n    var f = this[relationName].create;\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__update__' + relationName] = function() {\n    var f = this[relationName].update;\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__destroy__' + relationName] = function() {\n    var f = this[relationName].destroy;\n    f.apply(this, arguments);\n  };\n\n  return definition;\n};\n\n/**\n * Create a target model instance\n * @param {Object} targetModelData The target model data\n * @callback {Function} [cb] Callback function\n * @param {String|Object} err Error string or object\n * @param {Object} The newly created target model instance\n */\nHasOne.prototype.create = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.profile.create(options, cb)\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var fk = this.definition.keyTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n  targetModelData = targetModelData || {};\n  cb = cb || utils.createPromiseCallback();\n\n  targetModelData[fk] = modelInstance[pk];\n  var query = {where: {}};\n  query.where[fk] = targetModelData[fk];\n\n  this.definition.applyScope(modelInstance, query);\n  this.definition.applyProperties(modelInstance, targetModelData);\n\n  modelTo.findOrCreate(query, targetModelData, options,\n    function(err, targetModel, created) {\n      if (err) {\n        return cb && cb(err);\n      }\n      if (created) {\n        // Refresh the cache\n        self.resetCache(targetModel);\n        cb && cb(err, targetModel);\n      } else {\n        cb && cb(new Error(g.f(\n          '{{HasOne}} relation cannot create more than one instance of %s',\n           modelTo.modelName)));\n      }\n    });\n  return cb.promise;\n};\n\nHasOne.prototype.update = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.profile.update(data, cb)\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  var definition = this.definition;\n  var fk = this.definition.keyTo;\n  this.fetch(function(err, targetModel) {\n    if (targetModel instanceof ModelBaseClass) {\n      delete targetModelData[fk];\n      targetModel.updateAttributes(targetModelData, options, cb);\n    } else {\n      cb(new Error(g.f('{{HasOne}} relation %s is empty', definition.name)));\n    }\n  });\n  return cb.promise;\n};\n\nHasOne.prototype.destroy = function(options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.profile.destroy(cb)\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  var definition = this.definition;\n  this.fetch(function(err, targetModel) {\n    if (targetModel instanceof ModelBaseClass) {\n      targetModel.destroy(options, cb);\n    } else {\n      cb(new Error(g.f('{{HasOne}} relation %s is empty', definition.name)));\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Create a target model instance\n * @param {Object} targetModelData The target model data\n * @callback {Function} [cb] Callback function\n * @param {String|Object} err Error string or object\n * @param {Object} The newly created target model instance\n */\nHasMany.prototype.create = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.create(data, cb)\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var fk = this.definition.keyTo;\n  var pk = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n  targetModelData = targetModelData || {};\n  cb = cb || utils.createPromiseCallback();\n\n  var fkAndProps = function(item) {\n    item[fk] = modelInstance[pk];\n    self.definition.applyProperties(modelInstance, item);\n  };\n\n  var apply = function(data, fn) {\n    if (Array.isArray(data)) {\n      data.forEach(fn);\n    } else {\n      fn(data);\n    }\n  };\n\n  apply(targetModelData, fkAndProps);\n\n  modelTo.create(targetModelData, options, function(err, targetModel) {\n    if (!err) {\n      // Refresh the cache\n      apply(targetModel, self.addToCache.bind(self));\n      cb && cb(err, targetModel);\n    } else {\n      cb && cb(err);\n    }\n  });\n  return cb.promise;\n};\n/**\n * Build a target model instance\n * @param {Object} targetModelData The target model data\n * @returns {Object} The newly built target model instance\n */\nHasMany.prototype.build = HasOne.prototype.build = function(targetModelData) {\n  var modelTo = this.definition.modelTo;\n  var pk = this.definition.keyFrom;\n  var fk = this.definition.keyTo;\n\n  targetModelData = targetModelData || {};\n  targetModelData[fk] = this.modelInstance[pk];\n\n  this.definition.applyProperties(this.modelInstance, targetModelData);\n\n  return new modelTo(targetModelData);\n};\n\n/**\n * Define the method for the hasOne relation itself\n * It will support one of the following styles:\n * - order.customer(refresh, callback): Load the target model instance asynchronously\n * - order.customer(customer): Synchronous setter of the target model instance\n * - order.customer(): Synchronous getter of the target model instance\n *\n * @param {Boolean} refresh Reload from the data source\n * @param {Object|Function} params Query parameters\n * @returns {Object}\n */\nHasOne.prototype.related = function(condOrRefresh, options, cb) {\n  var self = this;\n  var modelTo = this.definition.modelTo;\n  var fk = this.definition.keyTo;\n  var pk = this.definition.keyFrom;\n  var definition = this.definition;\n  var modelInstance = this.modelInstance;\n  var newValue;\n\n  if ((condOrRefresh instanceof ModelBaseClass) &&\n    options === undefined && cb === undefined) {\n    // order.customer(customer)\n    newValue = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.profile(cb)\n    cb = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof options === 'function' && cb === undefined) {\n    // customer.profile(condOrRefresh, cb)\n    cb = options;\n    options = {};\n  }\n\n  var cachedValue;\n  if (!condOrRefresh) {\n    cachedValue = self.getCache();\n  }\n  if (newValue) { // acts as setter\n    newValue[fk] = modelInstance[pk];\n    self.resetCache(newValue);\n  } else if (typeof cb === 'function') { // acts as async getter\n    if (cachedValue === undefined) {\n      var query = {where: {}};\n      query.where[fk] = modelInstance[pk];\n      definition.applyScope(modelInstance, query);\n      modelTo.findOne(query, options, function(err, inst) {\n        if (err) {\n          return cb(err);\n        }\n        if (!inst) {\n          return cb(null, null);\n        }\n        // Check if the foreign key matches the primary key\n        if (inst[fk] != null && modelInstance[pk] != null &&\n            inst[fk].toString() === modelInstance[pk].toString()) {\n          self.resetCache(inst);\n          cb(null, inst);\n        } else {\n          err = new Error(g.f('Key mismatch: %s.%s: %s, %s.%s: %s',\n            self.definition.modelFrom.modelName, pk, modelInstance[pk],\n            modelTo.modelName, fk, inst[fk]));\n          err.statusCode = 400;\n          cb(err);\n        }\n      });\n      return modelInstance[pk];\n    } else {\n      cb(null, cachedValue);\n      return cachedValue;\n    }\n  } else if (condOrRefresh === undefined) { // acts as sync getter\n    return cachedValue;\n  } else { // setter\n    newValue[fk] = modelInstance[pk];\n    self.resetCache();\n  }\n};\n\n/**\n * Define a Promise-based method for the hasOne relation itself\n * - order.customer.getAsync(cb): Load the target model instance asynchronously\n *\n * @param {Function} cb Callback of the form function (err, inst)\n * @returns {Promise | Undefined} Returns promise if cb is omitted\n */\n\nHasOne.prototype.getAsync = function(options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.profile.getAsync(cb)\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  this.related(true, cb);\n  return cb.promise;\n};\n\nRelationDefinition.embedsOne = function(modelFrom, modelTo, params) {\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params);\n\n  var thisClassName = modelFrom.modelName;\n  var relationName = params.as || (i8n.camelize(modelTo.modelName, true) + 'Item');\n  var propertyName = params.property || i8n.camelize(modelTo.modelName, true);\n  var idName = modelTo.dataSource.idName(modelTo.modelName) || 'id';\n\n  if (relationName === propertyName) {\n    propertyName = '_' + propertyName;\n    debug('EmbedsOne property cannot be equal to relation name: ' +\n      'forcing property %s for relation %s', propertyName, relationName);\n  }\n\n  var definition = modelFrom.relations[relationName] = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.embedsOne,\n    modelFrom: modelFrom,\n    keyFrom: propertyName,\n    keyTo: idName,\n    modelTo: modelTo,\n    multiple: false,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n    embed: true,\n    methods: params.methods,\n  });\n\n  var opts = {type: modelTo};\n\n  if (params.default === true) {\n    opts.default = function() { return new modelTo(); };\n  } else if (typeof params.default === 'object') {\n    opts.default = (function(def) {\n      return function() {\n        return new modelTo(def);\n      };\n    }(params.default));\n  }\n\n  modelFrom.dataSource.defineProperty(modelFrom.modelName, propertyName, opts);\n\n  // validate the embedded instance\n  if (definition.options.validate !== false) {\n    modelFrom.validate(relationName, function(err) {\n      var inst = this[propertyName];\n      if (inst instanceof modelTo) {\n        if (!inst.isValid()) {\n          var first = Object.keys(inst.errors)[0];\n          var msg = 'is invalid: `' + first + '` ' + inst.errors[first];\n          this.errors.add(relationName, msg, 'invalid');\n          err(false);\n        }\n      }\n    });\n  }\n\n  // Define a property for the scope so that we have 'this' for the scoped methods\n  Object.defineProperty(modelFrom.prototype, relationName, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      var relation = new EmbedsOne(definition, this);\n      var relationMethod = relation.related.bind(relation);\n      relationMethod.create = relation.create.bind(relation);\n      relationMethod.build = relation.build.bind(relation);\n      relationMethod.update = relation.update.bind(relation);\n      relationMethod.destroy = relation.destroy.bind(relation);\n      relationMethod.value = relation.embeddedValue.bind(relation);\n      relationMethod._targetClass = definition.modelTo.modelName;\n      bindRelationMethods(relation, relationMethod, definition);\n      return relationMethod;\n    },\n  });\n\n  // FIXME: [rfeng] Wrap the property into a function for remoting\n  // so that it can be accessed as /api/<model>/<id>/<embedsOneRelationName>\n  // For example, /api/orders/1/customer\n  modelFrom.prototype['__get__' + relationName] = function() {\n    var f = this[relationName];\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__create__' + relationName] = function() {\n    var f = this[relationName].create;\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__update__' + relationName] = function() {\n    var f = this[relationName].update;\n    f.apply(this, arguments);\n  };\n\n  modelFrom.prototype['__destroy__' + relationName] = function() {\n    var f = this[relationName].destroy;\n    f.apply(this, arguments);\n  };\n\n  return definition;\n};\n\nEmbedsOne.prototype.related = function(condOrRefresh, options, cb) {\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n  var propertyName = this.definition.keyFrom;\n  var newValue;\n\n  if ((condOrRefresh instanceof ModelBaseClass) &&\n    options === undefined && cb === undefined) {\n    // order.customer(customer)\n    newValue = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // order.customer(cb)\n    cb = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof options === 'function' && cb === undefined) {\n    // order.customer(condOrRefresh, cb)\n    cb = options;\n    options = {};\n  }\n\n  if (newValue) { // acts as setter\n    if (newValue instanceof modelTo) {\n      this.definition.applyProperties(modelInstance, newValue);\n      modelInstance.setAttribute(propertyName, newValue);\n    }\n    return;\n  }\n\n  var embeddedInstance = this.embeddedValue();\n\n  if (embeddedInstance) {\n    embeddedInstance.__persisted = true;\n  }\n\n  if (typeof cb === 'function') { // acts as async getter\n    process.nextTick(function() {\n      cb(null, embeddedInstance);\n    });\n  } else if (condOrRefresh === undefined) { // acts as sync getter\n    return embeddedInstance;\n  }\n};\n\nEmbedsOne.prototype.prepareEmbeddedInstance = function(inst) {\n  if (inst && inst.triggerParent !== 'function') {\n    var self = this;\n    var propertyName = this.definition.keyFrom;\n    var modelInstance = this.modelInstance;\n    if (this.definition.options.persistent) {\n      var pk = this.definition.keyTo;\n      inst.__persisted = !!inst[pk];\n    } else {\n      inst.__persisted = true;\n    }\n    inst.triggerParent = function(actionName, callback) {\n      if (actionName === 'save') {\n        var embeddedValue = self.embeddedValue();\n        modelInstance.updateAttribute(propertyName,\n          embeddedValue, function(err, modelInst) {\n            callback(err, err ? null : modelInst);\n          });\n      } else if (actionName === 'destroy') {\n        modelInstance.unsetAttribute(propertyName, true);\n        // cannot delete property completely the way save works. operator $unset needed like mongo\n        modelInstance.save(function(err, modelInst) {\n          callback(err, modelInst);\n        });\n      } else {\n        process.nextTick(callback);\n      }\n    };\n    var originalTrigger = inst.trigger;\n    inst.trigger = function(actionName, work, data, callback) {\n      if (typeof work === 'function') {\n        var originalWork = work;\n        work = function(next) {\n          originalWork.call(this, function(done) {\n            inst.triggerParent(actionName, function(err, inst) {\n              next(done); // TODO [fabien] - error handling?\n            });\n          });\n        };\n      }\n      originalTrigger.call(this, actionName, work, data, callback);\n    };\n  }\n};\n\nEmbedsOne.prototype.embeddedValue = function(modelInstance) {\n  modelInstance = modelInstance || this.modelInstance;\n  var embeddedValue = modelInstance[this.definition.keyFrom];\n  this.prepareEmbeddedInstance(embeddedValue);\n  return embeddedValue;\n};\n\nEmbedsOne.prototype.create = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.customer.create(data, cb)\n    cb = options;\n    options = {};\n  }\n  var modelTo = this.definition.modelTo;\n  var propertyName = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n\n  targetModelData = targetModelData || {};\n  cb = cb || utils.createPromiseCallback();\n\n  var inst = this.callScopeMethod('build', targetModelData);\n\n  var updateEmbedded = function(callback) {\n    if (modelInstance.isNewRecord()) {\n      modelInstance.setAttribute(propertyName, inst);\n      modelInstance.save(options, function(err) {\n        callback(err, err ? null : inst);\n      });\n    } else {\n      modelInstance.updateAttribute(propertyName,\n        inst, options, function(err) {\n          callback(err, err ? null : inst);\n        });\n    }\n  };\n\n  if (this.definition.options.persistent) {\n    inst.save(options, function(err) { // will validate\n      if (err) return cb(err, inst);\n      updateEmbedded(cb);\n    });\n  } else {\n    var context = {\n      Model: modelTo,\n      instance: inst,\n      options: options || {},\n      hookState: {},\n    };\n    modelTo.notifyObserversOf('before save', context, function(err) {\n      if (err) {\n        return process.nextTick(function() {\n          cb(err);\n        });\n      }\n\n      err = inst.isValid() ? null : new ValidationError(inst);\n      if (err) {\n        process.nextTick(function() {\n          cb(err);\n        });\n      } else {\n        updateEmbedded(function(err, inst) {\n          if (err) return cb(err);\n          context.instance = inst;\n          modelTo.notifyObserversOf('after save', context, function(err) {\n            cb(err, err ? null : inst);\n          });\n        });\n      }\n    });\n  }\n  return cb.promise;\n};\n\nEmbedsOne.prototype.build = function(targetModelData) {\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n  var propertyName = this.definition.keyFrom;\n  var forceId = this.definition.options.forceId;\n  var persistent = this.definition.options.persistent;\n  var connector = modelTo.dataSource.connector;\n\n  targetModelData = targetModelData || {};\n\n  this.definition.applyProperties(modelInstance, targetModelData);\n\n  var pk = this.definition.keyTo;\n  var pkProp = modelTo.definition.properties[pk];\n\n  var assignId = (forceId || targetModelData[pk] === undefined);\n  assignId = assignId && !persistent && (pkProp && pkProp.generated);\n\n  if (assignId && typeof connector.generateId === 'function') {\n    var id = connector.generateId(modelTo.modelName, targetModelData, pk);\n    targetModelData[pk] = id;\n  }\n\n  var embeddedInstance = new modelTo(targetModelData);\n  modelInstance[propertyName] = embeddedInstance;\n\n  this.prepareEmbeddedInstance(embeddedInstance);\n\n  return embeddedInstance;\n};\n\nEmbedsOne.prototype.update = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.customer.update(data, cb)\n    cb = options;\n    options = {};\n  }\n\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n  var propertyName = this.definition.keyFrom;\n\n  var isInst = targetModelData instanceof ModelBaseClass;\n  var data = isInst ? targetModelData.toObject() : targetModelData;\n\n  var embeddedInstance = this.embeddedValue();\n  if (embeddedInstance instanceof modelTo) {\n    cb = cb || utils.createPromiseCallback();\n    var hookState = {};\n    var context = {\n      Model: modelTo,\n      currentInstance: embeddedInstance,\n      data: data,\n      options: options || {},\n      hookState: hookState,\n    };\n    modelTo.notifyObserversOf('before save', context, function(err) {\n      if (err) return cb(err);\n\n      embeddedInstance.setAttributes(context.data);\n\n      // TODO support async validations\n      if (!embeddedInstance.isValid()) {\n        return cb(new ValidationError(embeddedInstance));\n      }\n\n      modelInstance.save(function(err, inst) {\n        if (err) return cb(err);\n\n        context = {\n          Model: modelTo,\n          instance: inst ? inst[propertyName] : embeddedInstance,\n          options: options || {},\n          hookState: hookState,\n        };\n        modelTo.notifyObserversOf('after save', context, function(err) {\n          cb(err, context.instance);\n        });\n      });\n    });\n  } else if (!embeddedInstance && cb) {\n    return this.callScopeMethod('create', data, cb);\n  } else if (!embeddedInstance) {\n    return this.callScopeMethod('build', data);\n  }\n  return cb.promise;\n};\n\nEmbedsOne.prototype.destroy = function(options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.customer.destroy(cb)\n    cb = options;\n    options = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n  var propertyName = this.definition.keyFrom;\n  var embeddedInstance = modelInstance[propertyName];\n\n  if (!embeddedInstance) {\n    cb();\n    return cb.promise;\n  }\n\n  modelInstance.unsetAttribute(propertyName, true);\n\n  var context = {\n    Model: modelTo,\n    instance: embeddedInstance,\n    options: options || {},\n    hookState: {},\n  };\n  modelTo.notifyObserversOf('before delete', context, function(err) {\n    if (err) return cb(err);\n    modelInstance.save(function(err, result) {\n      if (err) return cb(err);\n      modelTo.notifyObserversOf('after delete', context, cb);\n    });\n  });\n\n  return cb.promise;\n};\n\nRelationDefinition.embedsMany = function embedsMany(modelFrom, modelTo, params) {\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params, true);\n\n  var thisClassName = modelFrom.modelName;\n  var relationName = params.as || (i8n.camelize(modelTo.modelName, true) + 'List');\n  var propertyName = params.property || i8n.camelize(modelTo.pluralModelName, true);\n  var idName = modelTo.dataSource.idName(modelTo.modelName) || 'id';\n\n  if (relationName === propertyName) {\n    propertyName = '_' + propertyName;\n    debug('EmbedsMany property cannot be equal to relation name: ' +\n      'forcing property %s for relation %s', propertyName, relationName);\n  }\n\n  var definition = modelFrom.relations[relationName] = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.embedsMany,\n    modelFrom: modelFrom,\n    keyFrom: propertyName,\n    keyTo: idName,\n    modelTo: modelTo,\n    multiple: true,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n    embed: true,\n  });\n\n  modelFrom.dataSource.defineProperty(modelFrom.modelName, propertyName, {\n    type: [modelTo], default: function() { return []; },\n  });\n\n  if (typeof modelTo.dataSource.connector.generateId !== 'function') {\n    modelFrom.validate(propertyName, function(err) {\n      var self = this;\n      var embeddedList = this[propertyName] || [];\n      var hasErrors = false;\n      embeddedList.forEach(function(item, idx) {\n        if (item instanceof modelTo && item[idName] == undefined) {\n          hasErrors = true;\n          var msg = 'contains invalid item at index `' + idx + '`:';\n          msg += ' `' + idName + '` is blank';\n          self.errors.add(propertyName, msg, 'invalid');\n        }\n      });\n      if (hasErrors) err(false);\n    });\n  }\n\n  if (!params.polymorphic) {\n    modelFrom.validate(propertyName, function(err) {\n      var embeddedList = this[propertyName] || [];\n      var ids = embeddedList.map(function(m) { return m[idName] && m[idName].toString(); }); // mongodb\n      var uniqueIds = ids.filter(function(id, pos) {\n        return utils.findIndexOf(ids, id, idEquals) === pos;\n      });\n      if (ids.length !== uniqueIds.length) {\n        this.errors.add(propertyName, 'contains duplicate `' + idName + '`', 'uniqueness');\n        err(false);\n      }\n    }, {code: 'uniqueness'});\n  }\n\n  // validate all embedded items\n  if (definition.options.validate !== false) {\n    modelFrom.validate(propertyName, function(err) {\n      var self = this;\n      var embeddedList = this[propertyName] || [];\n      var hasErrors = false;\n      embeddedList.forEach(function(item, idx) {\n        if (item instanceof modelTo) {\n          if (!item.isValid()) {\n            hasErrors = true;\n            var id = item[idName];\n            var first = Object.keys(item.errors)[0];\n            let msg = id ?\n              'contains invalid item: `' + id + '`' :\n              'contains invalid item at index `' + idx + '`';\n            msg += ' (`' + first + '` ' + item.errors[first] + ')';\n            self.errors.add(propertyName, msg, 'invalid');\n          }\n        } else {\n          hasErrors = true;\n          self.errors.add(propertyName, 'contains invalid item', 'invalid');\n        }\n      });\n      if (hasErrors) err(false);\n    });\n  }\n\n  var scopeMethods = {\n    findById: scopeMethod(definition, 'findById'),\n    destroy: scopeMethod(definition, 'destroyById'),\n    updateById: scopeMethod(definition, 'updateById'),\n    exists: scopeMethod(definition, 'exists'),\n    add: scopeMethod(definition, 'add'),\n    remove: scopeMethod(definition, 'remove'),\n    get: scopeMethod(definition, 'get'),\n    set: scopeMethod(definition, 'set'),\n    unset: scopeMethod(definition, 'unset'),\n    at: scopeMethod(definition, 'at'),\n    value: scopeMethod(definition, 'embeddedValue'),\n  };\n\n  var findByIdFunc = scopeMethods.findById;\n  modelFrom.prototype['__findById__' + relationName] = findByIdFunc;\n\n  var destroyByIdFunc = scopeMethods.destroy;\n  modelFrom.prototype['__destroyById__' + relationName] = destroyByIdFunc;\n\n  var updateByIdFunc = scopeMethods.updateById;\n  modelFrom.prototype['__updateById__' + relationName] = updateByIdFunc;\n\n  var addFunc = scopeMethods.add;\n  modelFrom.prototype['__link__' + relationName] = addFunc;\n\n  var removeFunc = scopeMethods.remove;\n  modelFrom.prototype['__unlink__' + relationName] = removeFunc;\n\n  scopeMethods.create = scopeMethod(definition, 'create');\n  scopeMethods.build = scopeMethod(definition, 'build');\n\n  scopeMethods.related = scopeMethod(definition, 'related'); // bound to definition\n\n  if (!definition.options.persistent) {\n    scopeMethods.destroyAll = scopeMethod(definition, 'destroyAll');\n  }\n\n  var customMethods = extendScopeMethods(definition, scopeMethods, params.scopeMethods);\n\n  for (var i = 0; i < customMethods.length; i++) {\n    var methodName = customMethods[i];\n    var method = scopeMethods[methodName];\n    if (typeof method === 'function' && method.shared === true) {\n      modelFrom.prototype['__' + methodName + '__' + relationName] = method;\n    }\n  };\n\n  // Mix the property and scoped methods into the prototype class\n  var scopeDefinition = defineScope(modelFrom.prototype, modelTo, relationName, function() {\n    return {};\n  }, scopeMethods, definition.options);\n\n  scopeDefinition.related = scopeMethods.related;\n\n  return definition;\n};\n\nEmbedsMany.prototype.prepareEmbeddedInstance = function(inst) {\n  if (inst && inst.triggerParent !== 'function') {\n    var self = this;\n    var propertyName = this.definition.keyFrom;\n    var modelInstance = this.modelInstance;\n    if (this.definition.options.persistent) {\n      var pk = this.definition.keyTo;\n      inst.__persisted = !!inst[pk];\n    } else {\n      inst.__persisted = true;\n    }\n    inst.triggerParent = function(actionName, callback) {\n      if (actionName === 'save' || actionName === 'destroy') {\n        var embeddedList = self.embeddedList();\n        if (actionName === 'destroy') {\n          var index = embeddedList.indexOf(inst);\n          if (index > -1) embeddedList.splice(index, 1);\n        }\n        modelInstance.updateAttribute(propertyName,\n          embeddedList, function(err, modelInst) {\n            callback(err, err ? null : modelInst);\n          });\n      } else {\n        process.nextTick(callback);\n      }\n    };\n    var originalTrigger = inst.trigger;\n    inst.trigger = function(actionName, work, data, callback) {\n      if (typeof work === 'function') {\n        var originalWork = work;\n        work = function(next) {\n          originalWork.call(this, function(done) {\n            inst.triggerParent(actionName, function(err, inst) {\n              next(done); // TODO [fabien] - error handling?\n            });\n          });\n        };\n      }\n      originalTrigger.call(this, actionName, work, data, callback);\n    };\n  }\n};\n\nEmbedsMany.prototype.embeddedList =\nEmbedsMany.prototype.embeddedValue = function(modelInstance) {\n  modelInstance = modelInstance || this.modelInstance;\n  var embeddedList = modelInstance[this.definition.keyFrom] || [];\n  embeddedList.forEach(this.prepareEmbeddedInstance.bind(this));\n  return embeddedList;\n};\n\nEmbedsMany.prototype.related = function(receiver, scopeParams, condOrRefresh, options, cb) {\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var actualCond = {};\n\n  if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.emails(receiver, scopeParams, cb)\n    cb = condOrRefresh;\n    condOrRefresh = false;\n  } else if (typeof options === 'function' && cb === undefined) {\n    // customer.emails(receiver, scopeParams, condOrRefresh, cb)\n    cb = options;\n    options = {};\n  }\n\n  if (typeof condOrRefresh === 'object') {\n    actualCond = condOrRefresh;\n  }\n\n  var embeddedList = this.embeddedList(receiver);\n\n  this.definition.applyScope(receiver, actualCond);\n\n  var params = mergeQuery(actualCond, scopeParams);\n\n  if (params.where && Object.keys(params.where).length > 0) { // TODO [fabien] Support order/sorting\n    embeddedList = embeddedList ? embeddedList.filter(applyFilter(params)) : embeddedList;\n  }\n\n  var returnRelated = function(list) {\n    if (params.include) {\n      modelTo.include(list, params.include, options, cb);\n    } else {\n      process.nextTick(function() { cb(null, list); });\n    }\n  };\n\n  returnRelated(embeddedList);\n};\n\nEmbedsMany.prototype.findById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // order.emails(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var pk = this.definition.keyTo;\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var embeddedList = this.embeddedList();\n\n  var find = function(id) {\n    for (var i = 0; i < embeddedList.length; i++) {\n      var item = embeddedList[i];\n      if (idEquals(item[pk], id)) return item;\n    }\n    return null;\n  };\n\n  var item = find(fkId.toString()); // in case of explicit id\n  item = (item instanceof modelTo) ? item : null;\n\n  if (typeof cb === 'function') {\n    process.nextTick(function() {\n      cb(null, item);\n    });\n  };\n\n  return item; // sync\n};\n\nEmbedsMany.prototype.exists = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.exists(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var modelTo = this.definition.modelTo;\n  var inst = this.findById(fkId, options, function(err, inst) {\n    if (cb) cb(err, inst instanceof modelTo);\n  });\n  return inst instanceof modelTo; // sync\n};\n\nEmbedsMany.prototype.updateById = function(fkId, data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.updateById(fkId, data, cb)\n    cb = options;\n    options = {};\n  }\n  if (typeof data === 'function') {\n    // customer.emails.updateById(fkId, cb)\n    cb = data;\n    data = {};\n  }\n  options = options || {};\n\n  var modelTo = this.definition.modelTo;\n  var propertyName = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  var embeddedList = this.embeddedList();\n\n  var inst = this.findById(fkId);\n\n  if (inst instanceof modelTo) {\n    var hookState = {};\n    var context = {\n      Model: modelTo,\n      currentInstance: inst,\n      data: data,\n      options: options,\n      hookState: hookState,\n    };\n    modelTo.notifyObserversOf('before save', context, function(err) {\n      if (err) return cb && cb(err);\n\n      inst.setAttributes(data);\n\n      err = inst.isValid() ? null : new ValidationError(inst);\n      if (err && typeof cb === 'function') {\n        return process.nextTick(function() {\n          cb(err, inst);\n        });\n      }\n\n      context = {\n        Model: modelTo,\n        instance: inst,\n        options: options,\n        hookState: hookState,\n      };\n\n      if (typeof cb === 'function') {\n        modelInstance.updateAttribute(propertyName, embeddedList, options,\n        function(err) {\n          if (err) return cb(err, inst);\n          modelTo.notifyObserversOf('after save', context, function(err) {\n            cb(err, inst);\n          });\n        });\n      } else {\n        modelTo.notifyObserversOf('after save', context, function(err) {\n          if (!err) return;\n          debug('Unhandled error in \"after save\" hooks: %s', err.stack || err);\n        });\n      }\n    });\n  } else if (typeof cb === 'function') {\n    process.nextTick(function() {\n      cb(null, null); // not found\n    });\n  }\n  return inst; // sync\n};\n\nEmbedsMany.prototype.destroyById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.destroyById(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var modelTo = this.definition.modelTo;\n  var propertyName = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  var embeddedList = this.embeddedList();\n\n  var inst = (fkId instanceof modelTo) ? fkId : this.findById(fkId);\n\n  if (inst instanceof modelTo) {\n    var context = {\n      Model: modelTo,\n      instance: inst,\n      options: options || {},\n      hookState: {},\n    };\n    modelTo.notifyObserversOf('before delete', context, function(err) {\n      if (err) return cb(err);\n\n      var index = embeddedList.indexOf(inst);\n      if (index > -1) embeddedList.splice(index, 1);\n      if (typeof cb !== 'function') return;\n      modelInstance.updateAttribute(propertyName,\n        embeddedList, function(err) {\n          if (err) return cb(err);\n          modelTo.notifyObserversOf('after delete', context, function(err) {\n            cb(err);\n          });\n        });\n    });\n  } else if (typeof cb === 'function') {\n    process.nextTick(cb); // not found\n  }\n  return inst; // sync\n};\n\nEmbedsMany.prototype.destroyAll = function(where, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.destroyAll(where, cb);\n    cb = options;\n    options = {};\n  } else if (typeof where === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.emails.destroyAll(cb);\n    cb = where;\n    where = {};\n  }\n  var propertyName = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  var embeddedList = this.embeddedList();\n\n  if (where && Object.keys(where).length > 0) {\n    var filter = applyFilter({where: where});\n    var reject = function(v) { return !filter(v); };\n    embeddedList = embeddedList ? embeddedList.filter(reject) : embeddedList;\n  } else {\n    embeddedList = [];\n  }\n\n  if (typeof cb === 'function') {\n    modelInstance.updateAttribute(propertyName,\n      embeddedList, function(err) {\n        cb(err);\n      });\n  } else {\n    modelInstance.setAttribute(propertyName, embeddedList);\n  }\n};\n\nEmbedsMany.prototype.get = EmbedsMany.prototype.findById;\nEmbedsMany.prototype.set = EmbedsMany.prototype.updateById;\nEmbedsMany.prototype.unset = EmbedsMany.prototype.destroyById;\n\nEmbedsMany.prototype.at = function(index, cb) {\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var embeddedList = this.embeddedList();\n\n  var item = embeddedList[parseInt(index)];\n  item = (item instanceof modelTo) ? item : null;\n\n  if (typeof cb === 'function') {\n    process.nextTick(function() {\n      cb(null, item);\n    });\n  };\n\n  return item; // sync\n};\n\nEmbedsMany.prototype.create = function(targetModelData, options, cb) {\n  var pk = this.definition.keyTo;\n  var modelTo = this.definition.modelTo;\n  var propertyName = this.definition.keyFrom;\n  var modelInstance = this.modelInstance;\n\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.create(cb)\n    cb = options;\n    options = {};\n  }\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n  targetModelData = targetModelData || {};\n  cb = cb || utils.createPromiseCallback();\n\n  var embeddedList = this.embeddedList();\n\n  var inst = this.callScopeMethod('build', targetModelData);\n\n  var updateEmbedded = function(callback) {\n    if (modelInstance.isNewRecord()) {\n      modelInstance.setAttribute(propertyName, embeddedList);\n      modelInstance.save(options, function(err) {\n        callback(err, err ? null : inst);\n      });\n    } else {\n      modelInstance.updateAttribute(propertyName,\n        embeddedList, options, function(err) {\n          callback(err, err ? null : inst);\n        });\n    }\n  };\n\n  if (this.definition.options.persistent) {\n    inst.save(function(err) { // will validate\n      if (err) return cb(err, inst);\n      updateEmbedded(cb);\n    });\n  } else {\n    const err = inst.isValid() ? null : new ValidationError(inst);\n    if (err) {\n      process.nextTick(function() {\n        cb(err);\n      });\n    } else {\n      var context = {\n        Model: modelTo,\n        instance: inst,\n        options: options || {},\n        hookState: {},\n      };\n      modelTo.notifyObserversOf('before save', context, function(err) {\n        if (err) return cb(err);\n        updateEmbedded(function(err, inst) {\n          if (err) return cb(err, null);\n          modelTo.notifyObserversOf('after save', context, function(err) {\n            cb(err, err ? null : inst);\n          });\n        });\n      });\n    }\n  }\n  return cb.promise;\n};\n\nEmbedsMany.prototype.build = function(targetModelData) {\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n  var forceId = this.definition.options.forceId;\n  var persistent = this.definition.options.persistent;\n  var connector = modelTo.dataSource.connector;\n\n  var pk = this.definition.keyTo;\n  var pkProp = modelTo.definition.properties[pk];\n  var pkType = pkProp && pkProp.type;\n\n  var embeddedList = this.embeddedList();\n\n  targetModelData = targetModelData || {};\n\n  var assignId = (forceId || targetModelData[pk] === undefined);\n  assignId = assignId && !persistent;\n\n  if (assignId && pkType === Number) {\n    var ids = embeddedList.map(function(m) {\n      return (typeof m[pk] === 'number' ? m[pk] : 0);\n    });\n    if (ids.length > 0) {\n      targetModelData[pk] = Math.max.apply(null, ids) + 1;\n    } else {\n      targetModelData[pk] = 1;\n    }\n  } else if (assignId && typeof connector.generateId === 'function') {\n    var id = connector.generateId(modelTo.modelName, targetModelData, pk);\n    targetModelData[pk] = id;\n  }\n\n  this.definition.applyProperties(modelInstance, targetModelData);\n\n  var inst = new modelTo(targetModelData);\n\n  if (this.definition.options.prepend) {\n    embeddedList.unshift(inst);\n  } else {\n    embeddedList.push(inst);\n  }\n\n  this.prepareEmbeddedInstance(inst);\n\n  return inst;\n};\n\n/**\n * Add the target model instance to the 'embedsMany' relation\n * @param {Object|ID} acInst The actual instance or id value\n */\nEmbedsMany.prototype.add = function(acInst, data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.add(acInst, data, cb)\n    cb = options;\n    options = {};\n  } else if (typeof data === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.emails.add(acInst, cb)\n    cb = data;\n    data = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n\n  var self = this;\n  var definition = this.definition;\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var defOpts = definition.options;\n  var belongsTo = defOpts.belongsTo && modelTo.relations[defOpts.belongsTo];\n\n  if (!belongsTo) {\n    throw new Error('Invalid reference: ' + defOpts.belongsTo || '(none)');\n  }\n\n  var fk2 = belongsTo.keyTo;\n  var pk2 = belongsTo.modelTo.definition.idName() || 'id';\n\n  var query = {};\n\n  query[fk2] = (acInst instanceof belongsTo.modelTo) ? acInst[pk2] : acInst;\n\n  var filter = {where: query};\n\n  belongsTo.applyScope(modelInstance, filter);\n\n  belongsTo.modelTo.findOne(filter, options, function(err, ref) {\n    if (ref instanceof belongsTo.modelTo) {\n      var inst = self.build(data || {});\n      inst[defOpts.belongsTo](ref);\n      modelInstance.save(function(err) {\n        cb(err, err ? null : inst);\n      });\n    } else {\n      cb(null, null);\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Remove the target model instance from the 'embedsMany' relation\n * @param {Object|ID) acInst The actual instance or id value\n */\nEmbedsMany.prototype.remove = function(acInst, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.emails.remove(acInst, cb)\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var definition = this.definition;\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var defOpts = definition.options;\n  var belongsTo = defOpts.belongsTo && modelTo.relations[defOpts.belongsTo];\n\n  if (!belongsTo) {\n    throw new Error('Invalid reference: ' + defOpts.belongsTo || '(none)');\n  }\n\n  var fk2 = belongsTo.keyTo;\n  var pk2 = belongsTo.modelTo.definition.idName() || 'id';\n\n  var query = {};\n\n  query[fk2] = (acInst instanceof belongsTo.modelTo) ? acInst[pk2] : acInst;\n\n  var filter = {where: query};\n\n  belongsTo.applyScope(modelInstance, filter);\n\n  cb = cb || utils.createPromiseCallback();\n\n  modelInstance[definition.name](filter, options, function(err, items) {\n    if (err) return cb(err);\n\n    items.forEach(function(item) {\n      self.unset(item);\n    });\n\n    modelInstance.save(options, function(err) {\n      cb(err);\n    });\n  });\n  return cb.promise;\n};\n\nRelationDefinition.referencesMany = function referencesMany(modelFrom, modelTo, params) {\n  params = params || {};\n  modelTo = lookupModelTo(modelFrom, modelTo, params, true);\n\n  var thisClassName = modelFrom.modelName;\n  var relationName = params.as || i8n.camelize(modelTo.pluralModelName, true);\n  var fk = params.foreignKey || i8n.camelize(modelTo.modelName + '_ids', true);\n  var idName = modelTo.dataSource.idName(modelTo.modelName) || 'id';\n  var idType = modelTo.definition.properties[idName].type;\n\n  var definition = modelFrom.relations[relationName] = new RelationDefinition({\n    name: relationName,\n    type: RelationTypes.referencesMany,\n    modelFrom: modelFrom,\n    keyFrom: fk,\n    keyTo: idName,\n    modelTo: modelTo,\n    multiple: true,\n    properties: params.properties,\n    scope: params.scope,\n    options: params.options,\n  });\n\n  modelFrom.dataSource.defineProperty(modelFrom.modelName, fk, {\n    type: [idType], default: function() { return []; },\n  });\n\n  modelFrom.validate(relationName, function(err) {\n    var ids = this[fk] || [];\n    var uniqueIds = ids.filter(function(id, pos) {\n      return utils.findIndexOf(ids, id, idEquals) === pos;\n    });\n    if (ids.length !== uniqueIds.length) {\n      var msg = 'contains duplicate `' + modelTo.modelName + '` instance';\n      this.errors.add(relationName, msg, 'uniqueness');\n      err(false);\n    }\n  }, {code: 'uniqueness'});\n\n  var scopeMethods = {\n    findById: scopeMethod(definition, 'findById'),\n    destroy: scopeMethod(definition, 'destroyById'),\n    updateById: scopeMethod(definition, 'updateById'),\n    exists: scopeMethod(definition, 'exists'),\n    add: scopeMethod(definition, 'add'),\n    remove: scopeMethod(definition, 'remove'),\n    at: scopeMethod(definition, 'at'),\n  };\n\n  var findByIdFunc = scopeMethods.findById;\n  modelFrom.prototype['__findById__' + relationName] = findByIdFunc;\n\n  var destroyByIdFunc = scopeMethods.destroy;\n  modelFrom.prototype['__destroyById__' + relationName] = destroyByIdFunc;\n\n  var updateByIdFunc = scopeMethods.updateById;\n  modelFrom.prototype['__updateById__' + relationName] = updateByIdFunc;\n\n  var addFunc = scopeMethods.add;\n  modelFrom.prototype['__link__' + relationName] = addFunc;\n\n  var removeFunc = scopeMethods.remove;\n  modelFrom.prototype['__unlink__' + relationName] = removeFunc;\n\n  scopeMethods.create = scopeMethod(definition, 'create');\n  scopeMethods.build = scopeMethod(definition, 'build');\n\n  scopeMethods.related = scopeMethod(definition, 'related');\n\n  var customMethods = extendScopeMethods(definition, scopeMethods, params.scopeMethods);\n\n  for (var i = 0; i < customMethods.length; i++) {\n    var methodName = customMethods[i];\n    var method = scopeMethods[methodName];\n    if (typeof method === 'function' && method.shared === true) {\n      modelFrom.prototype['__' + methodName + '__' + relationName] = method;\n    }\n  };\n\n  // Mix the property and scoped methods into the prototype class\n  var scopeDefinition = defineScope(modelFrom.prototype, modelTo, relationName, function() {\n    return {};\n  }, scopeMethods, definition.options);\n\n  scopeDefinition.related = scopeMethods.related; // bound to definition\n\n  return definition;\n};\n\nReferencesMany.prototype.related = function(receiver, scopeParams, condOrRefresh, options, cb) {\n  var fk = this.definition.keyFrom;\n  var modelTo = this.definition.modelTo;\n  var relationName = this.definition.name;\n  var modelInstance = this.modelInstance;\n  var self = receiver;\n\n  var actualCond = {};\n  var actualRefresh = false;\n\n  if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.orders(receiver, scopeParams, cb)\n    cb = condOrRefresh;\n    condOrRefresh = undefined;\n  } else if (typeof options === 'function' && cb === undefined) {\n    // customer.orders(receiver, scopeParams, condOrRefresh, cb)\n    cb = options;\n    options = {};\n    if (typeof condOrRefresh === 'boolean') {\n      actualRefresh = condOrRefresh;\n      condOrRefresh = {};\n    } else {\n      actualRefresh = true;\n    }\n  }\n  actualCond = condOrRefresh || {};\n\n  var ids = self[fk] || [];\n\n  this.definition.applyScope(modelInstance, actualCond);\n\n  var params = mergeQuery(actualCond, scopeParams);\n  return modelTo.findByIds(ids, params, options, cb);\n};\n\nReferencesMany.prototype.findById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.findById(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var modelTo = this.definition.modelTo;\n  var modelFrom = this.definition.modelFrom;\n  var relationName = this.definition.name;\n  var modelInstance = this.modelInstance;\n\n  var pk = this.definition.keyTo;\n  var fk = this.definition.keyFrom;\n\n  if (typeof fkId === 'object') {\n    fkId = fkId.toString(); // mongodb\n  }\n\n  var ids = modelInstance[fk] || [];\n\n  var filter = {};\n\n  this.definition.applyScope(modelInstance, filter);\n\n  cb = cb || utils.createPromiseCallback();\n\n  modelTo.findByIds([fkId], filter, options, function(err, instances) {\n    if (err) {\n      return cb(err);\n    }\n\n    var inst = instances[0];\n    if (!inst) {\n      err = new Error(g.f('No instance with {{id}} %s found for %s', fkId, modelTo.modelName));\n      err.statusCode = 404;\n      return cb(err);\n    }\n\n    // Check if the foreign key is amongst the ids\n    if (utils.findIndexOf(ids, inst[pk], idEquals) > -1) {\n      cb(null, inst);\n    } else {\n      err = new Error(g.f('Key mismatch: %s.%s: %s, %s.%s: %s',\n        modelFrom.modelName, fk, modelInstance[fk],\n        modelTo.modelName, pk, inst[pk]));\n      err.statusCode = 400;\n      cb(err);\n    }\n  });\n  return cb.promise;\n};\n\nReferencesMany.prototype.exists = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.exists(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var fk = this.definition.keyFrom;\n  var ids = this.modelInstance[fk] || [];\n\n  cb = cb || utils.createPromiseCallback();\n  process.nextTick(function() { cb(null, utils.findIndexOf(ids, fkId, idEquals) > -1); });\n  return cb.promise;\n};\n\nReferencesMany.prototype.updateById = function(fkId, data, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.updateById(fkId, data, cb)\n    cb = options;\n    options = {};\n  } else if (typeof data === 'function' &&\n    options === undefined && cb === undefined) {\n    // customer.orders.updateById(fkId, cb)\n    cb = data;\n    data = {};\n  }\n  cb = cb || utils.createPromiseCallback();\n\n  this.findById(fkId, options, function(err, inst) {\n    if (err) return cb(err);\n    inst.updateAttributes(data, options, cb);\n  });\n  return cb.promise;\n};\n\nReferencesMany.prototype.destroyById = function(fkId, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.destroyById(fkId, cb)\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  cb = cb || utils.createPromiseCallback();\n  this.findById(fkId, function(err, inst) {\n    if (err) return cb(err);\n    self.remove(inst, function(err, ids) {\n      inst.destroy(cb);\n    });\n  });\n  return cb.promise;\n};\n\nReferencesMany.prototype.at = function(index, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.at(index, cb)\n    cb = options;\n    options = {};\n  }\n  var fk = this.definition.keyFrom;\n  var ids = this.modelInstance[fk] || [];\n  cb = cb || utils.createPromiseCallback();\n  this.findById(ids[index], options, cb);\n  return cb.promise;\n};\n\nReferencesMany.prototype.create = function(targetModelData, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.create(data, cb)\n    cb = options;\n    options = {};\n  }\n  var definition = this.definition;\n  var modelTo = this.definition.modelTo;\n  var relationName = this.definition.name;\n  var modelInstance = this.modelInstance;\n\n  var pk = this.definition.keyTo;\n  var fk = this.definition.keyFrom;\n\n  if (typeof targetModelData === 'function' && !cb) {\n    cb = targetModelData;\n    targetModelData = {};\n  }\n  targetModelData = targetModelData || {};\n  cb = cb || utils.createPromiseCallback();\n\n  var ids = modelInstance[fk] || [];\n\n  var inst = this.callScopeMethod('build', targetModelData);\n\n  inst.save(options, function(err, inst) {\n    if (err) return cb(err, inst);\n\n    var id = inst[pk];\n\n    if (typeof id === 'object') {\n      id = id.toString(); // mongodb\n    }\n\n    if (definition.options.prepend) {\n      ids.unshift(id);\n    } else {\n      ids.push(id);\n    }\n\n    modelInstance.updateAttribute(fk,\n      ids, options, function(err, modelInst) {\n        cb(err, inst);\n      });\n  });\n  return cb.promise;\n};\n\nReferencesMany.prototype.build = function(targetModelData) {\n  var modelTo = this.definition.modelTo;\n  targetModelData = targetModelData || {};\n\n  this.definition.applyProperties(this.modelInstance, targetModelData);\n\n  return new modelTo(targetModelData);\n};\n\n/**\n * Add the target model instance to the 'embedsMany' relation\n * @param {Object|ID} acInst The actual instance or id value\n */\nReferencesMany.prototype.add = function(acInst, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.add(acInst, cb)\n    cb = options;\n    options = {};\n  }\n  var self = this;\n  var definition = this.definition;\n  var modelTo = this.definition.modelTo;\n  var modelInstance = this.modelInstance;\n\n  var pk = this.definition.keyTo;\n  var fk = this.definition.keyFrom;\n\n  var insert = function(inst, done) {\n    var id = inst[pk];\n\n    if (typeof id === 'object') {\n      id = id.toString(); // mongodb\n    }\n\n    var ids = modelInstance[fk] || [];\n\n    if (definition.options.prepend) {\n      ids.unshift(id);\n    } else {\n      ids.push(id);\n    }\n\n    modelInstance.updateAttribute(fk, ids, options, function(err) {\n      done(err, err ? null : inst);\n    });\n  };\n\n  cb = cb || utils.createPromiseCallback();\n\n  if (acInst instanceof modelTo) {\n    insert(acInst, cb);\n  } else {\n    var filter = {where: {}};\n    filter.where[pk] = acInst;\n\n    definition.applyScope(modelInstance, filter);\n\n    modelTo.findOne(filter, options, function(err, inst) {\n      if (err || !inst) return cb(err, null);\n      insert(inst, cb);\n    });\n  }\n  return cb.promise;\n};\n\n/**\n * Remove the target model instance from the 'embedsMany' relation\n * @param {Object|ID) acInst The actual instance or id value\n */\nReferencesMany.prototype.remove = function(acInst, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    // customer.orders.remove(acInst, cb)\n    cb = options;\n    options = {};\n  }\n  var definition = this.definition;\n  var modelInstance = this.modelInstance;\n\n  var pk = this.definition.keyTo;\n  var fk = this.definition.keyFrom;\n\n  var ids = modelInstance[fk] || [];\n\n  var id = (acInst instanceof definition.modelTo) ? acInst[pk] : acInst;\n\n  cb = cb || utils.createPromiseCallback();\n\n  var index = utils.findIndexOf(ids, id, idEquals);\n  if (index > -1) {\n    ids.splice(index, 1);\n    modelInstance.updateAttribute(fk, ids, options, function(err, inst) {\n      cb(err, inst[fk] || []);\n    });\n  } else {\n    process.nextTick(function() { cb(null, ids); });\n  }\n  return cb.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/scope.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar i8n = require('inflection');\nvar utils = require('./utils');\nvar defineCachedRelations = utils.defineCachedRelations;\nvar setScopeValuesFromWhere = utils.setScopeValuesFromWhere;\nvar mergeQuery = utils.mergeQuery;\nvar DefaultModelBaseClass = require('./model.js');\nvar collectTargetIds = utils.collectTargetIds;\nvar idName = utils.idName;\n\n/**\n * Module exports\n */\nexports.defineScope = defineScope;\n\nfunction ScopeDefinition(definition) {\n  this.isStatic = definition.isStatic;\n  this.modelFrom = definition.modelFrom;\n  this.modelTo = definition.modelTo || definition.modelFrom;\n  this.name = definition.name;\n  this.params = definition.params;\n  this.methods = definition.methods || {};\n  this.options = definition.options || {};\n}\n\nScopeDefinition.prototype.targetModel = function(receiver) {\n  var modelTo;\n  if (typeof this.options.modelTo === 'function') {\n    modelTo = this.options.modelTo.call(this, receiver) || this.modelTo;\n  } else {\n    modelTo = this.modelTo;\n  }\n  if (!(modelTo.prototype instanceof DefaultModelBaseClass)) {\n    var msg = 'Invalid target model for scope `';\n    msg += (this.isStatic ? this.modelFrom : this.modelFrom.constructor).modelName;\n    msg += this.isStatic ? '.' : '.prototype.';\n    msg += this.name + '`.';\n    throw new Error(msg);\n  }\n  return modelTo;\n};\n\n/*!\n * Find related model instances\n * @param {*} receiver The target model class/prototype\n * @param {Object|Function} scopeParams\n * @param {Boolean|Object} [condOrRefresh] true for refresh or object as a filter\n * @param {Object} [options]\n * @param {Function} cb\n * @returns {*}\n */\nScopeDefinition.prototype.related = function(receiver, scopeParams, condOrRefresh, options, cb) {\n  var name = this.name;\n  var self = receiver;\n\n  var actualCond = {};\n  var actualRefresh = false;\n  var saveOnCache = receiver instanceof DefaultModelBaseClass;\n  if (typeof condOrRefresh === 'function' &&\n    options === undefined && cb === undefined) {\n    // related(receiver, scopeParams, cb)\n    cb = condOrRefresh;\n    options = {};\n    condOrRefresh = undefined;\n  } else if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  if (condOrRefresh !== undefined) {\n    if (typeof condOrRefresh === 'boolean') {\n      actualRefresh = condOrRefresh;\n    } else {\n      actualCond = condOrRefresh;\n      actualRefresh = true;\n      saveOnCache = false;\n    }\n  }\n  cb = cb || utils.createPromiseCallback();\n\n  if (!self.__cachedRelations || self.__cachedRelations[name] === undefined ||\n      actualRefresh) {\n    // It either doesn't hit the cache or refresh is required\n    var params = mergeQuery(actualCond, scopeParams, {nestedInclude: true});\n    var targetModel = this.targetModel(receiver);\n\n    // If there is a through model\n    // run another query to apply filter on relatedModel(targetModel)\n    // see github.com/strongloop/loopback-datasource-juggler/issues/166\n    var scopeOnRelatedModel = params.collect &&\n        params.include.scope !== null &&\n        typeof params.include.scope === 'object';\n    if (scopeOnRelatedModel) {\n      var filter = params.include;\n      // The filter applied on relatedModel\n      var queryRelated = filter.scope;\n      delete params.include.scope;\n    };\n\n    targetModel.find(params, options, function(err, data) {\n      if (!err && saveOnCache) {\n        defineCachedRelations(self);\n        self.__cachedRelations[name] = data;\n      }\n\n      if (scopeOnRelatedModel === true) {\n        var relatedModel = targetModel.relations[filter.relation].modelTo;\n        var IdKey = idName(relatedModel);\n\n        // Merge queryRelated filter and targetId filter\n        var buildWhere = function() {\n          var IdKeyCondition = {};\n          IdKeyCondition[IdKey] = collectTargetIds(data, IdKey);\n          var mergedWhere = {\n            and: [IdKeyCondition, queryRelated.where],\n          };\n          return mergedWhere;\n        };\n        if (queryRelated.where !== undefined) {\n          queryRelated.where = buildWhere();\n        } else {\n          queryRelated.where = {};\n          queryRelated.where[IdKey] = collectTargetIds(data, IdKey);\n        }\n\n        relatedModel.find(queryRelated, cb);\n      } else {\n        cb(err, data);\n      }\n    });\n  } else {\n    // Return from cache\n    cb(null, self.__cachedRelations[name]);\n  }\n  return cb.promise;\n};\n\n/**\n * Define a scope method\n * @param {String} name of the method\n * @param {Function} function to define\n */\nScopeDefinition.prototype.defineMethod = function(name, fn) {\n  return this.methods[name] = fn;\n};\n\n/**\n * Define a scope to the class\n * @param {Model} cls The class where the scope method is added\n * @param {Model} targetClass The class that a query to run against\n * @param {String} name The name of the scope\n * @param {Object|Function} params The parameters object for the query or a function\n * to return the query object\n * @param methods An object of methods keyed by the method name to be bound to the class\n */\nfunction defineScope(cls, targetClass, name, params, methods, options) {\n  // collect meta info about scope\n  if (!cls._scopeMeta) {\n    cls._scopeMeta = {};\n  }\n\n  // only makes sense to add scope in meta if base and target classes\n  // are same\n  if (cls === targetClass) {\n    cls._scopeMeta[name] = params;\n  } else if (targetClass) {\n    if (!targetClass._scopeMeta) {\n      targetClass._scopeMeta = {};\n    }\n  }\n\n  options = options || {};\n  // Check if the cls is the class itself or its prototype\n  var isStatic = (typeof cls === 'function') || options.isStatic || false;\n  var definition = new ScopeDefinition({\n    isStatic: isStatic,\n    modelFrom: cls,\n    modelTo: targetClass,\n    name: name,\n    params: params,\n    methods: methods,\n    options: options,\n  });\n\n  if (isStatic) {\n    cls.scopes = cls.scopes || {};\n    cls.scopes[name] = definition;\n  } else {\n    cls.constructor.scopes = cls.constructor.scopes || {};\n    cls.constructor.scopes[name] = definition;\n  }\n\n  // Define a property for the scope\n  Object.defineProperty(cls, name, {\n    enumerable: false,\n    configurable: true,\n    /**\n     * This defines a property for the scope. For example, user.accounts or\n     * User.vips. Please note the cls can be the model class or prototype of\n     * the model class.\n     *\n     * The property value is function. It can be used to query the scope,\n     * such as user.accounts(condOrRefresh, cb) or User.vips(cb). The value\n     * can also have child properties for create/build/delete. For example,\n     * user.accounts.create(act, cb).\n     *\n     */\n    get: function() {\n      var targetModel = definition.targetModel(this);\n      var self = this;\n\n      var f = function(condOrRefresh, options, cb) {\n        if (arguments.length === 0) {\n          if (typeof f.value === 'function') {\n            return f.value(self);\n          } else if (self.__cachedRelations) {\n            return self.__cachedRelations[name];\n          }\n        } else {\n          if (typeof condOrRefresh === 'function' &&\n              options === undefined && cb === undefined) {\n            // customer.orders(cb)\n            cb = condOrRefresh;\n            options = {};\n            condOrRefresh = undefined;\n          } else if (typeof options === 'function' && cb === undefined) {\n            // customer.orders(condOrRefresh, cb);\n            cb = options;\n            options = {};\n          }\n          options = options || {};\n          // Check if there is a through model\n          // see https://github.com/strongloop/loopback/issues/1076\n          if (f._scope.collect &&\n            condOrRefresh !== null && typeof condOrRefresh === 'object') {\n            f._scope.include = {\n              relation: f._scope.collect,\n              scope: condOrRefresh,\n            };\n            condOrRefresh = {};\n          }\n          return definition.related(self, f._scope, condOrRefresh, options, cb);\n        }\n      };\n\n      f._receiver = this;\n      f._scope = typeof definition.params === 'function' ?\n        definition.params.call(self) : definition.params;\n\n      f._targetClass = targetModel.modelName;\n      if (f._scope.collect) {\n        const rel = targetModel.relations[f._scope.collect];\n        f._targetClass = rel && rel.modelTo && rel.modelTo.modelName || i8n.camelize(f._scope.collect);\n      }\n\n      f.getAsync = function(condOrRefresh, options, cb) {\n        if (typeof condOrRefresh === 'function' &&\n            options === undefined && cb === undefined) {\n          // customer.orders.getAsync(cb)\n          cb = condOrRefresh;\n          options = {};\n          condOrRefresh = {};\n        } else if (typeof options === 'function' && cb === undefined) {\n          // customer.orders.getAsync(condOrRefresh, cb);\n          cb = options;\n          options = {};\n        }\n        options = options || {};\n        return definition.related(self, f._scope, condOrRefresh, options, cb);\n      };\n\n      f.build = build;\n      f.create = create;\n      f.updateAll = updateAll;\n      f.destroyAll = destroyAll;\n      f.findById = findById;\n      f.findOne = findOne;\n      f.count = count;\n\n      for (var i in definition.methods) {\n        f[i] = definition.methods[i].bind(self);\n      }\n\n      if (!targetClass) return f;\n\n      // Define scope-chaining, such as\n      // Station.scope('active', {where: {isActive: true}});\n      // Station.scope('subway', {where: {isUndeground: true}});\n      // Station.active.subway(cb);\n      Object.keys(targetClass._scopeMeta).forEach(function(name) {\n        Object.defineProperty(f, name, {\n          enumerable: false,\n          get: function() {\n            mergeQuery(f._scope, targetModel._scopeMeta[name]);\n            return f;\n          },\n        });\n      }.bind(self));\n      return f;\n    },\n  });\n\n  // Wrap the property into a function for remoting\n  var fn = function() {\n    // primaryObject.scopeName, such as user.accounts\n    var f = this[name];\n    // set receiver to be the scope property whose value is a function\n    f.apply(this[name], arguments);\n  };\n\n  cls['__get__' + name] = fn;\n\n  var fnCreate = function() {\n    var f = this[name].create;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__create__' + name] = fnCreate;\n\n  var fnDelete = function() {\n    var f = this[name].destroyAll;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__delete__' + name] = fnDelete;\n\n  var fnUpdate = function() {\n    var f = this[name].updateAll;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__update__' + name] = fnUpdate;\n\n  var fnFindById = function(cb) {\n    var f = this[name].findById;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__findById__' + name] = fnFindById;\n\n  var fnFindOne = function(cb) {\n    var f = this[name].findOne;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__findOne__' + name] = fnFindOne;\n\n  var fnCount = function(cb) {\n    var f = this[name].count;\n    f.apply(this[name], arguments);\n  };\n\n  cls['__count__' + name] = fnCount;\n\n  // and it should have create/build methods with binded thisModelNameId param\n  function build(data) {\n    data = data || {};\n    // Find all fixed property values for the scope\n    var targetModel = definition.targetModel(this._receiver);\n    var where = (this._scope && this._scope.where) || {};\n    setScopeValuesFromWhere(data, where, targetModel);\n    return new targetModel(data);\n  }\n\n  function create(data, options, cb) {\n    if (typeof data === 'function' &&\n      options === undefined && cb === undefined) {\n      // create(cb)\n      cb = data;\n      data = {};\n    } else if (typeof options === 'function' && cb === undefined) {\n      // create(data, cb)\n      cb = options;\n      options = {};\n    }\n    options = options || {};\n    return this.build(data).save(options, cb);\n  }\n\n  /*\n   Callback\n   - The callback will be called after all elements are destroyed\n   - For every destroy call which results in an error\n   - If fetching the Elements on which destroyAll is called results in an error\n   */\n  function destroyAll(where, options, cb) {\n    if (typeof where === 'function') {\n      // destroyAll(cb)\n      cb = where;\n      where = {};\n    } else if (typeof options === 'function' && cb === undefined) {\n      // destroyAll(where, cb)\n      cb = options;\n      options = {};\n    }\n    options = options || {};\n\n    var targetModel = definition.targetModel(this._receiver);\n    var scoped = (this._scope && this._scope.where) || {};\n    var filter = mergeQuery({where: scoped}, {where: where || {}});\n    return targetModel.destroyAll(filter.where, options, cb);\n  }\n\n  function updateAll(where, data, options, cb) {\n    if (typeof data === 'function' &&\n      options === undefined && cb === undefined) {\n      // updateAll(data, cb)\n      cb = data;\n      data = where;\n      where = {};\n      options = {};\n    } else if (typeof options === 'function' && cb === undefined) {\n      // updateAll(where, data, cb)\n      cb = options;\n      options = {};\n    }\n    options = options || {};\n    var targetModel = definition.targetModel(this._receiver);\n    var scoped = (this._scope && this._scope.where) || {};\n    var filter = mergeQuery({where: scoped}, {where: where || {}});\n    return targetModel.updateAll(filter.where, data, options, cb);\n  }\n\n  function findById(id, filter, options, cb) {\n    if (options === undefined && cb === undefined) {\n      if (typeof filter === 'function') {\n        // findById(id, cb)\n        cb = filter;\n        filter = {};\n      }\n    } else if (cb === undefined) {\n      if (typeof options === 'function') {\n        // findById(id, query, cb)\n        cb = options;\n        options = {};\n        if (typeof filter === 'object' && !(filter.include || filter.fields)) {\n          // If filter doesn't have include or fields, assuming it's options\n          options = filter;\n          filter = {};\n        }\n      }\n    }\n\n    options = options || {};\n    filter = filter || {};\n    var targetModel = definition.targetModel(this._receiver);\n    var idName = targetModel.definition.idName();\n    var query = {where: {}};\n    query.where[idName] = id;\n    query = mergeQuery(query, filter);\n    return this.findOne(query, options, cb);\n  }\n\n  function findOne(filter, options, cb) {\n    if (typeof filter === 'function') {\n      // findOne(cb)\n      cb = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function' && cb === undefined) {\n      // findOne(filter, cb)\n      cb = options;\n      options = {};\n    }\n    options = options || {};\n    var targetModel = definition.targetModel(this._receiver);\n    var scoped = (this._scope && this._scope.where) || {};\n    filter = mergeQuery({where: scoped}, filter || {});\n    return targetModel.findOne(filter, options, cb);\n  }\n\n  function count(where, options, cb) {\n    if (typeof where === 'function') {\n      // count(cb)\n      cb = where;\n      where = {};\n    } else if (typeof options === 'function' && cb === undefined) {\n      // count(where, cb)\n      cb = options;\n      options = {};\n    }\n    options = options || {};\n\n    var targetModel = definition.targetModel(this._receiver);\n    var scoped = (this._scope && this._scope.where) || {};\n    var filter = mergeQuery({where: scoped}, {where: where || {}});\n    return targetModel.count(filter.where, options, cb);\n  }\n\n  return definition;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/connectors/memory.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\n/* global window:false */\nvar g = require('strong-globalize')();\nvar util = require('util');\nvar Connector = require('loopback-connector').Connector;\nvar geo = require('../geo');\nvar utils = require('../utils');\nvar fs = require('fs');\nvar async = require('async');\nvar debug = require('debug')('loopback:connector:memory');\n\n/**\n * Initialize the Memory connector against the given data source\n *\n * @param {DataSource} dataSource The loopback-datasource-juggler dataSource\n * @param {Function} [callback] The callback function\n */\nexports.initialize = function initializeDataSource(dataSource, callback) {\n  dataSource.connector = new Memory(null, dataSource.settings);\n  // Use dataSource.connect to avoid duplicate file reads from cache\n  dataSource.connect(callback);\n};\n\nexports.Memory = Memory;\nexports.applyFilter = applyFilter;\n\nfunction Memory(m, settings) {\n  if (m instanceof Memory) {\n    this.isTransaction = true;\n    this.cache = m.cache;\n    this.ids = m.ids;\n    this.constructor.super_.call(this, 'memory', settings);\n    this._models = m._models;\n  } else {\n    this.isTransaction = false;\n    this.cache = {};\n    this.ids = {};\n    this.constructor.super_.call(this, 'memory', settings);\n  }\n}\n\nutil.inherits(Memory, Connector);\n\nMemory.prototype.getDefaultIdType = function() {\n  return Number;\n};\n\nMemory.prototype.getTypes = function() {\n  return ['db', 'nosql', 'memory'];\n};\n\nMemory.prototype.connect = function(callback) {\n  if (this.isTransaction) {\n    this.onTransactionExec = callback;\n  } else {\n    this.loadFromFile(callback);\n  }\n};\n\nfunction serialize(obj) {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n  return JSON.stringify(obj);\n}\n\nfunction deserialize(dbObj) {\n  if (dbObj === null || dbObj === undefined) {\n    return dbObj;\n  }\n  if (typeof dbObj === 'string') {\n    return JSON.parse(dbObj);\n  } else {\n    return dbObj;\n  }\n}\n\nMemory.prototype.getCollection = function(model) {\n  var modelClass = this._models[model];\n  if (modelClass && modelClass.settings.memory) {\n    model = modelClass.settings.memory.collection || model;\n  }\n  return model;\n};\n\nMemory.prototype.initCollection = function(model) {\n  this.collection(model, {});\n  this.collectionSeq(model, 1);\n};\n\nMemory.prototype.collection = function(model, val) {\n  model = this.getCollection(model);\n  if (arguments.length > 1) this.cache[model] = val;\n  return this.cache[model];\n};\n\nMemory.prototype.collectionSeq = function(model, val) {\n  model = this.getCollection(model);\n  if (arguments.length > 1) this.ids[model] = val;\n  return this.ids[model];\n};\n\n/**\n * Create a queue to serialize file read/write operations\n * @returns {*} The file operation queue\n */\nMemory.prototype.setupFileQueue = function() {\n  var self = this;\n  if (!this.fileQueue) {\n    // Create a queue for writes\n    this.fileQueue = async.queue(function(task, done) {\n      var callback = task.callback || function() {};\n      var file = self.settings.file;\n      if (task.operation === 'write') {\n        // Flush out the models/ids\n        var data = JSON.stringify({\n          ids: self.ids,\n          models: self.cache,\n        }, null, '  ');\n        debug('Writing cache to %s: %s', file, data);\n        fs.writeFile(file, data, function(err) {\n          debug('Cache has been written to %s', file);\n          done(err);\n          callback(err, task.data);\n        });\n      } else if (task.operation === 'read') {\n        debug('Reading cache from %s: %s', file, data);\n        fs.readFile(file, {\n          encoding: 'utf8',\n          flag: 'r',\n        }, function(err, data) {\n          if (err && err.code !== 'ENOENT') {\n            done(err);\n            callback(err);\n          } else {\n            debug('Cache has been read from %s: %s', file, data);\n            self.parseAndLoad(data, function(err) {\n              done(err);\n              callback(err);\n            });\n          }\n        });\n      } else {\n        var err = new Error('Unknown type of task');\n        done(err);\n        callback(err);\n      }\n    }, 1);\n  }\n  return this.fileQueue;\n};\n\nMemory.prototype.parseAndLoad = function(data, callback) {\n  if (data) {\n    try {\n      data = JSON.parse(data.toString());\n    } catch (e) {\n      return callback && callback(e);\n    }\n\n    this.ids = data.ids || {};\n    this.cache = data.models || {};\n  } else {\n    if (!this.cache) {\n      this.ids = {};\n      this.cache = {};\n    }\n  }\n  callback && callback();\n};\n\nMemory.prototype.loadFromFile = function(callback) {\n  var hasLocalStorage = typeof window !== 'undefined' && window.localStorage;\n  var localStorage = hasLocalStorage && this.settings.localStorage;\n\n  if (this.settings.file) {\n    debug('Queueing read %s', this.settings.file);\n    this.setupFileQueue().push({\n      operation: 'read',\n      callback: callback,\n    });\n  } else if (localStorage) {\n    var data = window.localStorage.getItem(localStorage);\n    data = data || '{}';\n    this.parseAndLoad(data, callback);\n  } else {\n    process.nextTick(callback);\n  }\n};\n\n/*!\n * Flush the cache into the json file if necessary\n * @param {Function} callback\n */\nMemory.prototype.saveToFile = function(result, callback) {\n  var file = this.settings.file;\n  var hasLocalStorage = typeof window !== 'undefined' && window.localStorage;\n  var localStorage = hasLocalStorage && this.settings.localStorage;\n  if (file) {\n    debug('Queueing write %s', this.settings.file);\n    // Enqueue the write\n    this.setupFileQueue().push({\n      operation: 'write',\n      data: result,\n      callback: callback,\n    });\n  } else if (localStorage) {\n    // Flush out the models/ids\n    var data = JSON.stringify({\n      ids: this.ids,\n      models: this.cache,\n    }, null, '  ');\n    window.localStorage.setItem(localStorage, data);\n    process.nextTick(function() {\n      callback && callback(null, result);\n    });\n  } else {\n    process.nextTick(function() {\n      callback && callback(null, result);\n    });\n  }\n};\n\nMemory.prototype.define = function defineModel(definition) {\n  this.constructor.super_.prototype.define.apply(this, [].slice.call(arguments));\n  var m = definition.model.modelName;\n  if (!this.collection(m)) this.initCollection(m);\n};\n\nMemory.prototype._createSync = function(model, data, fn) {\n  // FIXME: [rfeng] We need to generate unique ids based on the id type\n  // FIXME: [rfeng] We don't support composite ids yet\n  var currentId = this.collectionSeq(model);\n  if (currentId === undefined) { // First time\n    currentId = this.collectionSeq(model, 1);\n  }\n  var id = this.getIdValue(model, data) || currentId;\n  if (id > currentId) {\n    // If the id is passed in and the value is greater than the current id\n    currentId = id;\n  }\n  this.collectionSeq(model, Number(currentId) + 1);\n\n  var props = this._models[model].properties;\n  var idName = this.idName(model);\n  id = (props[idName] && props[idName].type && props[idName].type(id)) || id;\n  this.setIdValue(model, data, id);\n  if (!this.collection(model)) {\n    this.collection(model, {});\n  }\n\n  if (this.collection(model)[id]) {\n    var error = new Error(g.f('Duplicate entry for %s.%s', model, idName));\n    error.statusCode = error.status = 409;\n    return fn(error);\n  }\n\n  this.collection(model)[id] = serialize(data);\n  fn(null, id);\n};\n\nMemory.prototype.create = function create(model, data, options, callback) {\n  var self = this;\n  this._createSync(model, data, function(err, id) {\n    if (err) {\n      return process.nextTick(function() {\n        callback(err);\n      });\n    };\n    self.saveToFile(id, callback);\n  });\n};\n\nMemory.prototype.updateOrCreate = function(model, data, options, callback) {\n  var self = this;\n  this.exists(model, self.getIdValue(model, data), options, function(err, exists) {\n    if (exists) {\n      self.save(model, data, options, function(err, data) {\n        callback(err, data, {isNewInstance: false});\n      });\n    } else {\n      self.create(model, data, options, function(err, id) {\n        self.setIdValue(model, data, id);\n        callback(err, data, {isNewInstance: true});\n      });\n    }\n  });\n};\n\nMemory.prototype.patchOrCreateWithWhere =\nMemory.prototype.upsertWithWhere = function(model, where, data, options, callback) {\n  var self = this;\n  var primaryKey = this.idName(model);\n  var filter = {where: where};\n  var nodes = self._findAllSkippingIncludes(model, filter);\n  if (nodes.length === 0) {\n    return self._createSync(model, data, function(err, id) {\n      if (err) return process.nextTick(function() { callback(err); });\n      self.saveToFile(id, function(err, id) {\n        self.setIdValue(model, data, id);\n        callback(err, self.fromDb(model, data), {isNewInstance: true});\n      });\n    });\n  }\n  if (nodes.length === 1) {\n    var primaryKeyValue = nodes[0][primaryKey];\n    self.updateAttributes(model, primaryKeyValue, data, options, function(err, data) {\n      callback(err, data, {isNewInstance: false});\n    });\n  } else {\n    process.nextTick(function() {\n      var error = new Error('There are multiple instances found.' +\n        'Upsert Operation will not be performed!');\n      error.statusCode = 400;\n      callback(error);\n    });\n  }\n};\n\nMemory.prototype.findOrCreate = function(model, filter, data, callback) {\n  var self = this;\n  var nodes = self._findAllSkippingIncludes(model, filter);\n  var found = nodes[0];\n\n  if (!found) {\n    // Calling _createSync to update the collection in a sync way and to guarantee to create it in the same turn of even loop\n    return self._createSync(model, data, function(err, id) {\n      if (err) return callback(err);\n      self.saveToFile(id, function(err, id) {\n        self.setIdValue(model, data, id);\n        callback(err, data, true);\n      });\n    });\n  }\n\n  if (!filter || !filter.include) {\n    return process.nextTick(function() {\n      callback(null, found, false);\n    });\n  }\n\n  self._models[model].model.include(nodes[0], filter.include, {}, function(err, nodes) {\n    process.nextTick(function() {\n      if (err) return callback(err);\n      callback(null, nodes[0], false);\n    });\n  });\n};\n\nMemory.prototype.save = function save(model, data, options, callback) {\n  var self = this;\n  var id = this.getIdValue(model, data);\n  var cachedModels = this.collection(model);\n  var modelData = cachedModels && this.collection(model)[id];\n  modelData = modelData && deserialize(modelData);\n  if (modelData) {\n    data = merge(modelData, data);\n  }\n  this.collection(model)[id] = serialize(data);\n  this.saveToFile(data, function(err) {\n    callback(err, self.fromDb(model, data), {isNewInstance: !modelData});\n  });\n};\n\nMemory.prototype.exists = function exists(model, id, options, callback) {\n  process.nextTick(function() {\n    callback(null, this.collection(model) && this.collection(model).hasOwnProperty(id));\n  }.bind(this));\n};\n\nMemory.prototype.find = function find(model, id, options, callback) {\n  process.nextTick(function() {\n    callback(null, id in this.collection(model) && this.fromDb(model, this.collection(model)[id]));\n  }.bind(this));\n};\n\nMemory.prototype.destroy = function destroy(model, id, options, callback) {\n  var exists = this.collection(model)[id];\n  delete this.collection(model)[id];\n  this.saveToFile({count: exists ? 1 : 0}, callback);\n};\n\nMemory.prototype.fromDb = function(model, data) {\n  if (!data) return null;\n  data = deserialize(data);\n  var props = this._models[model].properties;\n  for (var key in data) {\n    var val = data[key];\n    if (val === undefined || val === null) {\n      continue;\n    }\n    if (props[key]) {\n      switch (props[key].type.name) {\n        case 'Date':\n          val = new Date(val.toString().replace(/GMT.*$/, 'GMT'));\n          break;\n        case 'Boolean':\n          val = Boolean(val);\n          break;\n        case 'Number':\n          val = Number(val);\n          break;\n      }\n    }\n    data[key] = val;\n  }\n  return data;\n};\n\nfunction getValue(obj, path) {\n  if (obj == null) {\n    return undefined;\n  }\n  var keys = path.split('.');\n  var val = obj;\n  for (var i = 0, n = keys.length; i < n; i++) {\n    val = val[keys[i]];\n    if (val == null) {\n      return val;\n    }\n  }\n  return val;\n}\n\nMemory.prototype._findAllSkippingIncludes = function(model, filter) {\n  var nodes = Object.keys(this.collection(model)).map(function(key) {\n    return this.fromDb(model, this.collection(model)[key]);\n  }.bind(this));\n\n  if (filter) {\n    if (!filter.order) {\n      var idNames = this.idNames(model);\n      if (idNames && idNames.length) {\n        filter.order = idNames;\n      }\n    }\n    // do we need some sorting?\n    if (filter.order) {\n      var orders = filter.order;\n      if (typeof filter.order === 'string') {\n        orders = [filter.order];\n      }\n      orders.forEach(function(key, i) {\n        var reverse = 1;\n        var m = key.match(/\\s+(A|DE)SC$/i);\n        if (m) {\n          key = key.replace(/\\s+(A|DE)SC/i, '');\n          if (m[1].toLowerCase() === 'de') reverse = -1;\n        }\n        orders[i] = {'key': key, 'reverse': reverse};\n      });\n      nodes = nodes.sort(sorting.bind(orders));\n    }\n\n    var nearFilter = geo.nearFilter(filter.where);\n\n    // geo sorting\n    if (nearFilter) {\n      nodes = geo.filter(nodes, nearFilter);\n    }\n\n    // do we need some filtration?\n    if (filter.where && nodes)\n      nodes = nodes.filter(applyFilter(filter));\n\n    // field selection\n    if (filter.fields) {\n      nodes = nodes.map(utils.selectFields(filter.fields));\n    }\n\n    // limit/skip\n    var skip = filter.skip || filter.offset || 0;\n    var limit = filter.limit || nodes.length;\n    nodes = nodes.slice(skip, skip + limit);\n  }\n  return nodes;\n\n  function sorting(a, b) {\n    var undefinedA, undefinedB;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var aVal = getValue(a, this[i].key);\n      var bVal = getValue(b, this[i].key);\n      undefinedB = bVal === undefined && aVal !== undefined;\n      undefinedA = aVal === undefined && bVal !== undefined;\n\n      if (undefinedB || aVal > bVal) {\n        return 1 * this[i].reverse;\n      } else if (undefinedA || aVal < bVal) {\n        return -1 * this[i].reverse;\n      }\n    }\n\n    return 0;\n  }\n};\n\nMemory.prototype.all = function all(model, filter, options, callback) {\n  var self = this;\n  var nodes = self._findAllSkippingIncludes(model, filter);\n\n  process.nextTick(function() {\n    if (filter && filter.include) {\n      self._models[model].model.include(nodes, filter.include, options, callback);\n    } else {\n      callback(null, nodes);\n    }\n  });\n};\n\nfunction applyFilter(filter) {\n  var where = filter.where;\n  if (typeof where === 'function') {\n    return where;\n  }\n  var keys = Object.keys(where);\n  return function(obj) {\n    return keys.every(function(key) {\n      if (key === 'and' || key === 'or') {\n        if (Array.isArray(where[key])) {\n          if (key === 'and') {\n            return where[key].every(function(cond) {\n              return applyFilter({where: cond})(obj);\n            });\n          }\n          if (key === 'or') {\n            return where[key].some(function(cond) {\n              return applyFilter({where: cond})(obj);\n            });\n          }\n        }\n      }\n\n      var value = getValue(obj, key);\n      // Support referencesMany and other embedded relations\n      // Also support array types. Mongo, possibly PostgreSQL\n      if (Array.isArray(value)) {\n        var matcher = where[key];\n        // The following condition is for the case where we are querying with\n        // a neq filter, and when the value is an empty array ([]).\n        if (matcher.neq !== undefined && value.length <= 0) {\n          return true;\n        }\n        return value.some(function(v, i) {\n          var filter = {where: {}};\n          filter.where[i] = matcher;\n          return applyFilter(filter)(value);\n        });\n      }\n\n      if (test(where[key], value)) {\n        return true;\n      }\n\n      // If we have a composed key a.b and b would resolve to a property of an object inside an array\n      // then, we attempt to emulate mongo db matching. Helps for embedded relations\n      var dotIndex = key.indexOf('.');\n      var subValue = obj[key.substring(0, dotIndex)];\n      if (dotIndex !== -1) {\n        var subFilter = {where: {}};\n        var subKey = key.substring(dotIndex + 1);\n        subFilter.where[subKey] = where[key];\n        if (Array.isArray(subValue)) {\n          return subValue.some(applyFilter(subFilter));\n        } else if (typeof subValue === 'object' && subValue !== null) {\n          return applyFilter(subFilter)(subValue);\n        }\n      }\n\n      return false;\n    });\n  };\n\n  function toRegExp(pattern) {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    var regex = '';\n    // Escaping user input to be treated as a literal string within a regular expression\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Writing_a_Regular_Expression_Pattern\n    pattern = pattern.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    for (var i = 0, n = pattern.length; i < n; i++) {\n      var char = pattern.charAt(i);\n      if (char === '\\\\') {\n        i++; // Skip to next char\n        if (i < n) {\n          regex += pattern.charAt(i);\n        }\n        continue;\n      } else if (char === '%') {\n        regex += '.*';\n      } else if (char === '_') {\n        regex += '.';\n      } else if (char === '.') {\n        regex += '\\\\.';\n      } else if (char === '*') {\n        regex += '\\\\*';\n      } else {\n        regex += char;\n      }\n    }\n    return regex;\n  }\n\n  function test(example, value) {\n    if (typeof value === 'string' && (example instanceof RegExp)) {\n      return value.match(example);\n    }\n\n    if (example === undefined) {\n      return undefined;\n    }\n\n    if (typeof example === 'object' && example !== null) {\n      if (example.regexp) {\n        return value ? value.match(example.regexp) : false;\n      }\n\n      // ignore geo near filter\n      if (example.near) {\n        return true;\n      }\n\n      var i;\n      if (example.inq) {\n        // if (!value) return false;\n        for (i = 0; i < example.inq.length; i++) {\n          if (example.inq[i] == value) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      if (example.nin) {\n        for (i = 0; i < example.nin.length; i++) {\n          if (example.nin[i] == value) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      if ('neq' in example) {\n        return compare(example.neq, value) !== 0;\n      }\n\n      if ('between' in example) {\n        return (testInEquality({gte: example.between[0]}, value) &&\n        testInEquality({lte: example.between[1]}, value));\n      }\n\n      if (example.like || example.nlike || example.ilike || example.nilike) {\n        var like = example.like || example.nlike || example.ilike || example.nilike;\n        if (typeof like === 'string') {\n          like = toRegExp(like);\n        }\n        if (example.like) {\n          return !!new RegExp(like).test(value);\n        }\n\n        if (example.nlike) {\n          return !new RegExp(like).test(value);\n        }\n\n        if (example.ilike) {\n          return !!new RegExp(like, 'i').test(value);\n        }\n\n        if (example.nilike) {\n          return !new RegExp(like, 'i').test(value);\n        }\n      }\n\n      if (testInEquality(example, value)) {\n        return true;\n      }\n    }\n    // not strict equality\n    return (example !== null ? example.toString() : example) ==\n      (value != null ? value.toString() : value);\n  }\n\n  /**\n   * Compare two values\n   * @param {*} val1 The 1st value\n   * @param {*} val2 The 2nd value\n   * @returns {number} 0: =, positive: >, negative <\n   * @private\n   */\n  function compare(val1, val2) {\n    if (val1 == null || val2 == null) {\n      // Either val1 or val2 is null or undefined\n      return val1 == val2 ? 0 : NaN;\n    }\n    if (typeof val1 === 'number') {\n      return val1 - val2;\n    }\n    if (typeof val1 === 'string') {\n      return (val1 > val2) ? 1 : ((val1 < val2) ? -1 : (val1 == val2) ? 0 : NaN);\n    }\n    if (typeof val1 === 'boolean') {\n      return val1 - val2;\n    }\n    if (val1 instanceof Date) {\n      var result = val1 - val2;\n      return result;\n    }\n    // Return NaN if we don't know how to compare\n    return (val1 == val2) ? 0 : NaN;\n  }\n\n  function testInEquality(example, val) {\n    if ('gt' in example) {\n      return compare(val, example.gt) > 0;\n    }\n    if ('gte' in example) {\n      return compare(val, example.gte) >= 0;\n    }\n    if ('lt' in example) {\n      return compare(val, example.lt) < 0;\n    }\n    if ('lte' in example) {\n      return compare(val, example.lte) <= 0;\n    }\n    return false;\n  }\n}\n\nMemory.prototype.destroyAll = function destroyAll(model, where, options, callback) {\n  var cache = this.collection(model);\n  var filter = null;\n  var count = 0;\n  if (where) {\n    filter = applyFilter({where: where});\n    Object.keys(cache).forEach(function(id) {\n      if (!filter || filter(this.fromDb(model, cache[id]))) {\n        count++;\n        delete cache[id];\n      }\n    }.bind(this));\n  } else {\n    count = Object.keys(cache).length;\n    this.collection(model, {});\n  }\n  this.saveToFile({count: count}, callback);\n};\n\nMemory.prototype.count = function count(model, where, options, callback) {\n  var cache = this.collection(model);\n  var data = Object.keys(cache);\n  if (where) {\n    var filter = {where: where};\n    data = data.map(function(id) {\n      return this.fromDb(model, cache[id]);\n    }.bind(this));\n    data = data.filter(applyFilter(filter));\n  }\n  process.nextTick(function() {\n    callback(null, data.length);\n  });\n};\n\nMemory.prototype.update =\n  Memory.prototype.updateAll = function updateAll(model, where, data, options, cb) {\n    var self = this;\n    var cache = this.collection(model);\n    var filter = null;\n    where = where || {};\n    filter = applyFilter({where: where});\n\n    var ids = Object.keys(cache);\n    var count = 0;\n    async.each(ids, function(id, done) {\n      var inst = self.fromDb(model, cache[id]);\n      if (!filter || filter(inst)) {\n        count++;\n        // The id value from the cache is string\n        // Get the real id from the inst\n        id = self.getIdValue(model, inst);\n        self.updateAttributes(model, id, data, options, done);\n      } else {\n        process.nextTick(done);\n      }\n    }, function(err) {\n      if (err) return cb(err);\n      self.saveToFile({count: count}, cb);\n    });\n  };\n\nMemory.prototype.updateAttributes = function updateAttributes(model, id, data, options, cb) {\n  if (!id) {\n    var err = new Error(g.f('You must provide an {{id}} when updating attributes!'));\n    if (cb) {\n      return cb(err);\n    } else {\n      throw err;\n    }\n  }\n\n  // Do not modify the data object passed in arguments\n  data = Object.create(data);\n\n  this.setIdValue(model, data, id);\n\n  var cachedModels = this.collection(model);\n  var modelData = cachedModels && this.collection(model)[id];\n\n  if (modelData) {\n    this.save(model, data, options, cb);\n  } else {\n    cb(new Error(g.f('Could not update attributes. {{Object}} with {{id}} %s does not exist!', id)));\n  }\n};\n\nMemory.prototype.replaceById = function(model, id, data, options, cb) {\n  var self = this;\n  if (!id) {\n    var err = new Error(g.f('You must provide an {{id}} when replacing!'));\n    return process.nextTick(function() { cb(err); });\n  }\n  // Do not modify the data object passed in arguments\n  data = Object.create(data);\n  this.setIdValue(model, data, id);\n  var cachedModels = this.collection(model);\n  var modelData = cachedModels && this.collection(model)[id];\n  if (!modelData) {\n    var msg = 'Could not replace. Object with id ' + id + ' does not exist!';\n    var error = new Error(msg);\n    error.statusCode = error.status = 404;\n    return process.nextTick(function() { cb(error); });\n  }\n\n  var newModelData = {};\n  for (var key in data) {\n    var val = data[key];\n    if (typeof val === 'function') {\n      continue; // Skip methods\n    }\n    newModelData[key] = val;\n  }\n\n  this.collection(model)[id] = serialize(newModelData);\n  this.saveToFile(newModelData, function(err) {\n    cb(err, self.fromDb(model, newModelData));\n  });\n};\n\nMemory.prototype.replaceOrCreate = function(model, data, options, callback) {\n  var self = this;\n  var idName = self.idNames(model)[0];\n  var idValue = self.getIdValue(model, data);\n  var filter = {where: {}};\n  filter.where[idName] = idValue;\n  var nodes = self._findAllSkippingIncludes(model, filter);\n  var found = nodes[0];\n\n  if (!found) {\n    // Calling _createSync to update the collection in a sync way and\n    // to guarantee to create it in the same turn of even loop\n    return self._createSync(model, data, function(err, id) {\n      if (err) return process.nextTick(function() { callback(err); });\n      self.saveToFile(id, function(err, id) {\n        self.setIdValue(model, data, id);\n        callback(err, self.fromDb(model, data), {isNewInstance: true});\n      });\n    });\n  }\n  var id = self.getIdValue(model, data);\n  self.collection(model)[id] = serialize(data);\n  self.saveToFile(data, function(err) {\n    callback(err, self.fromDb(model, data), {isNewInstance: false});\n  });\n};\n\nMemory.prototype.transaction = function() {\n  return new Memory(this);\n};\n\nMemory.prototype.exec = function(callback) {\n  this.onTransactionExec();\n  setTimeout(callback, 50);\n};\n\nMemory.prototype.buildNearFilter = function(filter) {\n  // noop\n};\n\nMemory.prototype.automigrate = function(models, cb) {\n  var self = this;\n\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  models = models || Object.keys(self._models);\n  if (models.length === 0) {\n    return process.nextTick(cb);\n  }\n\n  var invalidModels = models.filter(function(m) {\n    return !(m in self._models);\n  });\n\n  if (invalidModels.length) {\n    return process.nextTick(function() {\n      cb(new Error(g.f('Cannot migrate models not attached to this datasource: %s',\n        invalidModels.join(' '))));\n    });\n  }\n\n  models.forEach(function(m) {\n    self.initCollection(m);\n  });\n  if (cb) process.nextTick(cb);\n};\n\nfunction merge(base, update) {\n  if (!base) {\n    return update;\n  }\n  // We cannot use Object.keys(update) if the update is an instance of the model\n  // class as the properties are defined at the ModelClass.prototype level\n  for (var key in update) {\n    var val = update[key];\n    if (typeof val === 'function') {\n      continue; // Skip methods\n    }\n    base[key] = val;\n  }\n  return base;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/index.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar SG = require('strong-globalize');\nSG.SetRootDir(__dirname);\n\nexports.Connector = require('./lib/connector');\n// Set up SqlConnector as an alias to SQLConnector\nexports.SQLConnector = exports.SqlConnector = require('./lib/sql');\nexports.ParameterizedSQL = exports.SQLConnector.ParameterizedSQL;\nexports.Transaction = require('./lib/transaction');\n\nexports.createPromiseCallback = require('./lib/utils').createPromiseCallback;\n\n// KeyValue helpers\nexports.ModelKeyComposer = require('./lib/model-key-composer');\nexports.BinaryPacker = require('./lib/binary-packer');\nexports.JSONStringPacker = require('./lib/json-string-packer');\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/connector.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar SG = require('strong-globalize');\nvar g = SG();\nvar debug = require('debug')('loopback:connector');\n\nmodule.exports = Connector;\n\n/**\n * Base class for LoopBack connector. This is more a collection of useful\n * methods for connectors than a super class\n * @constructor\n */\nfunction Connector(name, settings) {\n  this._models = {};\n  this.name = name;\n  this.settings = settings || {};\n}\n\n/**\n * Set the relational property to indicate the backend is a relational DB\n * @type {boolean}\n */\nConnector.prototype.relational = false;\n\n/**\n * Check if the connector is for a relational DB\n * @returns {Boolean} true for relational DB\n */\nConnector.prototype.isRelational = function() {\n  return this.isRelational ||\n    (this.getTypes().indexOf('rdbms') !== -1);\n};\n\n/**\n * Get types associated with the connector\n * @returns {String[]} The types for the connector\n */\nConnector.prototype.getTypes = function() {\n  return ['db', 'nosql'];\n};\n\n/**\n * Get the default data type for ID\n * @param prop Property definition\n * @returns {Function} The default type for ID\n */\nConnector.prototype.getDefaultIdType = function(prop) {\n  /* jshint unused:false */\n  return String;\n};\n\n/**\n * Generate random id.  Each data source model must override this method.\n * @param {String} modelName Model name\n * @returns {<model dependent>} Data type varies from model to model,\n */\n\nConnector.prototype.generateUniqueId = function(modelName) {\n  var idType = this.getDefaultIdType && this.getDefaultIdType();\n  var isTypeFunction = (typeof idType === 'function');\n  var id = this.generateValueByColumnType ? this.generateValueByColumnType(idType) :\n    (typeof idType === 'function' ? idType() : null);\n  return id;\n};\n\n/**\n * Get the metadata for the connector\n * @returns {Object} The metadata object\n * @property {String} type The type for the backend\n * @property {Function} defaultIdType The default id type\n * @property {Boolean} [isRelational] If the connector represents a relational\n * database\n * @property {Object} schemaForSettings The schema for settings object\n */\nConnector.prototype.getMetadata = function() {\n  if (!this._metadata) {\n    this._metadata = {\n      types: this.getTypes(),\n      defaultIdType: this.getDefaultIdType(),\n      isRelational: this.isRelational(),\n      schemaForSettings: {},\n    };\n  }\n  return this._metadata;\n};\n\n/**\n * Execute a command with given parameters\n * @param {String|Object} command The command such as SQL\n * @param {*[]} [params] An array of parameter values\n * @param {Object} [options] Options object\n * @param {Function} [callback] The callback function\n */\nConnector.prototype.execute = function(command, params, options, callback) {\n  throw new Error(g.f('execute() must be implemented by the connector'));\n};\n\n/**\n * Get the model definition by name\n * @param {String} modelName The model name\n * @returns {ModelDefinition} The model definition\n */\nConnector.prototype.getModelDefinition = function(modelName) {\n  return this._models[modelName];\n};\n\n/**\n * Get connector specific settings for a given model, for example,\n * ```\n * {\n *   \"postgresql\": {\n *     \"schema\": \"xyz\"\n *   }\n * }\n * ```\n *\n * @param {String} modelName Model name\n * @returns {Object} The connector specific settings\n */\nConnector.prototype.getConnectorSpecificSettings = function(modelName) {\n  var settings = this.getModelDefinition(modelName).settings || {};\n  return settings[this.name];\n};\n\n/**\n * Get model property definition\n * @param {String} modelName Model name\n * @param {String} propName Property name\n * @returns {Object} Property definition\n */\nConnector.prototype.getPropertyDefinition = function(modelName, propName) {\n  var model = this.getModelDefinition(modelName);\n  return model && model.properties[propName];\n};\n\n/**\n * Look up the data source by model name\n * @param {String} model The model name\n * @returns {DataSource} The data source\n */\nConnector.prototype.getDataSource = function(model) {\n  var m = this.getModelDefinition(model);\n  if (!m) {\n    debug('Model not found: ' + model);\n  }\n  return m && m.model.dataSource;\n};\n\n/**\n * Get the id property name\n * @param {String} model The model name\n * @returns {String} The id property name\n */\nConnector.prototype.idName = function(model) {\n  return this.getDataSource(model).idName(model);\n};\n\n/**\n * Get the id property names\n * @param {String} model The model name\n * @returns {[String]} The id property names\n */\nConnector.prototype.idNames = function(model) {\n  return this.getDataSource(model).idNames(model);\n};\n\n/**\n * Get the id index (sequence number, starting from 1)\n * @param {String} model The model name\n * @param {String} prop The property name\n * @returns {Number} The id index, undefined if the property is not part\n *   of the primary key\n */\nConnector.prototype.id = function(model, prop) {\n  var p = this.getModelDefinition(model).properties[prop];\n  return p && p.id;\n};\n\n/**\n * Hook to be called by DataSource for defining a model\n * @param {Object} modelDefinition The model definition\n */\nConnector.prototype.define = function(modelDefinition) {\n  modelDefinition.settings = modelDefinition.settings || {};\n  this._models[modelDefinition.model.modelName] = modelDefinition;\n};\n\n/**\n * Hook to be called by DataSource for defining a model property\n * @param {String} model The model name\n * @param {String} propertyName The property name\n * @param {Object} propertyDefinition The object for property definition\n */\nConnector.prototype.defineProperty = function(model, propertyName, propertyDefinition) {\n  var modelDef = this.getModelDefinition(model);\n  modelDef.properties[propertyName] = propertyDefinition;\n};\n\n/**\n * Disconnect from the connector\n * @param {Function} [cb] Callback function\n */\nConnector.prototype.disconnect = function disconnect(cb) {\n  // NO-OP\n  if (cb) {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Get the id value for the given model\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @returns {*} The id value\n *\n */\nConnector.prototype.getIdValue = function(model, data) {\n  return data && data[this.idName(model)];\n};\n\n/**\n * Set the id value for the given model\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @param {*} value The id value\n *\n */\nConnector.prototype.setIdValue = function(model, data, value) {\n  if (data) {\n    data[this.idName(model)] = value;\n  }\n};\n\n/**\n * Test if a property is nullable\n * @param {Object} prop The property definition\n * @returns {boolean} true if nullable\n */\nConnector.prototype.isNullable = function(prop) {\n  if (prop.required || prop.id) {\n    return false;\n  }\n  if (prop.nullable || prop['null'] || prop.allowNull) {\n    return true;\n  }\n  if (prop.nullable === false || prop['null'] === false ||\n    prop.allowNull === false) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Return the DataAccessObject interface implemented by the connector\n * @returns {Object} An object containing all methods implemented by the\n * connector that can be mixed into the model class. It should be considered as\n * the interface.\n */\nConnector.prototype.getDataAccessObject = function() {\n  return this.DataAccessObject;\n};\n\n/*!\n * Define aliases to a prototype method/property\n * @param {Function} cls The class that owns the method/property\n * @param {String} methodOrPropertyName The official property method/property name\n * @param {String|String[]} aliases Aliases to the official property/method\n */\nConnector.defineAliases = function(cls, methodOrPropertyName, aliases) {\n  if (typeof aliases === 'string') {\n    aliases = [aliases];\n  }\n  if (Array.isArray(aliases)) {\n    aliases.forEach(function(alias) {\n      if (typeof alias === 'string') {\n        Object.defineProperty(cls, alias, {\n          get: function() {\n            return this[methodOrPropertyName];\n          },\n        });\n      }\n    });\n  }\n};\n\n/**\n * `command()` and `query()` are aliases to `execute()`\n */\nConnector.defineAliases(Connector.prototype, 'execute', ['command', 'query']);\n\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/sql.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar SG = require('strong-globalize');\nvar g = SG();\n\nvar util = require('util');\nvar async = require('async');\nvar assert = require('assert');\nvar Connector = require('./connector');\nvar debug = require('debug')('loopback:connector:sql');\nvar ParameterizedSQL = require('./parameterized-sql');\nvar Transaction = require('./transaction');\n\nmodule.exports = SQLConnector;\n\nfunction NOOP() {}\n\n/**\n * Base class for connectors that connect to relational databases using SQL\n * @class\n */\nfunction SQLConnector() {\n  // Call the super constructor\n  Connector.apply(this, [].slice.call(arguments));\n}\n\n// Inherit from the base Connector\nutil.inherits(SQLConnector, Connector);\n\n// Export ParameterizedSQL\nSQLConnector.ParameterizedSQL = ParameterizedSQL;\n\n// The generic placeholder\nvar PLACEHOLDER = SQLConnector.PLACEHOLDER = ParameterizedSQL.PLACEHOLDER;\n\nSQLConnector.Transaction = Transaction;\n\n/**\n * Set the relational property to indicate the backend is a relational DB\n * @type {boolean}\n */\nSQLConnector.prototype.relational = true;\n\n/**\n * Invoke a prototype method on the super class\n * @param {String} methodName Method name\n */\nSQLConnector.prototype.invokeSuper = function(methodName) {\n  var args = [].slice.call(arguments, 1);\n  var superMethod = this.constructor.super_.prototype[methodName];\n  return superMethod.apply(this, args);\n};\n\n/**\n * Perform autoupdate for the given models\n * @param {String[]} [models] A model name or an array of model names.\n * If not present, apply to all models\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.autoupdate = function(models, cb) {\n  var self = this;\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  models = models || Object.keys(this._models);\n\n  async.each(models, function(model, done) {\n    if (!(model in self._models)) {\n      return process.nextTick(function() {\n        done(new Error(g.f('Model not found: %s', model)));\n      });\n    }\n    self.getTableStatus(model, function(err, fields, indexes, FKs) {\n      if (!err && fields.length) {\n        self.alterTable(model, fields, indexes, done);\n      } else {\n        self.createTable(model, done);\n      }\n    });\n  }, cb);\n};\n\n/**\n * Check if the models exist\n * @param {String[]} [models] A model name or an array of model names.\n * If not present, apply to all models\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.isActual = function(models, cb) {\n  var self = this;\n\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  models = models || Object.keys(this._models);\n\n  var changes = [];\n  async.each(models, function(model, done) {\n    self.getTableStatus(model, function(err, fields) {\n      changes = changes.concat(self.getAddModifyColumns(model, fields));\n      changes = changes.concat(self.getDropColumns(model, fields));\n      done(err);\n    });\n  }, function done(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    var actual = (changes.length === 0);\n    if (cb) cb(null, actual);\n  });\n};\n\nSQLConnector.prototype.getAddModifyColumns = function(model, fields) {\n  var sql = [];\n  var self = this;\n  sql = sql.concat(self.getColumnsToAdd(model, fields));\n  return sql;\n};\n\nSQLConnector.prototype.getColumnsToAdd = function(model, fields) {\n  throw new Error(g.f('{{getColumnsToAdd()}} must be implemented by the connector'));\n};\n\nSQLConnector.prototype.getDropColumns = function(model, fields) {\n  var sql = [];\n  var self = this;\n  sql = sql.concat(self.getColumnsToDrop(model, fields));\n  return sql;\n};\n\nSQLConnector.prototype.getColumnsToDrop = function(model, fields) {\n  throw new Error(g.f('{{getColumnsToDrop()}} must be implemented by the connector'));\n};\n\nSQLConnector.prototype.searchForPropertyInActual = function(model, propName,\n  actualFields) {\n  var self = this;\n  var found = false;\n  actualFields.forEach(function(f) {\n    if (f.column === self.column(model, propName)) {\n      found = f;\n      return;\n    }\n  });\n  return found;\n};\n\nSQLConnector.prototype.addPropertyToActual = function(model, propName) {\n  var self = this;\n  var sqlCommand = self.columnEscaped(model, propName) +\n    ' ' + self.columnDataType(model, propName) +\n    (self.isNullable(self.getPropertyDefinition(model, propName)) ?\n    '' : ' NOT NULL');\n  return sqlCommand;\n};\n\nSQLConnector.prototype.columnDataType = function(model, property) {\n  var columnMetadata = this.columnMetadata(model, property);\n  var colType = columnMetadata && columnMetadata.dataType;\n  if (colType) {\n    colType = colType.toUpperCase();\n  }\n  var prop = this.getModelDefinition(model).properties[property];\n  if (!prop) {\n    return null;\n  }\n  var colLength = columnMetadata && columnMetadata.dataLength ||\n    prop.length || prop.limit;\n  if (colType && colLength) {\n    return colType + '(' + colLength + ')';\n  }\n  return this.buildColumnType(prop);\n};\n\nSQLConnector.prototype.buildColumnType = function(property) {\n  throw new Error(g.f('{{buildColumnType()}} must be implemented by the connector'));\n};\n\nSQLConnector.prototype.propertyHasNotBeenDeleted = function(model, propName) {\n  return !!this.getModelDefinition(model).properties[propName];\n};\n\nSQLConnector.prototype.applySqlChanges = function(model, pendingChanges, cb) {\n  var self = this;\n  if (pendingChanges.length) {\n    var thisQuery = 'ALTER TABLE ' + self.tableEscaped(model);\n    var ranOnce = false;\n    pendingChanges.forEach(function(change) {\n      if (ranOnce) {\n        thisQuery = thisQuery + ' ';\n      }\n      thisQuery = thisQuery + ' ' + change;\n      ranOnce = true;\n    });\n    self.execute(thisQuery, cb);\n  }\n};\n\n/**\n * Alters a table\n * @param {String} model The model name\n * @param {Object} fields Fields of the table\n * @param {Object} indexes Indexes of the table\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.alterTable = function(model, fields, indexes, cb) {\n  throw new Error(g.f('{{alterTable()}} must be implemented by the connector'));\n};\n\nSQLConnector.prototype.checkFieldAndIndex = function(fields, indexes) {\n  return true;\n};\n\n/**\n * Get the status of a table\n * @param {String} model The model name\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.getTableStatus = function(model, cb) {\n  var fields, indexes;\n  var self = this;\n\n  this.showFields(model, function(err, data) {\n    if (err) return cb(err);\n    fields = data;\n\n    self.showIndexes(model, function(err, data) {\n      if (err) return cb(err);\n      indexes = data;\n\n      if (self.checkFieldAndIndex(fields, indexes))\n        return cb(null, fields, indexes);\n    });\n  });\n};\n\n/**\n * Get fields from a table\n * @param {String} model The model name\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.showFields = function(model, cb) {\n  throw new Error(g.f('{{showFields()}} must be implemented by the connector'));\n};\n\n/**\n * Get indexes from a table\n * @param {String} model The model name\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.showIndexes = function(model, cb) {\n  throw new Error(g.f('{{showIndexes()}} must be implemented by the connector'));\n};\n\n/**\n * Get types associated with the connector\n * Returns {String[]} The types for the connector\n */\nSQLConnector.prototype.getTypes = function() {\n  return ['db', 'rdbms', 'sql'];\n};\n\n/**\n * Get the default data type for ID\n * @param prop Property definition\n * Returns {Function}\n */\nSQLConnector.prototype.getDefaultIdType = function(prop) {\n  return Number;\n};\n\n/**\n * Get the default database schema name\n * @returns {string} The default schema name, such as 'public' or 'dbo'\n */\nSQLConnector.prototype.getDefaultSchemaName = function() {\n  return '';\n};\n\n/**\n * Get the database schema name for the given model. The schema name can be\n * customized at model settings or connector configuration level as `schema` or\n * `schemaName`. For example,\n *\n * ```json\n * \"Customer\": {\n *   \"name\": \"Customer\",\n *   \"mysql\": {\n *     \"schema\": \"MYDB\",\n *     \"table\": \"CUSTOMER\"\n *   }\n * }\n * ```\n *\n * @param {String} model The model name\n * @returns {String} The database schema name\n */\nSQLConnector.prototype.schema = function(model) {\n  // Check if there is a 'schema' property for connector\n  var dbMeta = this.getConnectorSpecificSettings(model);\n  var schemaName = (dbMeta && (dbMeta.schema || dbMeta.schemaName)) ||\n    (this.settings.schema || this.settings.schemaName) ||\n    this.getDefaultSchemaName();\n  return schemaName;\n};\n\n/**\n * Get the table name for the given model. The table name can be customized\n * at model settings as `table` or `tableName`. For example,\n *\n * ```json\n * \"Customer\": {\n *   \"name\": \"Customer\",\n *   \"mysql\": {\n *     \"table\": \"CUSTOMER\"\n *   }\n * }\n * ```\n *\n * Returns the table name (String).\n * @param {String} model The model name\n */\nSQLConnector.prototype.table = function(model) {\n  var dbMeta = this.getConnectorSpecificSettings(model);\n  var tableName;\n  if (dbMeta) {\n    tableName = dbMeta.table || dbMeta.tableName;\n    if (tableName) {\n      // Explicit table name, return as-is\n      return tableName;\n    }\n  }\n  tableName = model;\n  if (typeof this.dbName === 'function') {\n    tableName = this.dbName(tableName);\n  }\n  return tableName;\n};\n\n/**\n * Get the column name for the given model property. The column name can be\n * customized at the model property definition level as `column` or\n * `columnName`. For example,\n *\n * ```json\n * \"name\": {\n *   \"type\": \"string\",\n *   \"mysql\": {\n *     \"column\": \"NAME\"\n *   }\n * }\n * ```\n *\n * @param {String} model The model name\n * @param {String} property The property name\n * @returns {String} The column name\n */\nSQLConnector.prototype.column = function(model, property) {\n  var prop = this.getPropertyDefinition(model, property);\n  var columnName;\n  if (prop && prop[this.name]) {\n    columnName = prop[this.name].column || prop[this.name].columnName;\n    if (columnName) {\n      // Explicit column name, return as-is\n      return columnName;\n    }\n  }\n  columnName = property;\n  if (typeof this.dbName === 'function') {\n    columnName = this.dbName(columnName);\n  }\n  return columnName;\n};\n\n/**\n * Get the column metadata for the given model property\n * @param {String} model The model name\n * @param {String} property The property name\n * @returns {Object} The column metadata\n */\nSQLConnector.prototype.columnMetadata = function(model, property) {\n  return this.getDataSource(model).columnMetadata(model, property);\n};\n\n/**\n * Get the corresponding property name for the given column name\n * @param {String} model The model name\n * @param {String} column The column name\n * @returns {String} The property name for a given column\n */\nSQLConnector.prototype.propertyName = function(model, column) {\n  var props = this.getModelDefinition(model).properties;\n  for (var p in props) {\n    if (this.column(model, p) === column) {\n      return p;\n    }\n  }\n  return null;\n};\n\n/**\n * Get the id column name\n * @param {String} model The model name\n * @returns {String} The id column name\n */\nSQLConnector.prototype.idColumn = function(model) {\n  var name = this.getDataSource(model).idColumnName(model);\n  var dbName = this.dbName;\n  if (typeof dbName === 'function') {\n    name = dbName(name);\n  }\n  return name;\n};\n\n/**\n * Get the escaped id column name\n * @param {String} model The model name\n * @returns {String} the escaped id column name\n */\nSQLConnector.prototype.idColumnEscaped = function(model) {\n  return this.escapeName(this.idColumn(model));\n};\n\n/**\n * Get the escaped table name\n * @param {String} model The model name\n * @returns {String} the escaped table name\n */\nSQLConnector.prototype.tableEscaped = function(model) {\n  return this.escapeName(this.table(model));\n};\n\n/**\n * Get the escaped column name for a given model property\n * @param {String} model The model name\n * @param {String} property The property name\n * @returns {String} The escaped column name\n */\nSQLConnector.prototype.columnEscaped = function(model, property) {\n  return this.escapeName(this.column(model, property));\n};\n\n/*!\n * Check if id value is set\n * @param idValue\n * @param cb\n * @param returningNull\n * @returns {boolean}\n */\nfunction isIdValuePresent(idValue, cb, returningNull) {\n  try {\n    assert(idValue !== null && idValue !== undefined, 'id value is required');\n    return true;\n  } catch (err) {\n    process.nextTick(function() {\n      if (cb) cb(returningNull ? null : err);\n    });\n    return false;\n  }\n}\n\n/**\n * Convert the id value to the form required by database column\n * @param {String} model The model name\n * @param {*} idValue The id property value\n * @returns {*} The escaped id column value\n */\nSQLConnector.prototype.idColumnValue = function(model, idValue) {\n  var idProp = this.getDataSource(model).idProperty(model);\n  if (typeof this.toColumnValue === 'function') {\n    return this.toColumnValue(idProp, idValue);\n  } else {\n    return idValue;\n  }\n};\n\n/**\n * Replace `?` with connector specific placeholders. For example,\n *\n * ```\n * {sql: 'SELECT * FROM CUSTOMER WHERE NAME=?', params: ['John']}\n * ==>\n * {sql: 'SELECT * FROM CUSTOMER WHERE NAME=:1', params: ['John']}\n * ```\n * *LIMITATION*: We don't handle the ? inside escaped values, for example,\n * `SELECT * FROM CUSTOMER WHERE NAME='J?hn'` will not be parameterized\n * correctly.\n *\n * @param {ParameterizedSQL|Object} ps Parameterized SQL\n * @returns {ParameterizedSQL} Parameterized SQL with the connector specific\n * placeholders\n */\nSQLConnector.prototype.parameterize = function(ps) {\n  ps = new ParameterizedSQL(ps);\n\n  // The value is parameterized, for example\n  // {sql: 'to_point(?,?)', values: [1, 2]}\n  var parts = ps.sql.split(PLACEHOLDER);\n  var clause = [];\n  for (var j = 0, m = parts.length; j < m; j++) {\n    // Replace ? with the keyed placeholder, such as :5\n    clause.push(parts[j]);\n    if (j !== parts.length - 1) {\n      clause.push(this.getPlaceholderForValue(j + 1));\n    }\n  }\n  ps.sql = clause.join('');\n  return ps;\n};\n\n/**\n * Build the the `INSERT INTO` statement\n * @param {String} model The model name\n * @param {Object} fields Fields to be inserted\n * @param {Object} options Options object\n * @returns {ParameterizedSQL}\n */\nSQLConnector.prototype.buildInsertInto = function(model, fields, options) {\n  var stmt = new ParameterizedSQL('INSERT INTO ' + this.tableEscaped(model));\n  var columnNames = fields.names.join(',');\n  if (columnNames) {\n    stmt.merge('(' + columnNames + ')', '');\n  }\n  return stmt;\n};\n\n/**\n * Build the clause to return id values after insert\n * @param {String} model The model name\n * @param {Object} data The model data object\n * @param {Object} options Options object\n * @returns {string}\n */\nSQLConnector.prototype.buildInsertReturning = function(model, data, options) {\n  return '';\n};\n\n/**\n * Build the clause for default values if the fields is empty\n * @param {String} model The model name\n * @param {Object} data The model data object\n * @param {Object} options Options object\n * @returns {string} 'DEFAULT VALUES'\n */\nSQLConnector.prototype.buildInsertDefaultValues = function(model, data, options) {\n  return 'VALUES()';\n};\n\n/**\n * Build INSERT SQL statement\n * @param {String} model The model name\n * @param {Object} data The model data object\n * @param {Object} options The options object\n * @returns {string} The INSERT SQL statement\n */\nSQLConnector.prototype.buildInsert = function(model, data, options) {\n  var fields = this.buildFields(model, data);\n  var insertStmt = this.buildInsertInto(model, fields, options);\n  var columnValues = fields.columnValues;\n  var fieldNames = fields.names;\n  if (fieldNames.length) {\n    var values = ParameterizedSQL.join(columnValues, ',');\n    values.sql = 'VALUES(' + values.sql + ')';\n    insertStmt.merge(values);\n  } else {\n    insertStmt.merge(this.buildInsertDefaultValues(model, data, options));\n  }\n  var returning = this.buildInsertReturning(model, data, options);\n  if (returning) {\n    insertStmt.merge(returning);\n  }\n  return this.parameterize(insertStmt);\n};\n\n/**\n * Execute a SQL statement with given parameters.\n *\n * @param {String} sql The SQL statement\n * @param {*[]} [params] An array of parameter values\n * @param {Object} [options] Options object\n * @param {Function} [callback] The callback function\n */\nSQLConnector.prototype.execute = function(sql, params, options, callback) {\n  assert(typeof sql === 'string', 'sql must be a string');\n  if (typeof params === 'function' && options === undefined &&\n    callback === undefined) {\n    // execute(sql, callback)\n    options = {};\n    callback = params;\n    params = [];\n  } else if (typeof options === 'function' && callback === undefined) {\n    // execute(sql, params, callback)\n    callback = options;\n    options = {};\n  }\n  params = params || [];\n  options = options || {};\n  assert(Array.isArray(params), 'params must be an array');\n  assert(typeof options === 'object', 'options must be an object');\n  assert(typeof callback === 'function', 'callback must be a function');\n\n  var self = this;\n  if (!this.dataSource.connected) {\n    return this.dataSource.once('connected', function() {\n      self.execute(sql, params, options, callback);\n    });\n  }\n  var context = {\n    req: {\n      sql: sql,\n      params: params,\n    },\n    options: options,\n  };\n  this.notifyObserversAround('execute', context, function(context, done) {\n    self.executeSQL(context.req.sql, context.req.params, context.options,\n    function(err, info) {\n      if (err) {\n        debug('Error: %j %j %j', err, context.req.sql, context.req.params);\n      }\n\n      if (!err && info != null) {\n        context.res = info;\n      }\n      // Don't pass more than one args as it will confuse async.waterfall\n      done(err, info);\n    });\n  }, callback);\n};\n\n/**\n * Create the data model in MySQL\n *\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @param {Object} options Options object\n * @param {Function} [callback] The callback function\n */\nSQLConnector.prototype.create = function(model, data, options, callback) {\n  var self = this;\n  var stmt = this.buildInsert(model, data, options);\n  this.execute(stmt.sql, stmt.params, options, function(err, info) {\n    if (err) {\n      callback(err);\n    } else {\n      var insertedId = self.getInsertedId(model, info);\n      callback(err, insertedId);\n    }\n  });\n};\n\n/**\n * Save the model instance into the database\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @param {Object} options Options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.save = function(model, data, options, cb) {\n  var idName = this.idName(model);\n  var idValue = data[idName];\n\n  if (!isIdValuePresent(idValue, cb)) {\n    return;\n  }\n\n  var where = {};\n  where[idName] = idValue;\n\n  var updateStmt = new ParameterizedSQL('UPDATE ' + this.tableEscaped(model));\n  updateStmt.merge(this.buildFieldsForUpdate(model, data));\n  var whereStmt = this.buildWhere(model, where);\n  updateStmt.merge(whereStmt);\n  updateStmt = this.parameterize(updateStmt);\n  this.execute(updateStmt.sql, updateStmt.params, options,\n    function(err, result) {\n      if (cb) cb(err, result);\n    });\n};\n\n/**\n * Check if a model instance exists for the given id value\n * @param {String} model The model name\n * @param {*} id The id value\n * @param {Object} options Options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.exists = function(model, id, options, cb) {\n  if (!isIdValuePresent(id, cb, true)) {\n    return;\n  }\n  var idName = this.idName(model);\n  var where = {};\n  where[idName] = id;\n  var selectStmt = new ParameterizedSQL(\n    'SELECT 1 FROM ' + this.tableEscaped(model) +\n    ' WHERE ' + this.idColumnEscaped(model)\n  );\n  selectStmt.merge(this.buildWhere(model, where));\n  selectStmt = this.applyPagination(model, selectStmt, {\n    limit: 1,\n    offset: 0,\n    order: [idName],\n  });\n  selectStmt = this.parameterize(selectStmt);\n\n  this.execute(selectStmt.sql, selectStmt.params, options, function(err, data) {\n    if (!cb) return;\n    if (err) {\n      cb(err);\n    } else {\n      cb(null, data.length >= 1);\n    }\n  });\n};\n\n/**\n * ATM, this method is not used by loopback-datasource-juggler dao, which\n * maps `destroy` to `destroyAll` with a `where` filter that includes the `id`\n * instead.\n *\n * Delete a model instance by id value\n * @param {String} model The model name\n * @param {*} id The id value\n * @param {Object} options Options object\n * @param {Function} cb The callback function\n * @private\n */\nSQLConnector.prototype.destroy = function(model, id, options, cb) {\n  if (!isIdValuePresent(id, cb, true)) {\n    return;\n  }\n  var idName = this.idName(model);\n  var where = {};\n  where[idName] = id;\n  this.destroyAll(model, where, options, cb);\n};\n\n// Alias to `destroy`. Juggler checks `destroy` only.\nConnector.defineAliases(SQLConnector.prototype, 'destroy',\n  ['delete', 'deleteById', 'destroyById']);\n\n/**\n * Build the `DELETE FROM` SQL statement\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} options Options object\n * @returns {ParameterizedSQL} The SQL DELETE FROM statement\n */\nSQLConnector.prototype.buildDelete = function(model, where, options) {\n  var deleteStmt = new ParameterizedSQL('DELETE FROM ' +\n    this.tableEscaped(model));\n  deleteStmt.merge(this.buildWhere(model, where));\n  return this.parameterize(deleteStmt);\n};\n\n/**\n * Delete all matching model instances\n *\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.destroyAll = function(model, where, options, cb) {\n  var stmt = this.buildDelete(model, where, options);\n  this._executeAlteringQuery(model, stmt.sql, stmt.params, options, cb || NOOP);\n};\n\n// Alias to `destroyAll`. Juggler checks `destroyAll` only.\nConnector.defineAliases(SQLConnector.prototype, 'destroyAll', ['deleteAll']);\n\n/**\n * ATM, this method is not used by loopback-datasource-juggler dao, which\n * maps `updateAttributes` to `update` with a `where` filter that includes the\n * `id` instead.\n *\n * Update attributes for a given model instance\n * @param {String} model The model name\n * @param {*} id The id value\n * @param {Object} data The model data instance containing all properties to\n * be updated\n * @param {Object} options Options object\n * @param {Function} cb The callback function\n * @private\n */\nSQLConnector.prototype.updateAttributes = function(model, id, data, options, cb) {\n  if (!isIdValuePresent(id, cb)) return;\n  var where = this._buildWhereObjById(model, id, data);\n  this.updateAll(model, where, data, options, cb);\n};\n\n/**\n * Replace attributes for a given model instance\n * @param {String} model The model name\n * @param {*} id The id value\n * @param {Object} data The model data instance containing all properties to\n * be replaced\n * @param {Object} options Options object\n * @param {Function} cb The callback function\n * @private\n */\nSQLConnector.prototype.replaceById = function(model, id, data, options, cb) {\n  if (!isIdValuePresent(id, cb)) return;\n  var where = this._buildWhereObjById(model, id, data);\n  this._replace(model, where, data, options, cb);\n};\n\n/*\n * @param model The model name.\n * @param id The instance ID.\n * @param {Object} data The data Object.\n * @returns {Object} where The where object for a spcific instance.\n * @private\n */\nSQLConnector.prototype._buildWhereObjById = function(model, id, data) {\n  var idName = this.idName(model);\n  delete data[idName];\n  var where = {};\n  where[idName] = id;\n  return where;\n};\n\n/**\n * Build the UPDATE statement\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} data The data to be changed\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n * @returns {ParameterizedSQL} The UPDATE SQL statement\n */\nSQLConnector.prototype.buildUpdate = function(model, where, data, options) {\n  var fields = this.buildFieldsForUpdate(model, data);\n  return this._constructUpdateQuery(model, where, fields);\n};\n\n/**\n * Build the UPDATE statement for replacing\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} data The data to be changed\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n * @returns {ParameterizedSQL} The UPDATE SQL statement for replacing fields\n */\nSQLConnector.prototype.buildReplace = function(model, where, data, options) {\n  var fields = this.buildFieldsForReplace(model, data);\n  return this._constructUpdateQuery(model, where, fields);\n};\n\n/*\n * @param model The model name.\n * @param {} where The where object.\n * @param {Object} field The parameterizedSQL fileds.\n * @returns {Object} update query Constructed update query.\n * @private\n */\nSQLConnector.prototype._constructUpdateQuery = function(model, where, fields) {\n  var updateClause = new ParameterizedSQL('UPDATE ' + this.tableEscaped(model));\n  var whereClause = this.buildWhere(model, where);\n  updateClause.merge([fields, whereClause]);\n  return this.parameterize(updateClause);\n};\n\n/**\n * Update all instances that match the where clause with the given data\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} data The property/value object representing changes\n * to be made\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.update = function(model, where, data, options, cb) {\n  var stmt = this.buildUpdate(model, where, data, options);\n  this._executeAlteringQuery(model, stmt.sql, stmt.params, options, cb || NOOP);\n};\n\n/**\n * Replace all instances that match the where clause with the given data\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} data The property/value object representing changes\n * to be made\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype._replace = function(model, where, data, options, cb) {\n  var self = this;\n  var stmt = this.buildReplace(model, where, data, options);\n  this.execute(stmt.sql, stmt.params, options, function(err, info) {\n    if (err) return cb(err);\n    var affectedRows = self.getCountForAffectedRows(model, info);\n    var rowCount = typeof (affectedRows) === 'number' ?\n      affectedRows : info.affectedRows;\n    if (rowCount === 0) {\n      return cb(errorIdNotFoundForReplace(where.id));\n    } else {\n      return cb(null, info);\n    }\n  });\n};\n\nfunction errorIdNotFoundForReplace(idValue) {\n  var msg = g.f('Could not replace. Object with id %s does not exist!', idValue);\n  var error = new Error(msg);\n  error.statusCode = error.status = 404;\n  return error;\n}\n\nSQLConnector.prototype._executeAlteringQuery = function(model, sql, params, options, cb) {\n  var self = this;\n  this.execute(sql, params, options, function(err, info) {\n    var affectedRows = self.getCountForAffectedRows(model, info);\n    cb(err, {count: affectedRows});\n  });\n};\n\n// Alias to `update` and `replace`. Juggler checks `update` and `replace` only.\nConnector.defineAliases(SQLConnector.prototype, 'update', ['updateAll']);\nConnector.defineAliases(SQLConnector.prototype, 'replace', ['replaceAll']);\n\n/**\n * Build the SQL WHERE clause for the where object\n * @param {string} model Model name\n * @param {object} where An object for the where conditions\n * @returns {ParameterizedSQL} The SQL WHERE clause\n */\nSQLConnector.prototype.buildWhere = function(model, where) {\n  var whereClause = this._buildWhere(model, where);\n  if (whereClause.sql) {\n    whereClause.sql = 'WHERE ' + whereClause.sql;\n  }\n  return whereClause;\n};\n\n/**\n * Build SQL expression\n * @param {String} columnName Escaped column name\n * @param {String} operator SQL operator\n * @param {*} columnValue Column value\n * @param {*} propertyValue Property value\n * @returns {ParameterizedSQL} The SQL expression\n */\nSQLConnector.prototype.buildExpression =\nfunction(columnName, operator, columnValue, propertyValue) {\n  function buildClause(columnValue, separator, grouping) {\n    var values = [];\n    for (var i = 0, n = columnValue.length; i < n; i++) {\n      if (columnValue[i] instanceof ParameterizedSQL) {\n        values.push(columnValue[i]);\n      } else {\n        values.push(new ParameterizedSQL(PLACEHOLDER, [columnValue[i]]));\n      }\n    }\n    separator = separator || ',';\n    var clause = ParameterizedSQL.join(values, separator);\n    if (grouping) {\n      clause.sql = '(' + clause.sql + ')';\n    }\n    return clause;\n  }\n\n  var sqlExp = columnName;\n  var clause;\n  if (columnValue instanceof ParameterizedSQL) {\n    clause = columnValue;\n  } else {\n    clause = new ParameterizedSQL(PLACEHOLDER, [columnValue]);\n  }\n  switch (operator) {\n    case 'gt':\n      sqlExp += '>';\n      break;\n    case 'gte':\n      sqlExp += '>=';\n      break;\n    case 'lt':\n      sqlExp += '<';\n      break;\n    case 'lte':\n      sqlExp += '<=';\n      break;\n    case 'between':\n      sqlExp += ' BETWEEN ';\n      clause = buildClause(columnValue, ' AND ', false);\n      break;\n    case 'inq':\n      sqlExp += ' IN ';\n      clause = buildClause(columnValue, ',', true);\n      break;\n    case 'nin':\n      sqlExp += ' NOT IN ';\n      clause = buildClause(columnValue, ',', true);\n      break;\n    case 'neq':\n      if (columnValue == null) {\n        return new ParameterizedSQL(sqlExp + ' IS NOT NULL');\n      }\n      sqlExp += '!=';\n      break;\n    case 'like':\n      sqlExp += ' LIKE ';\n      break;\n    case 'nlike':\n      sqlExp += ' NOT LIKE ';\n      break;\n    // this case not needed since each database has its own regex syntax, but\n    // we leave the MySQL syntax here as a placeholder\n    case 'regexp':\n      sqlExp += ' REGEXP ';\n      break;\n  }\n  var stmt = ParameterizedSQL.join([sqlExp, clause], '');\n  return stmt;\n};\n\n/*!\n * @param model\n * @param where\n * @returns {ParameterizedSQL}\n * @private\n */\nSQLConnector.prototype._buildWhere = function(model, where) {\n  if (!where) {\n    return new ParameterizedSQL('');\n  }\n  if (typeof where !== 'object' || Array.isArray(where)) {\n    debug('Invalid value for where: %j', where);\n    return new ParameterizedSQL('');\n  }\n  var self = this;\n  var props = self.getModelDefinition(model).properties;\n\n  var whereStmts = [];\n  for (var key in where) {\n    var stmt = new ParameterizedSQL('', []);\n    // Handle and/or operators\n    if (key === 'and' || key === 'or') {\n      var branches = [];\n      var branchParams = [];\n      var clauses = where[key];\n      if (Array.isArray(clauses)) {\n        for (var i = 0, n = clauses.length; i < n; i++) {\n          var stmtForClause = self._buildWhere(model, clauses[i]);\n          if (stmtForClause.sql) {\n            stmtForClause.sql = '(' + stmtForClause.sql + ')';\n            branchParams = branchParams.concat(stmtForClause.params);\n            branches.push(stmtForClause.sql);\n          }\n        }\n        stmt.merge({\n          sql: branches.join(' ' + key.toUpperCase() + ' '),\n          params: branchParams,\n        });\n        whereStmts.push(stmt);\n        continue;\n      }\n      // The value is not an array, fall back to regular fields\n    }\n    var p = props[key];\n    if (p == null) {\n      // Unknown property, ignore it\n      debug('Unknown property %s is skipped for model %s', key, model);\n      continue;\n    }\n    /* eslint-disable one-var */\n    var columnName = self.columnEscaped(model, key);\n    var expression = where[key];\n    var columnValue;\n    var sqlExp;\n    /* eslint-enable one-var */\n    if (expression === null || expression === undefined) {\n      stmt.merge(columnName + ' IS NULL');\n    } else if (expression && expression.constructor === Object) {\n      var operator = Object.keys(expression)[0];\n      // Get the expression without the operator\n      expression = expression[operator];\n      if (operator === 'inq' || operator === 'nin' || operator === 'between') {\n        columnValue = [];\n        if (Array.isArray(expression)) {\n          // Column value is a list\n          for (var j = 0, m = expression.length; j < m; j++) {\n            columnValue.push(this.toColumnValue(p, expression[j]));\n          }\n        } else {\n          columnValue.push(this.toColumnValue(p, expression));\n        }\n        if (operator === 'between') {\n          // BETWEEN v1 AND v2\n          var v1 = columnValue[0] === undefined ? null : columnValue[0];\n          var v2 = columnValue[1] === undefined ? null : columnValue[1];\n          columnValue = [v1, v2];\n        } else {\n          // IN (v1,v2,v3) or NOT IN (v1,v2,v3)\n          if (columnValue.length === 0) {\n            if (operator === 'inq') {\n              columnValue = [null];\n            } else {\n              // nin () is true\n              continue;\n            }\n          }\n        }\n      } else if (operator === 'regexp' && expression instanceof RegExp) {\n        // do not coerce RegExp based on property definitions\n        columnValue = expression;\n      } else {\n        columnValue = this.toColumnValue(p, expression);\n      }\n      sqlExp = self.buildExpression(\n        columnName, operator, columnValue, p);\n      stmt.merge(sqlExp);\n    } else {\n      // The expression is the field value, not a condition\n      columnValue = self.toColumnValue(p, expression);\n      if (columnValue === null) {\n        stmt.merge(columnName + ' IS NULL');\n      } else {\n        if (columnValue instanceof ParameterizedSQL) {\n          stmt.merge(columnName + '=').merge(columnValue);\n        } else {\n          stmt.merge({\n            sql: columnName + '=?',\n            params: [columnValue],\n          });\n        }\n      }\n    }\n    whereStmts.push(stmt);\n  }\n  var params = [];\n  var sqls = [];\n  for (var k = 0, s = whereStmts.length; k < s; k++) {\n    sqls.push(whereStmts[k].sql);\n    params = params.concat(whereStmts[k].params);\n  }\n  var whereStmt = new ParameterizedSQL({\n    sql: sqls.join(' AND '),\n    params: params,\n  });\n  return whereStmt;\n};\n\n/**\n * Build the ORDER BY clause\n * @param {string} model Model name\n * @param {string[]} order An array of sorting criteria\n * @returns {string} The ORDER BY clause\n */\nSQLConnector.prototype.buildOrderBy = function(model, order) {\n  if (!order) {\n    return '';\n  }\n  var self = this;\n  if (typeof order === 'string') {\n    order = [order];\n  }\n  var clauses = [];\n  for (var i = 0, n = order.length; i < n; i++) {\n    var t = order[i].split(/[\\s,]+/);\n    if (t.length === 1) {\n      clauses.push(self.columnEscaped(model, order[i]));\n    } else {\n      clauses.push(self.columnEscaped(model, t[0]) + ' ' + t[1]);\n    }\n  }\n  return 'ORDER BY ' + clauses.join(',');\n};\n\n/**\n * Build an array of fields for the database operation\n * @param {String} model Model name\n * @param {Object} data Model data object\n * @param {Boolean} excludeIds Exclude id properties or not, default to false\n * @returns {{names: Array, values: Array, properties: Array}}\n */\nSQLConnector.prototype.buildFields = function(model, data, excludeIds) {\n  var keys = Object.keys(data);\n  return this._buildFieldsForKeys(model, data, keys, excludeIds);\n};\n\n/**\n * Build an array of fields for the replace database operation\n * @param {String} model Model name\n * @param {Object} data Model data object\n * @param {Boolean} excludeIds Exclude id properties or not, default to false\n * @returns {{names: Array, values: Array, properties: Array}}\n */\nSQLConnector.prototype.buildReplaceFields = function(model, data, excludeIds) {\n  var props = this.getModelDefinition(model).properties;\n  var keys = Object.keys(props);\n  return this._buildFieldsForKeys(model, data, keys, excludeIds);\n};\n\n/*\n * @param {String} model The model name.\n * @returns {Object} data The model data object.\n * @returns {Array} keys The key fields for which need to be built.\n * @param {Boolean} excludeIds Exclude id properties or not, default to false\n * @private\n */\nSQLConnector.prototype._buildFieldsForKeys = function(model, data, keys, excludeIds) {\n  var props = this.getModelDefinition(model).properties;\n  var fields = {\n    names: [], // field names\n    columnValues: [], // an array of ParameterizedSQL\n    properties: [], // model properties\n  };\n  for (var i = 0, n = keys.length; i < n; i++) {\n    var key = keys[i];\n    var p = props[key];\n    if (p == null) {\n      // Unknown property, ignore it\n      debug('Unknown property %s is skipped for model %s', key, model);\n      continue;\n    }\n\n    if (excludeIds && p.id) {\n      continue;\n    }\n    var k = this.columnEscaped(model, key);\n    var v = this.toColumnValue(p, data[key]);\n    if (v !== undefined) {\n      fields.names.push(k);\n      if (v instanceof ParameterizedSQL) {\n        fields.columnValues.push(v);\n      } else {\n        fields.columnValues.push(new ParameterizedSQL(PLACEHOLDER, [v]));\n      }\n      fields.properties.push(p);\n    }\n  }\n  return fields;\n};\n\n/**\n * Build the SET clause for database update.\n * @param {String} model Model name.\n * @param {Object} data The model data object.\n * @param {Boolean} excludeIds Exclude id properties or not, default to true.\n * @returns {string} The list of fields for update query.\n */\nSQLConnector.prototype.buildFieldsForUpdate = function(model, data, excludeIds) {\n  if (excludeIds === undefined) {\n    excludeIds = true;\n  }\n  var fields = this.buildFields(model, data, excludeIds);\n  return this._constructUpdateParameterizedSQL(fields);\n};\n\n/**\n * Build the SET clause for database replace through update query.\n * @param {String} model Model name.\n * @param {Object} data The model data object.\n * @param {Boolean} excludeIds Exclude id properties or not, default to true.\n * @returns {string} The list of fields for update query.\n */\nSQLConnector.prototype.buildFieldsForReplace = function(model, data, excludeIds) {\n  if (excludeIds === undefined) {\n    excludeIds = true;\n  }\n  var fields = this.buildReplaceFields(model, data, excludeIds);\n  return this._constructUpdateParameterizedSQL(fields);\n};\n\n/*\n * @param {Object} field The fileds.\n * @returns {Object} parameterizedSQL.\n * @private\n */\nSQLConnector.prototype._constructUpdateParameterizedSQL = function(fields) {\n  var columns = new ParameterizedSQL('');\n  for (var i = 0, n = fields.names.length; i < n; i++) {\n    var clause = ParameterizedSQL.append(fields.names[i],\n      fields.columnValues[i], '=');\n    columns.merge(clause, ',');\n  }\n  columns.sql = 'SET ' + columns.sql;\n  return columns;\n};\n\n/**\n * Build a list of escaped column names for the given model and fields filter\n * @param {string} model Model name\n * @param {object} filter The filter object\n * @returns {string} Comma separated string of escaped column names\n */\nSQLConnector.prototype.buildColumnNames = function(model, filter) {\n  var fieldsFilter = filter && filter.fields;\n  var cols = this.getModelDefinition(model).properties;\n  if (!cols) {\n    return '*';\n  }\n  var self = this;\n  var keys = Object.keys(cols);\n  if (Array.isArray(fieldsFilter) && fieldsFilter.length > 0) {\n    // Not empty array, including all the fields that are valid properties\n    keys = fieldsFilter.filter(function(f) {\n      return cols[f];\n    });\n  } else if ('object' === typeof fieldsFilter &&\n    Object.keys(fieldsFilter).length > 0) {\n    // { field1: boolean, field2: boolean ... }\n    var included = [];\n    var excluded = [];\n    keys.forEach(function(k) {\n      if (fieldsFilter[k]) {\n        included.push(k);\n      } else if ((k in fieldsFilter) && !fieldsFilter[k]) {\n        excluded.push(k);\n      }\n    });\n    if (included.length > 0) {\n      keys = included;\n    } else if (excluded.length > 0) {\n      excluded.forEach(function(e) {\n        var index = keys.indexOf(e);\n        keys.splice(index, 1);\n      });\n    }\n  }\n  var names = keys.map(function(c) {\n    return self.columnEscaped(model, c);\n  });\n  return names.join(',');\n};\n\n/**\n * Build a SQL SELECT statement\n * @param {String} model Model name\n * @param {Object} filter Filter object\n * @param {Object} options Options object\n * @returns {ParameterizedSQL} Statement object {sql: ..., params: [...]}\n */\nSQLConnector.prototype.buildSelect = function(model, filter, options) {\n  if (!filter.order) {\n    var idNames = this.idNames(model);\n    if (idNames && idNames.length) {\n      filter.order = idNames;\n    }\n  }\n\n  var selectStmt = new ParameterizedSQL('SELECT ' +\n    this.buildColumnNames(model, filter) +\n    ' FROM ' + this.tableEscaped(model)\n  );\n\n  if (filter) {\n    if (filter.where) {\n      var whereStmt = this.buildWhere(model, filter.where);\n      selectStmt.merge(whereStmt);\n    }\n\n    if (filter.order) {\n      selectStmt.merge(this.buildOrderBy(model, filter.order));\n    }\n\n    if (filter.limit || filter.skip || filter.offset) {\n      selectStmt = this.applyPagination(\n        model, selectStmt, filter);\n    }\n  }\n  return this.parameterize(selectStmt);\n};\n\n/**\n * Transform the row data into a model data object\n * @param {string} model Model name\n * @param {object} rowData An object representing the row data from DB\n * @returns {object} Model data object\n */\nSQLConnector.prototype.fromRow = SQLConnector.prototype.fromDatabase =\nfunction(model, rowData) {\n  if (rowData == null) {\n    return rowData;\n  }\n  var props = this.getModelDefinition(model).properties;\n  var data = {};\n  for (var p in props) {\n    var columnName = this.column(model, p);\n    // Load properties from the row\n    var columnValue = this.fromColumnValue(props[p], rowData[columnName]);\n    if (columnValue !== undefined) {\n      data[p] = columnValue;\n    }\n  }\n  return data;\n};\n\n/**\n * Find matching model instances by the filter\n *\n * Please also note the name `all` is confusing. `Model.find` is to find all\n * matching instances while `Model.findById` is to find an instance by id. On\n * the other hand, `Connector.prototype.all` implements `Model.find` while\n * `Connector.prototype.find` implements `Model.findById` due to the `bad`\n * naming convention we inherited from juggling-db.\n *\n * @param {String} model The model name\n * @param {Object} filter The filter\n * @param {Function} [cb] The cb function\n */\nSQLConnector.prototype.all = function find(model, filter, options, cb) {\n  var self = this;\n  // Order by id if no order is specified\n  filter = filter || {};\n  var stmt = this.buildSelect(model, filter, options);\n  this.execute(stmt.sql, stmt.params, options, function(err, data) {\n    if (err) {\n      return cb(err, []);\n    }\n\n    var objs = data.map(function(obj) {\n      return self.fromRow(model, obj);\n    });\n    if (filter && filter.include) {\n      self.getModelDefinition(model).model.include(\n        objs, filter.include, options, cb);\n    } else {\n      cb(null, objs);\n    }\n  });\n};\n\n// Alias to `all`. Juggler checks `all` only.\nConnector.defineAliases(SQLConnector.prototype, 'all', ['findAll']);\n\n/**\n * ATM, this method is not used by loopback-datasource-juggler dao, which\n * maps `findById` to `find` with a `where` filter that includes the `id`\n * instead.\n *\n * Please also note the name `find` is confusing. `Model.find` is to find all\n * matching instances while `Model.findById` is to find an instance by id. On\n * the other hand, `Connector.prototype.find` is for `findById` and\n * `Connector.prototype.all` is for `find` due the `bad` convention used by\n * juggling-db.\n *\n * Find by id\n * @param {String} model The Model name\n * @param {*} id The id value\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n * @private\n */\nSQLConnector.prototype.find = function(model, id, options, cb) {\n  if (id == null) {\n    process.nextTick(function() {\n      var err = new Error(g.f('id value is required'));\n      if (cb) {\n        cb(err);\n      }\n    });\n    return;\n  }\n  var where = {};\n  var idName = this.idName(model);\n  where[idName] = id;\n\n  var filter = {limit: 1, offset: 0, order: idName, where: where};\n  return this.all(model, filter, options, function(err, results) {\n    cb(err, (results && results[0]) || null);\n  });\n};\n// Alias to `find`. Juggler checks `findById` only.\nConnector.defineAliases(SQLConnector.prototype, 'find', ['findById']);\n\n/**\n * Count all model instances by the where filter\n *\n * @param {String} model The model name\n * @param {Object} where The where object\n * @param {Object} options The options object\n * @param {Function} cb The callback function\n */\nSQLConnector.prototype.count = function(model, where, options, cb) {\n  if (typeof where === 'function') {\n    // Backward compatibility for 1.x style signature:\n    // count(model, cb, where)\n    var tmp = options;\n    cb = where;\n    where = tmp;\n  }\n\n  var stmt = new ParameterizedSQL('SELECT count(*) as \"cnt\" FROM ' +\n    this.tableEscaped(model));\n  stmt = stmt.merge(this.buildWhere(model, where));\n  stmt = this.parameterize(stmt);\n  this.execute(stmt.sql, stmt.params,\n    function(err, res) {\n      if (err) {\n        return cb(err);\n      }\n      var c = (res && res[0] && res[0].cnt) || 0;\n      // Some drivers return count as a string to contain bigint\n      // See https://github.com/brianc/node-postgres/pull/427\n      cb(err, Number(c));\n    });\n};\n\n/**\n * Drop the table for the given model from the database\n * @param {String} model The model name\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.dropTable = function(model, cb) {\n  this.execute('DROP TABLE IF EXISTS ' + this.tableEscaped(model), cb);\n};\n\n/**\n * Create the table for the given model\n * @param {String} model The model name\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.createTable = function(model, cb) {\n  var sql = 'CREATE TABLE ' + this.tableEscaped(model) +\n    ' (\\n  ' + this.buildColumnDefinitions(model) + '\\n)';\n  this.execute(sql, cb);\n};\n\n/**\n * Recreate the tables for the given models\n * @param {[String]|String} [models] A model name or an array of model names,\n * if not present, apply to all models defined in the connector\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.automigrate = function(models, cb) {\n  var self = this;\n\n  if ((!cb) && ('function' === typeof models)) {\n    cb = models;\n    models = undefined;\n  }\n  // First argument is a model name\n  if ('string' === typeof models) {\n    models = [models];\n  }\n\n  models = models || Object.keys(self._models);\n  if (models.length === 0) {\n    return process.nextTick(cb);\n  }\n\n  var invalidModels = models.filter(function(m) {\n    return !(m in self._models);\n  });\n  if (invalidModels.length) {\n    return process.nextTick(function() {\n      cb(new Error(g.f('Cannot migrate models not attached to this datasource: %s',\n        invalidModels.join(' '))));\n    });\n  }\n\n  async.each(models, function(model, done) {\n    self.dropTable(model, function(err) {\n      if (err) {\n        // TODO(bajtos) should we abort here and call cb(err)?\n        // The original code in juggler ignored the error completely\n        console.error(err);\n      }\n      self.createTable(model, function(err, result) {\n        if (err) {\n          console.error(err);\n        }\n        done(err, result);\n      });\n    });\n  }, cb);\n};\n\n/**\n * Serialize an object into JSON string or other primitive types so that it\n * can be saved into a RDB column\n * @param {Object} obj The object value\n * @returns {*}\n */\nSQLConnector.prototype.serializeObject = function(obj) {\n  var val;\n  if (obj && typeof obj.toJSON === 'function') {\n    obj = obj.toJSON();\n  }\n  if (typeof obj !== 'string') {\n    val = JSON.stringify(obj);\n  } else {\n    val = obj;\n  }\n  return val;\n};\n\n/*!\n * @param obj\n */\nSQLConnector.prototype.escapeObject = function(obj) {\n  var val = this.serializeObject(obj);\n  return this.escapeValue(val);\n};\n\n/**\n * The following _abstract_ methods have to be implemented by connectors that\n * extend from SQLConnector to reuse the base implementations of CRUD methods\n * from SQLConnector\n */\n\n/**\n * Converts a model property value into the form required by the\n * database column. The result should be one of following forms:\n *\n * - {sql: \"point(?,?)\", params:[10,20]}\n * - {sql: \"'John'\", params: []}\n * - \"John\"\n *\n * @param {Object} propertyDef Model property definition\n * @param {*} value Model property value\n * @returns {ParameterizedSQL|*} Database column value.\n *\n */\nSQLConnector.prototype.toColumnValue = function(propertyDef, value) {\n  throw new Error(g.f('{{toColumnValue()}} must be implemented by the connector'));\n};\n\n/**\n * Convert the data from database column to model property\n * @param {object} propertyDef Model property definition\n * @param {*) value Column value\n * @returns {*} Model property value\n */\nSQLConnector.prototype.fromColumnValue = function(propertyDef, value) {\n  throw new Error(g.f('{{fromColumnValue()}} must be implemented by the connector'));\n};\n\n/**\n * Escape the name for the underlying database\n * @param {String} name The name\n * @returns {String} An escaped name for SQL\n */\nSQLConnector.prototype.escapeName = function(name) {\n  throw new Error(g.f('{{escapeName()}} must be implemented by the connector'));\n};\n\n/**\n * Escape the name for the underlying database\n * @param {String} value The value to be escaped\n * @returns {*} An escaped value for SQL\n */\nSQLConnector.prototype.escapeValue = function(value) {\n  throw new Error(g.f('{{escapeValue()}} must be implemented by the connector'));\n};\n\n/**\n * Get the place holder in SQL for identifiers, such as ??\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nSQLConnector.prototype.getPlaceholderForIdentifier = function(key) {\n  throw new Error(g.f('{{getPlaceholderForIdentifier()}} must be implemented by ' +\n    'the connector'));\n};\n\n/**\n * Get the place holder in SQL for values, such as :1 or ?\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nSQLConnector.prototype.getPlaceholderForValue = function(key) {\n  throw new Error(g.f('{{getPlaceholderForValue()}} must be implemented by ' +\n    'the connector'));\n};\n\n/**\n * Build a new SQL statement with pagination support by wrapping the given sql\n * @param {String} model The model name\n * @param {ParameterizedSQL} stmt The sql statement\n * @param {Object} filter The filter object from the query\n */\nSQLConnector.prototype.applyPagination = function(model, stmt, filter) {\n  throw new Error(g.f('{{applyPagination()}} must be implemented by the connector'));\n};\n\n/**\n * Parse the result for SQL UPDATE/DELETE/INSERT for the number of rows\n * affected\n * @param {String} model Model name\n * @param {Object} info Status object\n * @returns {Number} Number of rows affected\n */\nSQLConnector.prototype.getCountForAffectedRows = function(model, info) {\n  throw new Error(g.f('{{getCountForAffectedRows()}} must be implemented by ' +\n    'the connector'));\n};\n\n/**\n * Parse the result for SQL INSERT for newly inserted id\n * @param {String} model Model name\n * @param {Object} info The status object from driver\n * @returns {*} The inserted id value\n */\nSQLConnector.prototype.getInsertedId = function(model, info) {\n  throw new Error(g.f('{{getInsertedId()}} must be implemented by the connector'));\n};\n\n/**\n * Execute a SQL statement with given parameters\n * @param {String} sql The SQL statement\n * @param {*[]} [params] An array of parameter values\n * @param {Object} [options] Options object\n * @param {Function} [callback] The callback function\n */\nSQLConnector.prototype.executeSQL = function(sql, params, options, callback) {\n  throw new Error(g.f('{{executeSQL()}} must be implemented by the connector'));\n};\n\n// Refactored Discovery methods\n\n/**\n * Build sql for listing schemas\n * @param {Object} options Options for discoverDatabaseSchemas\n */\nSQLConnector.prototype.buildQuerySchemas = function(options) {\n  var sql = 'SELECT catalog_name as \"catalog\",' +\n   ' schema_name as \"schema\"' +\n   ' FROM information_schema.schemata';\n  return this.paginateSQL(sql, 'schema_name', options);\n};\n\n/**\n * Paginate the results returned from database\n * @param {String} sql The sql to execute\n * @param {Object} orderBy The property name by which results are ordered\n * @param {Object} options Options for discoverDatabaseSchemas\n */\nSQLConnector.prototype.paginateSQL = function(sql, orderBy, options) {\n  throw new Error(g.f('{{paginateSQL}} must be implemented by the connector'));\n};\n/**\n * Discover database schemas\n *\n // * @param {Object} options Options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverDatabaseSchemas = function(options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n  this.execute(self.buildQuerySchemas(options), cb);\n};\n\n/*!\n * Build sql for listing tables\n * @param options {all: for all owners, owner: for a given owner}\n * @returns {string} The sql statement\n */\n // Due to the different implementation structure of information_schema across\n // connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryTables = function(options) {\n  throw new Error(g.f('{{buildQueryTables}} must be implemented by the connector'));\n};\n\n/*!\n * Build sql for listing views\n * @param options {all: for all owners, owner: for a given owner}\n * @returns {string} The sql statement\n */\n // Due to the different implementation structure of information_schema across\n // connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryViews = function(options) {\n  throw new Error(g.f('{{buildQueryViews}} must be implemented by the connector'));\n};\n\n/**\n * Discover model definitions\n *\n * @param {Object} options Options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverModelDefinitions = function(options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  options = options || {};\n\n  var self = this;\n  var calls = [function(callback) {\n    self.execute(self.buildQueryTables(options), callback);\n  }];\n\n  if (options.views) {\n    calls.push(function(callback) {\n      self.execute(self.buildQueryViews(options), callback);\n    });\n  }\n  async.parallel(calls, function(err, data) {\n    if (err) {\n      cb(err, data);\n    } else {\n      var merged = [];\n      merged = merged.concat(data.shift());\n      if (data.length) {\n        merged = merged.concat(data.shift());\n      }\n      cb(err, merged);\n    }\n  });\n};\n\n/**\n * Build sql for listing columns\n * @param {String} schema The schema name\n * @param {String} table The table name\n */\n// Due to the different implementation structure of information_schema across\n// connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryColumns = function(schema, table) {\n  throw new Error(g.f('{{buildQueryColumns}} must be implemented by the connector'));\n};\n\n/**\n * Map the property type from database to loopback\n * @param {Object} columnDefinition The columnDefinition of the table/schema\n * @param {Object} options The options for the connector\n */\nSQLConnector.prototype.buildPropertyType = function(columnDefinition, options) {\n  throw new Error(g.f('{{buildPropertyType}} must be implemented by the connector'));\n};\n\n/*!\n * Normalize the arguments\n * @param table string, required\n * @param options object, optional\n * @param cb function, optional\n */\nSQLConnector.prototype.getArgs = function(table, options, cb) {\n  throw new Error(g.f('{{getArgs}} must be implemented by the connector'));\n};\n\n/**\n * Discover model properties from a table\n * @param {String} table The table name\n * @param {Object} options The options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverModelProperties = function(table, options, cb) {\n  var self = this;\n  var args = self.getArgs(table, options, cb);\n  var schema = args.schema;\n\n  table = args.table;\n  options = args.options;\n\n  if (!schema) {\n    schema = self.getDefaultSchema();\n  }\n\n  self.setDefaultOptions(options);\n  cb = args.cb;\n\n  var sql = self.buildQueryColumns(schema, table);\n  var callback = function(err, results) {\n    if (err) {\n      cb(err, results);\n    } else {\n      results.map(function(r) {\n        r.type = self.buildPropertyType(r, options);\n        self.setNullableProperty(r);\n      });\n      cb(err, results);\n    }\n  };\n  this.execute(sql, callback);\n};\n\n/*!\n * Build the sql statement for querying primary keys of a given table\n * @param schema\n * @param table\n * @returns {string}\n */\n// http://docs.oracle.com/javase/6/docs/api/java/sql/DatabaseMetaData.html\n// #getPrimaryKeys(java.lang.String, java.lang.String, java.lang.String)\n// Due to the different implementation structure of information_schema across\n// connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryPrimaryKeys = function(schema, table) {\n  throw new Error(g.f('{{buildQueryPrimaryKeys}} must be implemented by the connector'));\n};\n\n/**\n * Discover primary keys for a given table\n * @param {String} table The table name\n * @param {Object} options The options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverPrimaryKeys = function(table, options, cb) {\n  var self = this;\n  var args = self.getArgs(table, options, cb);\n  var schema = args.schema;\n\n  if (typeof(self.getDefaultSchema) === 'function' && !schema) {\n    schema = self.getDefaultSchema();\n  }\n  table = args.table;\n  options = args.options;\n  cb = args.cb;\n\n  var sql = self.buildQueryPrimaryKeys(schema, table);\n  this.execute(sql, cb);\n};\n\n/*!\n * Build the sql statement for querying foreign keys of a given table\n * @param schema\n * @param table\n * @returns {string}\n */\n // Due to the different implementation structure of information_schema across\n // connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryForeignKeys = function(schema, table) {\n  throw new Error(g.f('{{buildQueryForeignKeys}} must be implemented by the connector'));\n};\n\n/**\n * Discover foreign keys for a given table\n * @param {String} table The table name\n * @param {Object} options The options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverForeignKeys = function(table, options, cb) {\n  var self = this;\n  var args = self.getArgs(table, options, cb);\n  var schema = args.schema;\n\n  if (typeof(self.getDefaultSchema) === 'function' && !schema) {\n    schema = self.getDefaultSchema();\n  }\n  table = args.table;\n  options = args.options;\n  cb = args.cb;\n\n  var sql = self.buildQueryForeignKeys(schema, table);\n  this.execute(sql, cb);\n};\n\n/*!\n * Retrieves a description of the foreign key columns that reference the\n * given table's primary key columns (the foreign keys exported by a table).\n * They are ordered by fkTableOwner, fkTableName, and keySeq.\n * @param schema\n * @param table\n * @returns {string}\n */\n // Due to the different implementation structure of information_schema across\n // connectors, each connector will have to generate its own query\nSQLConnector.prototype.buildQueryExportedForeignKeys = function(schema, table) {\n  throw new Error(g.f('{{buildQueryExportedForeignKeys}} must be implemented by' +\n  'the connector'));\n};\n\n/**\n * Discover foreign keys that reference to the primary key of this table\n * @param {String} table The table name\n * @param {Object} options The options for discovery\n * @param {Function} [cb] The callback function\n */\nSQLConnector.prototype.discoverExportedForeignKeys = function(table, options, cb) {\n  var self = this;\n  var args = self.getArgs(table, options, cb);\n  var schema = args.schema;\n\n  if (typeof(self.getDefaultSchema) === 'function' && !schema) {\n    schema = self.getDefaultSchema();\n  }\n  table = args.table;\n  options = args.options;\n  cb = args.cb;\n\n  var sql = self.buildQueryExportedForeignKeys(schema, table);\n  this.execute(sql, cb);\n};\n\n/**\n * Discover default schema of a database\n * @param {Object} options The options for discovery\n */\nSQLConnector.prototype.getDefaultSchema = function(options) {\n  throw new Error(g.f('{{getDefaultSchema}} must be implemented by' +\n  'the connector'));\n};\n\n/**\n * Set default options for the connector\n * @param {Object} options The options for discovery\n */\nSQLConnector.prototype.setDefaultOptions = function(options) {\n  throw new Error(g.f('{{setDefaultOptions}} must be implemented by' +\n  'the connector'));\n};\n\n/**\n * Set the nullable value for the property\n * @param {Object} property The property to set nullable\n */\nSQLConnector.prototype.setNullableProperty = function(property) {\n  throw new Error(g.f('{{setNullableProperty}} must be implemented by' +\n  'the connector'));\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/parameterized-sql.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar assert = require('assert');\nvar PLACEHOLDER = '?';\n\nmodule.exports = ParameterizedSQL;\n\n/**\n * A class for parameterized SQL clauses\n * @param {String|Object} sql The SQL clause. If the value is a string, treat\n * it as the template using `?` as the placeholder, for example, `(?,?)`. If\n * the value is an object, treat it as {sql: '...', params: [...]}\n * @param {*[]} params An array of parameter values. The length should match the\n * number of placeholders in the template\n * @returns {ParameterizedSQL} A new instance of ParameterizedSQL\n * @constructor\n */\nfunction ParameterizedSQL(sql, params) {\n  if (!(this instanceof ParameterizedSQL)) {\n    return new ParameterizedSQL(sql, params);\n  }\n  sql = sql || '';\n  if (arguments.length === 1 && typeof sql === 'object') {\n    this.sql = sql.sql;\n    this.params = sql.params || [];\n  } else {\n    this.sql = sql;\n    this.params = params || [];\n  }\n  assert(typeof this.sql === 'string', 'sql must be a string');\n  assert(Array.isArray(this.params), 'params must be an array');\n\n  var parts = this.sql.split(PLACEHOLDER);\n  assert(parts.length - 1 === this.params.length,\n    'The number of ? (' + (parts.length - 1) +\n    ') in the sql (' + this.sql + ') must match the number of params (' +\n    this.params.length +\n    ') ' + this.params);\n}\n\n/**\n * Merge the parameterized sqls into the current instance\n * @param {Object|Object[]} ps A parametered SQL or an array of parameterized\n * SQLs\n * @param {String} [separator] Separator, default to ` `\n * @returns {ParameterizedSQL} The current instance\n */\nParameterizedSQL.prototype.merge = function(ps, separator) {\n  if (Array.isArray(ps)) {\n    return this.constructor.append(this,\n      this.constructor.join(ps, separator), separator);\n  } else {\n    return this.constructor.append(this, ps, separator);\n  }\n};\n\nParameterizedSQL.prototype.toJSON = function() {\n  return {\n    sql: this.sql,\n    params: this.params,\n  };\n};\n\n/**\n * Append the statement into the current statement\n * @param {Object} currentStmt The current SQL statement\n * @param {Object} stmt The statement to be appended\n * @param {String} [separator] Separator, default to ` `\n * @returns {*} The merged statement\n */\nParameterizedSQL.append = function(currentStmt, stmt, separator) {\n  currentStmt = (currentStmt instanceof ParameterizedSQL) ?\n    currentStmt : new ParameterizedSQL(currentStmt);\n  stmt = (stmt instanceof ParameterizedSQL) ? stmt :\n    new ParameterizedSQL(stmt);\n  separator = typeof separator === 'string' ? separator : ' ';\n  if (currentStmt.sql) {\n    currentStmt.sql += separator;\n  }\n  if (stmt.sql) {\n    currentStmt.sql += stmt.sql;\n  }\n  currentStmt.params = currentStmt.params.concat(stmt.params);\n  return currentStmt;\n};\n\n/**\n * Join multiple parameterized SQLs into one\n * @param {Object[]} sqls An array of parameterized SQLs\n * @param {String} [separator] Separator, default to ` `\n * @returns {ParameterizedSQL}\n */\nParameterizedSQL.join = function(sqls, separator) {\n  assert(Array.isArray(sqls), 'sqls must be an array');\n  var ps = new ParameterizedSQL('', []);\n  for (var i = 0, n = sqls.length; i < n; i++) {\n    this.append(ps, sqls[i], separator);\n  }\n  return ps;\n};\n\nParameterizedSQL.PLACEHOLDER = PLACEHOLDER;\n\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/transaction.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar assert = require('assert');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('loopback:connector:transaction');\n\nmodule.exports = Transaction;\n\n/**\n * Create a new Transaction object\n * @param {Connector} connector The connector instance\n * @param {*} connection A connection to the DB\n * @constructor\n */\nfunction Transaction(connector, connection) {\n  this.connector = connector;\n  this.connection = connection;\n  EventEmitter.call(this);\n}\n\nutil.inherits(Transaction, EventEmitter);\n\n// Isolation levels\nTransaction.SERIALIZABLE = 'SERIALIZABLE';\nTransaction.REPEATABLE_READ = 'REPEATABLE READ';\nTransaction.READ_COMMITTED = 'READ COMMITTED';\nTransaction.READ_UNCOMMITTED = 'READ UNCOMMITTED';\n\nTransaction.hookTypes = {\n  BEFORE_COMMIT: 'before commit',\n  AFTER_COMMIT: 'after commit',\n  BEFORE_ROLLBACK: 'before rollback',\n  AFTER_ROLLBACK: 'after rollback',\n  TIMEOUT: 'timeout',\n};\n\n/**\n * Commit a transaction and release it back to the pool\n * @param cb\n * @returns {*}\n */\nTransaction.prototype.commit = function(cb) {\n  return this.connector.commit(this.connection, cb);\n};\n\n/**\n * Rollback a transaction and release it back to the pool\n * @param cb\n * @returns {*|boolean}\n */\nTransaction.prototype.rollback = function(cb) {\n  return this.connector.rollback(this.connection, cb);\n};\n\n/**\n * Begin a new transaction\n * @param {Connector} connector The connector instance\n * @param {Object} [options] Options {isolationLevel: '...', timeout: 1000}\n * @param cb\n */\nTransaction.begin = function(connector, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  if (typeof options === 'string') {\n    options = {isolationLevel: options};\n  }\n  var isolationLevel = options.isolationLevel || Transaction.READ_COMMITTED;\n  assert(isolationLevel === Transaction.SERIALIZABLE ||\n    isolationLevel === Transaction.REPEATABLE_READ ||\n    isolationLevel === Transaction.READ_COMMITTED ||\n    isolationLevel === Transaction.READ_UNCOMMITTED, 'Invalid isolationLevel');\n\n  debug('Starting a transaction with options: %j', options);\n  assert(typeof connector.beginTransaction === 'function',\n    'beginTransaction must be function implemented by the connector');\n  connector.beginTransaction(isolationLevel, function(err, connection) {\n    if (err) {\n      return cb(err);\n    }\n    var tx = connection;\n    if (!(connection instanceof Transaction)) {\n      tx = new Transaction(connector, connection);\n    }\n    cb(err, tx);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/utils.js":"// Copyright IBM Corp. 2012,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar Promise = require('bluebird');\n\nexports.createPromiseCallback = createPromiseCallback;\n\nfunction createPromiseCallback() {\n  var cb;\n  var promise = new Promise(function(resolve, reject) {\n    cb = function(err, data) {\n      if (err) return reject(err);\n      return resolve(data);\n    };\n  });\n  cb.promise = promise;\n  return cb;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/model-key-composer.js":"// Copyright IBM Corp. 2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar createPromiseCallback = require('./utils').createPromiseCallback;\nvar debug = require('debug')('loopback:connector:model-key-composer');\nvar g = require('strong-globalize')();\n\n/**\n * Build a single key string from a tuple (modelName, key).\n *\n * This method is typically used by KeyValue connectors to build a single\n * key string for a given modelName+key tuple.\n *\n * @param {String} modelName\n * @param {String} key\n * @callback {Function} cb The callback to receive the composed value.\n * @param {Error} err\n * @param {String} composedKey\n * @promise\n */\nexports.compose = function composeKeyFromModelNameAndKey(modelName, key, cb) {\n  cb = cb || createPromiseCallback();\n\n  // Escape model name to prevent collision\n  //   'model' + 'foo:bar' --vs-- 'model:foo' + 'bar'\n  var value = encodeURIComponent(modelName) + ':' + key;\n\n  setImmediate(function() {\n    cb(null, value);\n  });\n  return cb.promise;\n};\n\nvar PARSE_KEY_REGEX = /^([^:]*):(.*)/;\n\n/**\n * Parse a composed key string into a tuple (modelName, key).\n *\n * This method is typically used by KeyValue connectors to parse a composed\n * key string returned by SCAN/ITERATE method back to the expected\n * modelName+tuple key.\n *\n * @param {String} composed The composed key as returned by `composeKey`\n * @callback {Function} cb The callback to receive the parsed result.\n * @param {Error} err\n * @param {Object} result The result with properties `modelName` and `key`.\n * @promise\n */\nexports.parse = function(composed, cb) {\n  cb = cb || createPromiseCallback();\n\n  var matchResult = composed.match(PARSE_KEY_REGEX);\n  if (matchResult) {\n    var result = {\n      modelName: matchResult[1],\n      key: matchResult[2],\n    };\n    setImmediate(function() {\n      cb(null, result);\n    });\n  } else {\n    debug('Invalid key - missing model-name prefix: %s', composed);\n    var err = new Error(g.f(\n      'Invalid key %j - missing model-name prefix',\n      composed));\n    err.code = 'NO_MODEL_PREFIX';\n    setImmediate(function() {\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/binary-packer.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar createPromiseCallback = require('./utils').createPromiseCallback;\nvar msgpack = require('msgpack5');\n\nmodule.exports = BinaryPacker;\n\n/**\n * Create a new Packer instance that can be used to convert between JavaScript\n * objects and a binary representation in a Buffer.\n *\n * Compared to JSON, this encoding preserves the following JavaScript types:\n *  - Date\n */\nfunction BinaryPacker() {\n  this._packer = msgpack({forceFloat64: true});\n  this._packer.register(1, Date, encodeDate, decodeDate);\n}\n\n/**\n * Encode the provided value to a `Buffer`.\n *\n * @param {*} value Any value (string, number, object)\n * @callback {Function} cb The callback to receive the parsed result.\n * @param {Error} err\n * @param {Buffer} data The encoded value\n * @promise\n */\nBinaryPacker.prototype.encode = function(value, cb) {\n  cb = cb || createPromiseCallback();\n  try {\n    // msgpack5 returns https://www.npmjs.com/package/bl instead of Buffer\n    // use .slice() to convert to a Buffer\n    var data = this._packer.encode(value).slice();\n    setImmediate(function() {\n      cb(null, data);\n    });\n  } catch (err) {\n    setImmediate(function() {\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n\n/**\n * Decode the binary value back to a JavaScript value.\n * @param {Buffer} binary The binary input.\n * @callback {Function} cb The callback to receive the composed value.\n * @param {Error} err\n * @param {*} value Decoded value.\n * @promise\n */\nBinaryPacker.prototype.decode = function(binary, cb) {\n  cb = cb || createPromiseCallback();\n  try {\n    var value = this._packer.decode(binary);\n    setImmediate(function() {\n      cb(null, value);\n    });\n  } catch (err) {\n    setImmediate(function() {\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n\nfunction encodeDate(obj) {\n  return new Buffer(obj.toISOString(), 'utf8');\n}\n\nfunction decodeDate(buf) {\n  return new Date(buf.toString('utf8'));\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector/lib/json-string-packer.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar createPromiseCallback = require('./utils').createPromiseCallback;\n\nmodule.exports = JSONStringPacker;\n\nvar ISO_DATE_REGEXP = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*))(?:Z|(\\+|-)([\\d|:]*))?$/;\n\n/**\n * Create a new Packer instance that can be used to convert between JavaScript\n * objects and a JsonString representation in a String.\n *\n * @param {String} encoding Buffer encoding refer to https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings\n */\nfunction JSONStringPacker(encoding) {\n  this.encoding = encoding || 'base64';\n}\n\n/**\n * Encode the provided value to a `JsonString`.\n *\n * @param {*} value Any value (string, number, object)\n * @callback {Function} cb The callback to receive the parsed result.\n * @param {Error} err\n * @param {Buffer} data The encoded value\n * @promise\n */\nJSONStringPacker.prototype.encode = function(value, cb) {\n  var encoding = this.encoding;\n\n  cb = cb || createPromiseCallback();\n  try {\n    var data = JSON.stringify(value, function(key, value) {\n      if (Buffer.isBuffer(this[key])) {\n        return {\n          type: 'Buffer',\n          data: this[key].toString(encoding),\n        };\n      } else {\n        return value;\n      }\n    });\n\n    setImmediate(function() {\n      cb(null, data);\n    });\n  } catch (err) {\n    setImmediate(function() {\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n\n/**\n * Decode the JsonString value back to a JavaScript value.\n * @param {String} jsonString The JsonString input.\n * @callback {Function} cb The callback to receive the composed value.\n * @param {Error} err\n * @param {*} value Decoded value.\n * @promise\n */\nJSONStringPacker.prototype.decode = function(jsonString, cb) {\n  var encoding = this.encoding;\n\n  cb = cb || createPromiseCallback();\n  try {\n    var value = JSON.parse(jsonString, function(k, v) {\n      if (v && v.type && v.type === 'Buffer') {\n        return new Buffer(v.data, encoding);\n      }\n\n      if (ISO_DATE_REGEXP.exec(v)) {\n        return new Date(v);\n      }\n\n      return v;\n    });\n\n    setImmediate(function() {\n      cb(null, value);\n    });\n  } catch (err) {\n    setImmediate(function() {\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/dao.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n// Turning on strict for this file breaks lots of test cases;\n// disabling strict for this file\n/* eslint-disable strict */\n\n/*!\n * Module exports class Model\n */\nmodule.exports = DataAccessObject;\n\n/*!\n * Module dependencies\n */\nvar g = require('strong-globalize')();\nvar async = require('async');\nvar jutil = require('./jutil');\nvar ValidationError = require('./validations').ValidationError;\nvar Relation = require('./relations.js');\nvar Inclusion = require('./include.js');\nvar List = require('./list.js');\nvar geo = require('./geo');\nvar Memory = require('./connectors/memory').Memory;\nvar utils = require('./utils');\nvar fieldsToArray = utils.fieldsToArray;\nvar removeUndefined = utils.removeUndefined;\nvar setScopeValuesFromWhere = utils.setScopeValuesFromWhere;\nvar idEquals = utils.idEquals;\nvar mergeQuery = utils.mergeQuery;\nvar util = require('util');\nvar assert = require('assert');\nvar BaseModel = require('./model');\nvar debug = require('debug')('loopback:dao');\n\n/**\n * Base class for all persistent objects.\n * Provides a common API to access any database connector.\n * This class describes only abstract behavior.  Refer to the specific connector for additional details.\n *\n * `DataAccessObject` mixes `Inclusion` classes methods.\n * @class DataAccessObject\n */\nfunction DataAccessObject() {\n  if (DataAccessObject._mixins) {\n    var self = this;\n    var args = arguments;\n    DataAccessObject._mixins.forEach(function(m) {\n      m.call(self, args);\n    });\n  }\n}\n\nfunction idName(m) {\n  return m.definition.idName() || 'id';\n}\n\nfunction getIdValue(m, data) {\n  return data && data[idName(m)];\n}\n\nfunction copyData(from, to) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n}\n\nfunction convertSubsetOfPropertiesByType(inst, data) {\n  var typedData = {};\n  for (var key in data) {\n    // Convert the properties by type\n    typedData[key] = inst[key];\n    if (typeof typedData[key] === 'object' &&\n            typedData[key] !== null &&\n            typeof typedData[key].toObject === 'function') {\n      typedData[key] = typedData[key].toObject();\n    }\n  }\n  return typedData;\n}\n\n/**\n * Apply strict check for model's data.\n * Notice: Please note this method modifies `inst` when `strict` is `validate`.\n */\nfunction applyStrictCheck(model, strict, data, inst, cb) {\n  var props = model.definition.properties;\n  var keys = Object.keys(data);\n  var result = {}, key;\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    if (props[key]) {\n      result[key] = data[key];\n    } else if (strict) {\n      inst.__unknownProperties.push(key);\n    }\n  }\n  cb(null, result);\n}\n\nfunction setIdValue(m, data, value) {\n  if (data) {\n    data[idName(m)] = value;\n  }\n}\n\nfunction byIdQuery(m, id) {\n  var pk = idName(m);\n  var query = {where: {}};\n  query.where[pk] = id;\n  return query;\n}\n\nfunction isWhereByGivenId(Model, where, idValue) {\n  var keys = Object.keys(where);\n  if (keys.length != 1) return false;\n\n  var pk = idName(Model);\n  if (keys[0] !== pk) return false;\n\n  return where[pk] === idValue;\n}\n\nDataAccessObject._forDB = function(data) {\n  if (!(this.getDataSource().isRelational && this.getDataSource().isRelational())) {\n    return data;\n  }\n  var res = {};\n  for (var propName in data) {\n    var type = this.getPropertyType(propName);\n    if (type === 'JSON' || type === 'Any' || type === 'Object' || data[propName] instanceof Array) {\n      res[propName] = JSON.stringify(data[propName]);\n    } else {\n      res[propName] = data[propName];\n    }\n  }\n  return res;\n};\n\nDataAccessObject.defaultScope = function(target, inst) {\n  var scope = this.definition.settings.scope;\n  if (typeof scope === 'function') {\n    scope = this.definition.settings.scope.call(this, target, inst);\n  }\n  return scope;\n};\n\nDataAccessObject.applyScope = function(query, inst) {\n  var scope = this.defaultScope(query, inst) || {};\n  if (typeof scope === 'object') {\n    mergeQuery(query, scope || {}, this.definition.settings.scope);\n  }\n};\n\nDataAccessObject.applyProperties = function(data, inst) {\n  var properties = this.definition.settings.properties;\n  properties = properties || this.definition.settings.attributes;\n  if (typeof properties === 'object') {\n    util._extend(data, properties);\n  } else if (typeof properties === 'function') {\n    util._extend(data, properties.call(this, data, inst) || {});\n  } else if (properties !== false) {\n    var scope = this.defaultScope(data, inst) || {};\n    if (typeof scope.where === 'object') {\n      setScopeValuesFromWhere(data, scope.where, this);\n    }\n  }\n};\n\nDataAccessObject.lookupModel = function(data) {\n  return this;\n};\n\n/**\n * Get the connector instance for the given model class\n * @returns {Connector} The connector instance\n */\nDataAccessObject.getConnector = function() {\n  return this.getDataSource().connector;\n};\n\n/**\n * Verify if allowExtendedOperators is enabled\n * @options {Object} [options] Optional options to use.\n * @property {Boolean} allowExtendedOperators.\n * @returns {Boolean} Returns `true` if allowExtendedOperators is enabled, else `false`.\n */\nDataAccessObject._allowExtendedOperators = function(options) {\n  options = options || {};\n\n  var Model = this;\n  var dsSettings = this.getDataSource().settings;\n  var allowExtendedOperators = dsSettings.allowExtendedOperators;\n  // options settings enable allowExtendedOperators per request (for example if\n  // enable allowExtendedOperators only server side);\n  // model settings enable allowExtendedOperators only for specific model.\n  // dataSource settings enable allowExtendedOperators globally (all models);\n  // options -> model -> dataSource (connector)\n  if (options.hasOwnProperty('allowExtendedOperators')) {\n    allowExtendedOperators = options.allowExtendedOperators === true;\n  } else if (Model.settings && Model.settings.hasOwnProperty('allowExtendedOperators')) {\n    allowExtendedOperators = Model.settings.allowExtendedOperators === true;\n  }\n  return allowExtendedOperators;\n};\n\n// Empty callback function\nfunction noCallback(err, result) {\n  // NOOP\n  debug('callback is ignored: err=%j, result=%j', err, result);\n}\n\n/**\n * Create an instance of Model with given data and save to the attached data source. Callback is optional.\n * Example:\n *```js\n * User.create({first: 'Joe', last: 'Bob'}, function(err, user) {\n *  console.log(user instanceof User); // true\n * });\n * ```\n * Note: You must include a callback and use the created model provided in the callback if your code depends on your model being\n * saved or having an ID.\n *\n * @param {Object} [data] Optional data object\n * @param {Object} [options] Options for create\n * @param {Function} [cb]  Callback function called with these arguments:\n *   - err (null or Error)\n *   - instance (null or Model)\n */\nDataAccessObject.create = function(data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  var Model = this;\n  var connector = Model.getConnector();\n  assert(typeof connector.create === 'function',\n    'create() must be implemented by the connector');\n\n  var self = this;\n\n  if (options === undefined && cb === undefined) {\n    if (typeof data === 'function') {\n      // create(cb)\n      cb = data;\n      data = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // create(data, cb);\n      cb = options;\n      options = {};\n    }\n  }\n\n  data = data || {};\n  options = options || {};\n  cb = cb || (Array.isArray(data) ? noCallback : utils.createPromiseCallback());\n\n  assert(typeof data === 'object', 'The data argument must be an object or array');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var hookState = {};\n\n  if (Array.isArray(data)) {\n    // Undefined item will be skipped by async.map() which internally uses\n    // Array.prototype.map(). The following loop makes sure all items are\n    // iterated\n    for (var i = 0, n = data.length; i < n; i++) {\n      if (data[i] === undefined) {\n        data[i] = {};\n      }\n    }\n    async.map(data, function(item, done) {\n      self.create(item, options, function(err, result) {\n        // Collect all errors and results\n        done(null, {err: err, result: result || item});\n      });\n    }, function(err, results) {\n      if (err) {\n        return cb(err, results);\n      }\n      // Convert the results into two arrays\n      var errors = null;\n      var data = [];\n      for (var i = 0, n = results.length; i < n; i++) {\n        if (results[i].err) {\n          if (!errors) {\n            errors = [];\n          }\n          errors[i] = results[i].err;\n        }\n        data[i] = results[i].result;\n      }\n      cb(errors, data);\n    });\n    return;\n  }\n\n  var enforced = {};\n  var obj;\n  var idValue = getIdValue(this, data);\n\n  // if we come from save\n  if (data instanceof Model && !idValue) {\n    obj = data;\n  } else {\n    obj = new Model(data);\n  }\n\n  this.applyProperties(enforced, obj);\n  obj.setAttributes(enforced);\n\n  Model = this.lookupModel(data); // data-specific\n  if (Model !== obj.constructor) obj = new Model(data);\n\n  var context = {\n    Model: Model,\n    instance: obj,\n    isNewInstance: true,\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('before save', context, function(err) {\n    if (err) return cb(err);\n\n    data = obj.toObject(true);\n\n    // options has precedence on model-setting\n    if (options.validate === false) {\n      return create();\n    }\n\n    // only when options.validate is not set, take model-setting into consideration\n    if (options.validate === undefined && Model.settings.automaticValidation === false) {\n      return create();\n    }\n\n    // validation required\n    obj.isValid(function(valid) {\n      if (valid) {\n        create();\n      } else {\n        cb(new ValidationError(obj), obj);\n      }\n    }, data, options);\n  });\n\n  function create() {\n    obj.trigger('create', function(createDone) {\n      obj.trigger('save', function(saveDone) {\n        var _idName = idName(Model);\n        var modelName = Model.modelName;\n        var val = removeUndefined(obj.toObject(true));\n        function createCallback(err, id, rev) {\n          if (id) {\n            obj.__data[_idName] = id;\n            defineReadonlyProp(obj, _idName, id);\n          }\n          if (rev) {\n            obj._rev = rev;\n          }\n          if (err) {\n            return cb(err, obj);\n          }\n          obj.__persisted = true;\n\n          var context = {\n            Model: Model,\n            data: val,\n            isNewInstance: true,\n            hookState: hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('loaded', context, function(err) {\n            if (err) return cb(err);\n\n            // By default, the instance passed to create callback is NOT updated\n            // with the changes made through persist/loaded hooks. To preserve\n            // backwards compatibility, we introduced a new setting updateOnLoad,\n            // which if set, will apply these changes to the model instance too.\n            if (Model.settings.updateOnLoad) {\n              obj.setAttributes(context.data);\n            }\n            saveDone.call(obj, function() {\n              createDone.call(obj, function() {\n                if (err) {\n                  return cb(err, obj);\n                }\n                var context = {\n                  Model: Model,\n                  instance: obj,\n                  isNewInstance: true,\n                  hookState: hookState,\n                  options: options,\n                };\n                if (options.notify !== false) {\n                  Model.notifyObserversOf('after save', context, function(err) {\n                    cb(err, obj);\n                  });\n                } else {\n                  cb(null, obj);\n                }\n              });\n            });\n          });\n        }\n\n        context = {\n          Model: Model,\n          data: val,\n          isNewInstance: true,\n          currentInstance: obj,\n          hookState: hookState,\n          options: options,\n        };\n        Model.notifyObserversOf('persist', context, function(err) {\n          if (err) return cb(err);\n\n          if (connector.create.length === 4) {\n            connector.create(modelName, obj.constructor._forDB(context.data), options, createCallback);\n          } else {\n            connector.create(modelName, obj.constructor._forDB(context.data), createCallback);\n          }\n        });\n      }, obj, cb);\n    }, obj, cb);\n  }\n\n  return cb.promise;\n};\n\nfunction stillConnecting(dataSource, obj, args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return dataSource.ready(obj, args);\n  }\n\n  // promise variant\n  var promiseArgs = Array.prototype.slice.call(args);\n  promiseArgs.callee = args.callee;\n  var cb =  utils.createPromiseCallback();\n  promiseArgs.push(cb);\n  if (dataSource.ready(obj, promiseArgs)) {\n    return cb.promise;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Update or insert a model instance: update exiting record if one is found, such that parameter `data.id` matches `id` of model instance;\n * otherwise, insert a new record.\n *\n * NOTE: No setters, validations, or hooks are applied when using upsert.\n * `updateOrCreate` and `patchOrCreate` are aliases\n * @param {Object} data The model instance data\n * @param {Object} [options] Options for upsert\n * @param {Function} cb The callback function (optional).\n */\n// [FIXME] rfeng: This is a hack to set up 'upsert' first so that\n// 'upsert' will be used as the name for strong-remoting to keep it backward\n// compatible for angular SDK\nDataAccessObject.updateOrCreate =\nDataAccessObject.patchOrCreate =\nDataAccessObject.upsert = function(data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (options === undefined && cb === undefined) {\n    if (typeof data === 'function') {\n      // upsert(cb)\n      cb = data;\n      data = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // upsert(data, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  data = data || {};\n  options = options || {};\n\n  assert(typeof data === 'object', 'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  if (Array.isArray(data)) {\n    cb(new Error('updateOrCreate does not support bulk mode or any array input'));\n    return cb.promise;\n  }\n\n  var hookState = {};\n\n  var self = this;\n  var Model = this;\n  var connector = Model.getConnector();\n\n  var id = getIdValue(this, data);\n  if (id === undefined || id === null) {\n    return this.create(data, options, cb);\n  }\n\n  var context = {\n    Model: Model,\n    query: byIdQuery(Model, id),\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('access', context, doUpdateOrCreate);\n\n  function doUpdateOrCreate(err, ctx) {\n    if (err) return cb(err);\n\n    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);\n    if (connector.updateOrCreate && isOriginalQuery) {\n      var context = {\n        Model: Model,\n        where: ctx.query.where,\n        data: data,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('before save', context, function(err, ctx) {\n        if (err) return cb(err);\n\n        data = ctx.data;\n        var update = data;\n        var inst = data;\n        if (!(data instanceof Model)) {\n          inst = new Model(data, {applyDefaultValues: false});\n        }\n        update = inst.toObject(false);\n\n        Model.applyProperties(update, inst);\n        Model = Model.lookupModel(update);\n\n        var connector = self.getConnector();\n\n        var doValidate = undefined;\n        if (options.validate === undefined) {\n          if (Model.settings.validateUpsert === undefined) {\n            if (Model.settings.automaticValidation !== undefined) {\n              doValidate = Model.settings.automaticValidation;\n            }\n          } else {\n            doValidate = Model.settings.validateUpsert;\n          }\n        } else {\n          doValidate = options.validate;\n        }\n\n        if (doValidate === false) {\n          callConnector();\n        } else {\n          inst.isValid(function(valid) {\n            if (!valid) {\n              if (doValidate) { // backwards compatibility with validateUpsert:undefined\n                return cb(new ValidationError(inst), inst);\n              } else {\n                // TODO(bajtos) Remove validateUpsert:undefined in v3.0\n                g.warn('Ignoring validation errors in {{updateOrCreate()}}:');\n                g.warn('  %s', new ValidationError(inst).message);\n                // continue with updateOrCreate\n              }\n            }\n            callConnector();\n          }, update, options);\n        }\n\n        function callConnector() {\n          update = removeUndefined(update);\n          context = {\n            Model: Model,\n            where: ctx.where,\n            data: update,\n            currentInstance: inst,\n            hookState: ctx.hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('persist', context, function(err) {\n            if (err) return done(err);\n            if (connector.updateOrCreate.length === 4) {\n              connector.updateOrCreate(Model.modelName, update, options, done);\n            } else {\n              connector.updateOrCreate(Model.modelName, update, done);\n            }\n          });\n        }\n        function done(err, data, info) {\n          if (err) return cb(err);\n          var context = {\n            Model: Model,\n            data: data,\n            isNewInstance: info && info.isNewInstance,\n            hookState: ctx.hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('loaded', context, function(err) {\n            if (err) return cb(err);\n\n            var obj;\n            if (data && !(data instanceof Model)) {\n              inst._initProperties(data, {persisted: true});\n              obj = inst;\n            } else {\n              obj = data;\n            }\n            if (err) {\n              cb(err, obj);\n            } else {\n              var context = {\n                Model: Model,\n                instance: obj,\n                isNewInstance: info ? info.isNewInstance : undefined,\n                hookState: hookState,\n                options: options,\n              };\n\n              if (options.notify !== false) {\n                Model.notifyObserversOf('after save', context, function(err) {\n                  cb(err, obj);\n                });\n              } else {\n                cb(null, obj);\n              }\n            }\n          });\n        }\n      });\n    } else {\n      var opts = {notify: false};\n      if (ctx.options && ctx.options.transaction) {\n        opts.transaction = ctx.options.transaction;\n      }\n      Model.findOne({where: ctx.query.where}, opts, function(err, inst) {\n        if (err) {\n          return cb(err);\n        }\n        if (!isOriginalQuery) {\n          // The custom query returned from a hook may hide the fact that\n          // there is already a model with `id` value `data[idName(Model)]`\n          delete data[idName(Model)];\n        }\n        if (inst) {\n          inst.updateAttributes(data, options, cb);\n        } else {\n          Model = self.lookupModel(data);\n          var obj = new Model(data);\n          obj.save(options, cb);\n        }\n      });\n    }\n  }\n  return cb.promise;\n};\n/**\n * Update or insert a model instance based on the search criteria.\n * If there is a single instance retrieved, update the retrieved model.\n * Creates a new model if no model instances were found.\n * Returns an error if multiple instances are found.\n * @param {Object} [where]  `where` filter, like\n * ```\n * { key: val, key2: {gt: 'val2'}, ...}\n * ```\n * <br/>see\n * [Where filter](https://docs.strongloop.com/display/LB/Where+filter#Wherefilter-Whereclauseforothermethods).\n * @param {Object} data The model instance data to insert.\n * @callback {Function} callback Callback function called with `cb(err, obj)` signature.\n * @param {Error} err Error object; see [Error object](http://docs.strongloop.com/display/LB/Error+object).\n * @param {Object} model Updated model instance.\n */\nDataAccessObject.patchOrCreateWithWhere =\nDataAccessObject.upsertWithWhere = function(where, data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) { return connectionPromise; }\n  if (cb === undefined) {\n    if (typeof options === 'function') {\n      // upsertWithWhere(where, data, cb)\n      cb = options;\n      options = {};\n    }\n  }\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n  assert(typeof where === 'object', 'The where argument must be an object');\n  assert(typeof data === 'object', 'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n  if (Object.keys(data).length === 0) {\n    var err = new Error('data object cannot be empty!');\n    err.statusCode = 400;\n    process.nextTick(function() { cb(err); });\n    return cb.promise;\n  }\n  var hookState = {};\n  var self = this;\n  var Model = this;\n  var connector = Model.getConnector();\n  var modelName = Model.modelName;\n  var query = {where: where};\n  var context = {\n    Model: Model,\n    query: query,\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('access', context, doUpsertWithWhere);\n  function doUpsertWithWhere(err, ctx) {\n    if (err) return cb(err);\n    ctx.data = data;\n    if (connector.upsertWithWhere) {\n      var context = {\n        Model: Model,\n        where: ctx.query.where,\n        data: ctx.data,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('before save', context, function(err, ctx) {\n        if (err) return cb(err);\n        data = ctx.data;\n        var update = data;\n        var inst = data;\n        if (!(data instanceof Model)) {\n          inst = new Model(data, {applyDefaultValues: false});\n        }\n        update = inst.toObject(false);\n        Model.applyScope(query);\n        Model.applyProperties(update, inst);\n        Model = Model.lookupModel(update);\n        if (options.validate === false) {\n          return callConnector();\n        }\n        if (options.validate === undefined && Model.settings.automaticValidation === false) {\n          return callConnector();\n        }\n        inst.isValid(function(valid) {\n          if (!valid) return cb(new ValidationError(inst), inst);\n          callConnector();\n        }, update, options);\n\n        function callConnector() {\n          try {\n            ctx.where = removeUndefined(ctx.where);\n            ctx.where = Model._coerce(ctx.where, options);\n            update = removeUndefined(update);\n            update = Model._coerce(update, options);\n          } catch (err) {\n            return process.nextTick(function() {\n              cb(err);\n            });\n          }\n          context = {\n            Model: Model,\n            where: ctx.where,\n            data: update,\n            currentInstance: inst,\n            hookState: ctx.hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('persist', context, function(err) {\n            if (err) return done(err);\n            connector.upsertWithWhere(modelName, ctx.where, update, options, done);\n          });\n        }\n        function done(err, data, info) {\n          if (err) return cb(err);\n          var contxt = {\n            Model: Model,\n            data: data,\n            isNewInstance: info && info.isNewInstance,\n            hookState: ctx.hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('loaded', contxt, function(err) {\n            if (err) return cb(err);\n            var obj;\n            if (contxt.data && !(contxt.data instanceof Model)) {\n              inst._initProperties(contxt.data, {persisted: true});\n              obj = inst;\n            } else {\n              obj = contxt.data;\n            }\n            var context = {\n              Model: Model,\n              instance: obj,\n              isNewInstance: info ? info.isNewInstance : undefined,\n              hookState: hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('after save', context, function(err) {\n              cb(err, obj);\n            });\n          });\n        }\n      });\n    } else {\n      var opts = {notify: false};\n      if (ctx.options && ctx.options.transaction) {\n        opts.transaction = ctx.options.transaction;\n      }\n      self.find({where: ctx.query.where}, opts, function(err, instances) {\n        if (err) return cb(err);\n        var modelsLength = instances.length;\n        if (modelsLength === 0)  {\n          self.create(data, options, cb);\n        } else if (modelsLength === 1) {\n          var modelInst = instances[0];\n          modelInst.updateAttributes(data, options, cb);\n        } else {\n          process.nextTick(function() {\n            var error = new Error('There are multiple instances found.' +\n                'Upsert Operation will not be performed!');\n            error.statusCode = 400;\n            cb(error);\n          });\n        }\n      });\n    }\n  }\n  return cb.promise;\n};\n/**\n * Replace or insert a model instance: replace exiting record if one is found, such that parameter `data.id` matches `id` of model instance;\n * otherwise, insert a new record.\n *\n * @param {Object} data The model instance data\n * @param {Object} [options] Options for replaceOrCreate\n * @param {Function} cb The callback function (optional).\n */\n\nDataAccessObject.replaceOrCreate = function replaceOrCreate(data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (cb === undefined) {\n    if (typeof options === 'function') {\n      // replaceOrCreta(data,cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  data = data || {};\n  options = options || {};\n\n  assert(typeof data === 'object', 'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var hookState = {};\n\n  var self = this;\n  var Model = this;\n  var connector = Model.getConnector();\n\n  var id = getIdValue(this, data);\n  if (id === undefined || id === null) {\n    return this.create(data, options, cb);\n  }\n\n  var forceId = this.settings.forceId;\n  if (forceId) {\n    return Model.replaceById(id, data, options, cb);\n  }\n\n  var inst;\n  if (data instanceof Model) {\n    inst = data;\n  } else {\n    inst = new Model(data);\n  }\n\n  var strict = inst.__strict;\n  var context = {\n    Model: Model,\n    query: byIdQuery(Model, id),\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('access', context, doReplaceOrCreate);\n\n  function doReplaceOrCreate(err, ctx) {\n    if (err) return cb(err);\n\n    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);\n    var where = ctx.query.where;\n    if (connector.replaceOrCreate && isOriginalQuery) {\n      var context = {\n        Model: Model,\n        instance: inst,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('before save', context, function(err, ctx) {\n        if (err) return cb(err);\n        var update = inst.toObject(false);\n        if (strict) {\n          applyStrictCheck(Model, strict, update, inst, validateAndCallConnector);\n        } else {\n          validateAndCallConnector();\n        }\n\n        function validateAndCallConnector(err) {\n          if (err) return cb(err);\n          Model.applyProperties(update, inst);\n          Model = Model.lookupModel(update);\n\n          var connector = self.getConnector();\n\n          if (options.validate === false) {\n            return callConnector();\n          }\n\n          // only when options.validate is not set, take model-setting into consideration\n          if (options.validate === undefined && Model.settings.automaticValidation === false) {\n            return callConnector();\n          }\n\n          inst.isValid(function(valid) {\n            if (!valid) return cb(new ValidationError(inst), inst);\n            callConnector();\n          }, update, options);\n\n          function callConnector() {\n            update = removeUndefined(update);\n            context = {\n              Model: Model,\n              where: where,\n              data: update,\n              currentInstance: inst,\n              hookState: ctx.hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('persist', context, function(err) {\n              if (err) return done(err);\n              connector.replaceOrCreate(Model.modelName, context.data, options, done);\n            });\n          }\n          function done(err, data, info) {\n            if (err) return cb(err);\n            var context = {\n              Model: Model,\n              data: data,\n              isNewInstance: info ? info.isNewInstance : undefined,\n              hookState: ctx.hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('loaded', context, function(err) {\n              if (err) return cb(err);\n\n              var obj;\n              if (data && !(data instanceof Model)) {\n                inst._initProperties(data, {persisted: true});\n                obj = inst;\n              } else {\n                obj = data;\n              }\n              if (err) {\n                cb(err, obj);\n              } else {\n                var context = {\n                  Model: Model,\n                  instance: obj,\n                  isNewInstance: info ? info.isNewInstance : undefined,\n                  hookState: hookState,\n                  options: options,\n                };\n\n                Model.notifyObserversOf('after save', context, function(err) {\n                  cb(err, obj, info);\n                });\n              }\n            });\n          }\n        }\n      });\n    } else {\n      var opts = {notify: false};\n      if (ctx.options && ctx.options.transaction) {\n        opts.transaction = ctx.options.transaction;\n      }\n      Model.findOne({where: ctx.query.where}, opts, function(err, found) {\n        if (err) return cb(err);\n        if (!isOriginalQuery) {\n          // The custom query returned from a hook may hide the fact that\n          // there is already a model with `id` value `data[idName(Model)]`\n          var pkName = idName(Model);\n          delete data[pkName];\n          if (found) id = found[pkName];\n        }\n        if (found) {\n          self.replaceById(id, data, options, cb);\n        } else {\n          Model = self.lookupModel(data);\n          var obj = new Model(data);\n          obj.save(options, cb);\n        }\n      });\n    }\n  }\n  return cb.promise;\n};\n\n/**\n * Find one record that matches specified query criteria.  Same as `find`, but limited to one record, and this function returns an\n * object, not a collection.\n * If the specified instance is not found, then create it using data provided as second argument.\n *\n * @param {Object} query Search conditions. See [find](#dataaccessobjectfindquery-callback) for query format.\n * For example: `{where: {test: 'me'}}`.\n * @param {Object} data Object to create.\n * @param {Object} [options] Option for findOrCreate\n * @param {Function} cb Callback called with (err, instance, created)\n */\nDataAccessObject.findOrCreate = function findOrCreate(query, data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  assert(arguments.length >= 1, 'At least one argument is required');\n  if (data === undefined && options === undefined && cb === undefined) {\n    assert(typeof query === 'object', 'Single argument must be data object');\n    // findOrCreate(data);\n    // query will be built from data, and method will return Promise\n    data = query;\n    query = {where: data};\n  } else  if (options === undefined && cb === undefined) {\n    if (typeof data === 'function') {\n      // findOrCreate(data, cb);\n      // query will be built from data\n      cb = data;\n      data = query;\n      query = {where: data};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // findOrCreate(query, data, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  query = query || {where: {}};\n  data = data || {};\n  options = options || {};\n\n  assert(typeof query === 'object', 'The query argument must be an object');\n  assert(typeof data === 'object', 'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var hookState = {};\n\n  var Model = this;\n  var self = this;\n  var connector = Model.getConnector();\n\n  function _findOrCreate(query, data, currentInstance) {\n    var modelName = self.modelName;\n    function findOrCreateCallback(err, data, created) {\n      if (err) return cb(err);\n      var context = {\n        Model: Model,\n        data: data,\n        isNewInstance: created,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('loaded', context, function(err) {\n        if (err) return cb(err);\n\n        var obj, Model = self.lookupModel(data);\n\n        if (data) {\n          obj = new Model(data, {fields: query.fields, applySetters: false,\n            persisted: true});\n        }\n\n        if (created) {\n          var context = {\n            Model: Model,\n            instance: obj,\n            isNewInstance: true,\n            hookState: hookState,\n            options: options,\n          };\n          Model.notifyObserversOf('after save', context, function(err) {\n            if (cb.promise) {\n              cb(err, [obj, created]);\n            } else {\n              cb(err, obj, created);\n            }\n          });\n        } else {\n          if (cb.promise) {\n            cb(err, [obj, created]);\n          } else {\n            cb(err, obj, created);\n          }\n        }\n      });\n    }\n\n    data = removeUndefined(data);\n    var context = {\n      Model: Model,\n      where: query.where,\n      data: data,\n      isNewInstance: true,\n      currentInstance: currentInstance,\n      hookState: hookState,\n      options: options,\n    };\n\n    Model.notifyObserversOf('persist', context, function(err) {\n      if (err) return cb(err);\n\n      if (connector.findOrCreate.length === 5) {\n        connector.findOrCreate(modelName, query, self._forDB(context.data), options, findOrCreateCallback);\n      } else {\n        connector.findOrCreate(modelName, query, self._forDB(context.data), findOrCreateCallback);\n      }\n    });\n  }\n\n  if (connector.findOrCreate) {\n    query.limit = 1;\n\n    try {\n      this._normalize(query, options);\n    } catch (err) {\n      process.nextTick(function() {\n        cb(err);\n      });\n      return cb.promise;\n    }\n\n    this.applyScope(query);\n\n    var context = {\n      Model: Model,\n      query: query,\n      hookState: hookState,\n      options: options,\n    };\n    Model.notifyObserversOf('access', context, function(err, ctx) {\n      if (err) return cb(err);\n\n      var query = ctx.query;\n\n      var enforced = {};\n      var Model = self.lookupModel(data);\n      var obj = data instanceof Model ? data : new Model(data);\n\n      Model.applyProperties(enforced, obj);\n      obj.setAttributes(enforced);\n\n      var context = {\n        Model: Model,\n        instance: obj,\n        isNewInstance: true,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('before save', context, function(err, ctx) {\n        if (err) return cb(err);\n\n        var obj = ctx.instance;\n        var data = obj.toObject(true);\n\n        // options has precedence on model-setting\n        if (options.validate === false) {\n          return _findOrCreate(query, data, obj);\n        }\n\n        // only when options.validate is not set, take model-setting into consideration\n        if (options.validate === undefined && Model.settings.automaticValidation === false) {\n          return _findOrCreate(query, data, obj);\n        }\n\n        // validation required\n        obj.isValid(function(valid) {\n          if (valid) {\n            _findOrCreate(query, data, obj);\n          } else {\n            cb(new ValidationError(obj), obj);\n          }\n        }, data, options);\n      });\n    });\n  } else {\n    Model.findOne(query, options, function(err, record) {\n      if (err) return cb(err);\n      if (record) {\n        if (cb.promise) {\n          return cb(null, [record, false]);\n        } else {\n          return cb(null, record, false);\n        }\n      }\n      Model.create(data, options, function(err, record) {\n        if (cb.promise) {\n          cb(err, [record, record != null]);\n        } else {\n          cb(err, record, record != null);\n        }\n      });\n    });\n  }\n  return cb.promise;\n};\n\n/**\n * Check whether a model instance exists in database\n *\n * @param {id} id Identifier of object (primary key value)\n * @param {Object} [options] Options\n * @param {Function} cb Callback function called with (err, exists: Bool)\n */\nDataAccessObject.exists = function exists(id, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  assert(arguments.length >= 1, 'The id argument is required');\n  if (cb === undefined) {\n    if (typeof options === 'function') {\n      // exists(id, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  if (id !== undefined && id !== null && id !== '') {\n    this.count(byIdQuery(this, id).where, options, function(err, count) {\n      cb(err, err ? false : count === 1);\n    });\n  } else {\n    process.nextTick(function() {\n      cb(new Error(g.f('{{Model::exists}} requires the {{id}} argument')));\n    });\n  }\n  return cb.promise;\n};\n\n/**\n * Find model instance by ID.\n *\n * Example:\n * ```js\n * User.findById(23, function(err, user) {\n *   console.info(user.id); // 23\n * });\n * ```\n *\n * @param {*} id Primary key value\n * @param {Object} [filter] The filter that contains `include` or `fields`.\n * Other settings such as `where`, `order`, `limit`, or `offset` will be\n * ignored.\n * @param {Object} [options] Options\n * @param {Function} cb Callback called with (err, instance)\n */\nDataAccessObject.findById = function findById(id, filter, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  assert(arguments.length >= 1, 'The id argument is required');\n\n  if (options === undefined && cb === undefined) {\n    if (typeof filter === 'function') {\n      // findById(id, cb)\n      cb = filter;\n      filter = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // findById(id, query, cb)\n      cb = options;\n      options = {};\n      if (typeof filter === 'object' && !(filter.include || filter.fields)) {\n        // If filter doesn't have include or fields, assuming it's options\n        options = filter;\n        filter = {};\n      }\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n  filter = filter || {};\n\n  assert(typeof filter === 'object', 'The filter argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  if (isPKMissing(this, cb)) {\n    return cb.promise;\n  } else if (id == null || id === '') {\n    process.nextTick(function() {\n      cb(new Error(g.f('{{Model::findById}} requires the {{id}} argument')));\n    });\n  } else {\n    var query = byIdQuery(this, id);\n    if (filter.include) {\n      query.include = filter.include;\n    }\n    if (filter.fields) {\n      query.fields = filter.fields;\n    }\n    this.findOne(query, options, cb);\n  }\n  return cb.promise;\n};\n\n/**\n * Find model instances by ids\n * @param {Array} ids An array of ids\n * @param {Object} query Query filter\n * @param {Object} [options] Options\n * @param {Function} cb Callback called with (err, instance)\n */\nDataAccessObject.findByIds = function(ids, query, options, cb) {\n  if (options === undefined && cb === undefined) {\n    if (typeof query === 'function') {\n      // findByIds(ids, cb)\n      cb = query;\n      query = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // findByIds(ids, query, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n  query = query || {};\n\n  assert(Array.isArray(ids), 'The ids argument must be an array');\n  assert(typeof query === 'object', 'The query argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  if (isPKMissing(this, cb)) {\n    return cb.promise;\n  } else if (ids.length === 0) {\n    process.nextTick(function() { cb(null, []); });\n    return cb.promise;\n  }\n\n  var filter = {where: {}};\n  var pk = idName(this);\n  filter.where[pk] = {inq: [].concat(ids)};\n  mergeQuery(filter, query || {});\n\n  // to know if the result need to be sorted by ids or not\n  // this variable need to be initialized before the call to find, because filter is updated during the call with an order\n  var toSortObjectsByIds = filter.order ? false : true;\n\n  this.find(filter, options, function(err, results) {\n    cb(err, toSortObjectsByIds ? utils.sortObjectsByIds(pk, ids, results) : results);\n  });\n  return cb.promise;\n};\n\nfunction convertNullToNotFoundError(ctx, cb) {\n  if (ctx.result !== null) return cb();\n\n  var modelName = ctx.method.sharedClass.name;\n  var id = ctx.getArgByName('id');\n  var msg = g.f('Unknown \"%s\" {{id}} \"%s\".', modelName, id);\n  var error = new Error(msg);\n  error.statusCode = error.status = 404;\n  cb(error);\n}\n\n// alias function for backwards compat.\nDataAccessObject.all = function() {\n  return DataAccessObject.find.apply(this, arguments);\n};\n\n/**\n * Get settings via hiarchical determiniation\n *\n * @param {String} key The setting key\n */\nDataAccessObject._getSetting = function(key) {\n  // Check for settings in model\n  var m = this.definition;\n  if (m && m.settings && m.settings[key]) {\n    return m.settings[key];\n  }\n\n  // Check for settings in connector\n  var ds = this.getDataSource();\n  if (ds && ds.settings && ds.settings[key]) {\n    return ds.settings[key];\n  }\n\n  return;\n};\n\nvar operators = {\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<=',\n  between: 'BETWEEN',\n  inq: 'IN',\n  nin: 'NOT IN',\n  neq: '!=',\n  like: 'LIKE',\n  nlike: 'NOT LIKE',\n  ilike: 'ILIKE',\n  nilike: 'NOT ILIKE',\n  regexp: 'REGEXP',\n};\n\n/*\n * Normalize the filter object and throw errors if invalid values are detected\n * @param {Object} filter The query filter object\n * @options {Object} [options] Optional options to use.\n * @property {Boolean} allowExtendedOperators.\n * @returns {Object} The normalized filter object\n * @private\n */\nDataAccessObject._normalize = function(filter, options) {\n  if (!filter) {\n    return undefined;\n  }\n  var err = null;\n  if ((typeof filter !== 'object') || Array.isArray(filter)) {\n    err = new Error(g.f('The query filter %j is not an {{object}}', filter));\n    err.statusCode = 400;\n    throw err;\n  }\n  if (filter.limit || filter.skip || filter.offset) {\n    var limit = Number(filter.limit || 100);\n    var offset = Number(filter.skip || filter.offset || 0);\n    if (isNaN(limit) || limit <= 0 || Math.ceil(limit) !== limit) {\n      err = new Error(g.f('The {{limit}} parameter %j is not valid',\n        filter.limit));\n      err.statusCode = 400;\n      throw err;\n    }\n    if (isNaN(offset) || offset < 0 || Math.ceil(offset) !== offset) {\n      err = new Error(g.f('The {{offset/skip}} parameter %j is not valid',\n          filter.skip || filter.offset));\n      err.statusCode = 400;\n      throw err;\n    }\n    filter.limit = limit;\n    filter.offset = offset;\n    filter.skip = offset;\n  }\n\n  if (filter.order) {\n    var order = filter.order;\n    if (!Array.isArray(order)) {\n      order = [order];\n    }\n    var fields = [];\n    for (var i = 0, m = order.length; i < m; i++) {\n      if (typeof order[i] === 'string') {\n        // Normalize 'f1 ASC, f2 DESC, f3' to ['f1 ASC', 'f2 DESC', 'f3']\n        var tokens = order[i].split(/(?:\\s*,\\s*)+/);\n        for (var t = 0, n = tokens.length; t < n; t++) {\n          var token = tokens[t];\n          if (token.length === 0) {\n            // Skip empty token\n            continue;\n          }\n          var parts = token.split(/\\s+/);\n          if (parts.length >= 2) {\n            var dir = parts[1].toUpperCase();\n            if (dir === 'ASC' || dir === 'DESC') {\n              token = parts[0] + ' ' + dir;\n            } else {\n              err = new Error(g.f('The {{order}} %j has invalid direction', token));\n              err.statusCode = 400;\n              throw err;\n            }\n          }\n          fields.push(token);\n        }\n      } else {\n        err = new Error(g.f('The order %j is not valid', order[i]));\n        err.statusCode = 400;\n        throw err;\n      }\n    }\n    if (fields.length === 1 && typeof filter.order === 'string') {\n      filter.order = fields[0];\n    } else {\n      filter.order = fields;\n    }\n  }\n\n  // normalize fields as array of included property names\n  if (filter.fields) {\n    filter.fields = fieldsToArray(filter.fields,\n      Object.keys(this.definition.properties), this.settings.strict);\n  }\n\n  var handleUndefined =  this._getSetting('normalizeUndefinedInQuery');\n  // alter configuration of how removeUndefined handles undefined values\n  filter = removeUndefined(filter, handleUndefined);\n  this._coerce(filter.where, options);\n  return filter;\n};\n\nfunction DateType(arg) {\n  var d = new Date(arg);\n  if (isNaN(d.getTime())) {\n    throw new Error(g.f('Invalid date: %s', arg));\n  }\n  return d;\n}\n\nfunction BooleanType(arg) {\n  if (typeof arg === 'string') {\n    switch (arg) {\n      case 'true':\n      case '1':\n        return true;\n      case 'false':\n      case '0':\n        return false;\n    }\n  }\n  if (arg == null) {\n    return null;\n  }\n  return Boolean(arg);\n}\n\nfunction NumberType(val) {\n  var num = Number(val);\n  return !isNaN(num) ? num : val;\n}\n\nfunction coerceArray(val) {\n  if (Array.isArray(val)) {\n    return val;\n  }\n\n  if (!utils.isPlainObject(val)) {\n    throw new Error(g.f('Value is not an {{array}} or {{object}} with sequential numeric indices'));\n  }\n\n  // It is an object, check if empty\n  var props = Object.keys(val);\n\n  if (props.length === 0) {\n    throw new Error(g.f('Value is an empty {{object}}'));\n  }\n\n  var arrayVal = new Array(props.length);\n  for (var i = 0; i < arrayVal.length; ++i) {\n    if (!val.hasOwnProperty(i)) {\n      throw new Error(g.f('Value is not an {{array}} or {{object}} with sequential numeric indices'));\n    }\n\n    arrayVal[i] = val[i];\n  }\n\n  return arrayVal;\n}\n\n/*\n * Coerce values based the property types\n * @param {Object} where The where clause\n * @options {Object} [options] Optional options to use.\n * @property {Boolean} allowExtendedOperators.\n * @returns {Object} The coerced where clause\n * @private\n */\nDataAccessObject._coerce = function(where, options) {\n  var self = this;\n  if (!where) {\n    return where;\n  }\n\n  options = options || {};\n\n  var err;\n  if (typeof where !== 'object' || Array.isArray(where)) {\n    err = new Error(g.f('The where clause %j is not an {{object}}', where));\n    err.statusCode = 400;\n    throw err;\n  }\n\n  var props = self.definition.properties;\n  for (var p in where) {\n    // Handle logical operators\n    if (p === 'and' || p === 'or' || p === 'nor') {\n      var clauses = where[p];\n      try {\n        clauses = coerceArray(clauses);\n      } catch (e) {\n        err = new Error(g.f('The %s operator has invalid clauses %j: %s', p, clauses, e.message));\n        err.statusCode = 400;\n        throw err;\n      }\n\n      for (var k = 0; k < clauses.length; k++) {\n        self._coerce(clauses[k], options);\n      }\n\n      continue;\n    }\n    var DataType = props[p] && props[p].type;\n    if (!DataType) {\n      continue;\n    }\n    if (Array.isArray(DataType) || DataType === Array) {\n      DataType = DataType[0];\n    }\n    if (DataType === Date) {\n      DataType = DateType;\n    } else if (DataType === Boolean) {\n      DataType = BooleanType;\n    } else if (DataType === Number) {\n      // This fixes a regression in mongodb connector\n      // For numbers, only convert it produces a valid number\n      // LoopBack by default injects a number id. We should fix it based\n      // on the connector's input, for example, MongoDB should use string\n      // while RDBs typically use number\n      DataType = NumberType;\n    }\n\n    if (!DataType) {\n      continue;\n    }\n\n    if (DataType.prototype instanceof BaseModel) {\n      continue;\n    }\n\n    if (DataType === geo.GeoPoint) {\n      // Skip the GeoPoint as the near operator breaks the assumption that\n      // an operation has only one property\n      // We should probably fix it based on\n      // http://docs.mongodb.org/manual/reference/operator/query/near/\n      // The other option is to make operators start with $\n      continue;\n    }\n\n    var val = where[p];\n    if (val === null || val === undefined) {\n      continue;\n    }\n    // Check there is an operator\n    var operator = null;\n    var exp = val;\n    if (val.constructor === Object) {\n      for (var op in operators) {\n        if (op in val) {\n          val = val[op];\n          operator = op;\n          switch (operator) {\n            case 'inq':\n            case 'nin':\n            case 'between':\n              try {\n                val = coerceArray(val);\n              } catch (e) {\n                err = new Error(g.f('The %s property has invalid clause %j: %s', p, where[p], e));\n                err.statusCode = 400;\n                throw err;\n              }\n\n              if (operator === 'between' && val.length !== 2) {\n                err = new Error(g.f(\n                  'The %s property has invalid clause %j: Expected precisely 2 values, received %d',\n                  p,\n                  where[p],\n                  val.length));\n                err.statusCode = 400;\n                throw err;\n              }\n              break;\n            case 'like':\n            case 'nlike':\n            case 'ilike':\n            case 'nilike':\n              if (!(typeof val === 'string' || val instanceof RegExp)) {\n                err = new Error(g.f(\n                  'The %s property has invalid clause %j: Expected a string or RegExp',\n                  p,\n                  where[p]));\n                err.statusCode = 400;\n                throw err;\n              }\n              break;\n            case 'regexp':\n              val = utils.toRegExp(val);\n              if (val instanceof Error) {\n                val.statusCode = 400;\n                throw err;\n              }\n              break;\n          }\n          break;\n        }\n      }\n    }\n\n    try {\n      // Coerce val into an array if it resembles an array-like object\n      val = coerceArray(val);\n    } catch (e) {\n      // NOOP when not coercable into an array.\n    }\n\n    // Coerce the array items\n    if (Array.isArray(val)) {\n      for (var i = 0; i < val.length; i++) {\n        if (val[i] !== null && val[i] !== undefined) {\n          if (!(val[i] instanceof RegExp)) {\n            val[i] = DataType(val[i]);\n          }\n        }\n      }\n    } else {\n      if (val != null) {\n        const allowExtendedOperators = self._allowExtendedOperators(options);\n        if (operator === null && val instanceof RegExp) {\n          // Normalize {name: /A/} to {name: {regexp: /A/}}\n          operator = 'regexp';\n        } else if (operator === 'regexp' && val instanceof RegExp) {\n          // Do not coerce regex literals/objects\n        } else if ((operator === 'like' || operator === 'nlike' ||\n            operator === 'ilike' || operator === 'nilike') && val instanceof RegExp) {\n          // Do not coerce RegExp operator value\n        } else if (allowExtendedOperators && typeof val === 'object') {\n          // Do not coerce object values when extended operators are allowed\n        } else {\n          val = DataType(val);\n        }\n      }\n    }\n    // Rebuild {property: {operator: value}}\n    if (operator) {\n      var value = {};\n      value[operator] = val;\n      if (exp.options) {\n        // Keep options for operators\n        value.options = exp.options;\n      }\n      val = value;\n    }\n    where[p] = val;\n  }\n  return where;\n};\n\n/**\n * Find all instances of Model that match the specified query.\n * Fields used for filter and sort should be declared with `{index: true}` in model definition.\n * See [Querying models](http://docs.strongloop.com/display/DOC/Querying+models) for more information.\n *\n * For example, find the second page of ten users over age 21 in descending order exluding the password property.\n *\n * ```js\n * User.find({\n *   where: {\n *     age: {gt: 21}},\n *     order: 'age DESC',\n *     limit: 10,\n *     skip: 10,\n *     fields: {password: false}\n *   },\n *   console.log\n * );\n * ```\n *\n * @options {Object} [query] Optional JSON object that specifies query criteria and parameters.\n * @property {Object} where Search criteria in JSON format `{ key: val, key2: {gt: 'val2'}}`.\n * Operations:\n * - gt: >\n * - gte: >=\n * - lt: <\n * - lte: <=\n * - between\n * - inq: IN\n * - nin: NOT IN\n * - neq: !=\n * - like: LIKE\n * - nlike: NOT LIKE\n * - ilike: ILIKE\n * - nilike: NOT ILIKE\n * - regexp: REGEXP\n *\n * You can also use `and` and `or` operations.  See [Querying models](http://docs.strongloop.com/display/DOC/Querying+models) for more information.\n * @property {String|Object|Array} include Allows you to load relations of several objects and optimize numbers of requests.\n * Format examples;\n * - `'posts'`: Load posts\n * - `['posts', 'passports']`: Load posts and passports\n * - `{'owner': 'posts'}`: Load owner and owner's posts\n * - `{'owner': ['posts', 'passports']}`: Load owner, owner's posts, and owner's passports\n * - `{'owner': [{posts: 'images'}, 'passports']}`: Load owner, owner's posts, owner's posts' images, and owner's passports\n * See `DataAccessObject.include()`.\n * @property {String} order Sort order.  Format: `'key1 ASC, key2 DESC'`\n * @property {Number} limit Maximum number of instances to return.\n * @property {Number} skip Number of instances to skip.\n * @property {Number} offset Alias for `skip`.\n * @property {Object|Array|String} fields Included/excluded fields.\n * - `['foo']` or `'foo'` - include only the foo property\n *  - `['foo', 'bar']` - include the foo and bar properties.  Format:\n *  - `{foo: true}` - include only foo\n * - `{bat: false}` - include all properties, exclude bat\n *\n * @param {Function} cb Optional callback function.  Call this function with two arguments: `err` (null or Error) and an array of instances.\n * @return {Promise} results If no callback function is provided, a promise (which resolves to an array of instances) is returned\n */\n\nDataAccessObject.find = function find(query, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (options === undefined && cb === undefined) {\n    if (typeof query === 'function') {\n      // find(cb);\n      cb = query;\n      query = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // find(query, cb);\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  query = query || {};\n  options = options || {};\n\n  assert(typeof query === 'object', 'The query argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var hookState = {};\n  var self = this;\n  var connector = self.getConnector();\n\n  assert(typeof connector.all === 'function',\n    'all() must be implemented by the connector');\n\n  try {\n    this._normalize(query, options);\n  } catch (err) {\n    process.nextTick(function() {\n      cb(err);\n    });\n    return cb.promise;\n  }\n\n  this.applyScope(query);\n\n  var near = query && geo.nearFilter(query.where);\n  var supportsGeo = !!connector.buildNearFilter;\n\n  if (near) {\n    if (supportsGeo) {\n      // convert it\n      connector.buildNearFilter(query, near);\n    } else if (query.where) {\n      // do in memory query\n      // using all documents\n      // TODO [fabien] use default scope here?\n      if (options.notify === false) {\n        queryGeo(query);\n      } else {\n        withNotifyGeo();\n      }\n\n      function withNotifyGeo() {\n        var context = {\n          Model: self,\n          query: query,\n          hookState: hookState,\n          options: options,\n        };\n        self.notifyObserversOf('access', context, function(err, ctx) {\n          if (err) return cb(err);\n          queryGeo(ctx.query);\n        });\n      }\n\n      function queryGeo(query) {\n        function geoCallbackWithoutNotify(err, data) {\n          var memory = new Memory();\n          var modelName = self.modelName;\n\n          if (err) {\n            cb(err);\n          } else if (Array.isArray(data)) {\n            memory.define({\n              properties: self.dataSource.definitions[self.modelName].properties,\n              settings: self.dataSource.definitions[self.modelName].settings,\n              model: self,\n            });\n\n            data.forEach(function(obj) {\n              memory.create(modelName, obj, options, function() {\n                // noop\n              });\n            });\n\n            // FIXME: apply \"includes\" and other transforms - see allCb below\n            memory.all(modelName, query, options, cb);\n          } else {\n            cb(null, []);\n          }\n        }\n\n        function geoCallbackWithNotify(err, data) {\n          if (err) return cb(err);\n\n          async.map(data, function(item, next) {\n            var context = {\n              Model: self,\n              data: item,\n              isNewInstance: false,\n              hookState: hookState,\n              options: options,\n            };\n\n            self.notifyObserversOf('loaded', context, function(err) {\n              if (err) return next(err);\n              next(null, context.data);\n            });\n          }, function(err, results) {\n            if (err) return cb(err);\n            geoCallbackWithoutNotify(null, results);\n          });\n        }\n\n        var geoCallback = options.notify === false ? geoCallbackWithoutNotify : geoCallbackWithNotify;\n        if (connector.all.length === 4) {\n          connector.all(self.modelName, {}, options, geoCallback);\n        } else {\n          connector.all(self.modelName, {}, geoCallback);\n        }\n      }\n      // already handled\n      return cb.promise;\n    }\n  }\n\n  var allCb = function(err, data) {\n    if (!err && Array.isArray(data)) {\n      async.map(data, function(item, next) {\n        var Model = self.lookupModel(item);\n        if (options.notify === false) {\n          buildResult(item, next);\n        } else {\n          withNotify(item, next);\n        }\n\n        function buildResult(data, callback) {\n          var ctorOpts = {\n            fields: query.fields,\n            applySetters: false,\n            persisted: true,\n          };\n          var obj;\n          try {\n            obj = new Model(data, ctorOpts);\n          } catch (err) {\n            return callback(err);\n          }\n\n          if (query && query.include) {\n            if (query.collect) {\n              // The collect property indicates that the query is to return the\n              // standalone items for a related model, not as child of the parent object\n              // For example, article.tags\n              obj = obj.__cachedRelations[query.collect];\n              if (obj === null) {\n                obj = undefined;\n              }\n            } else {\n              // This handles the case to return parent items including the related\n              // models. For example, Article.find({include: 'tags'}, ...);\n              // Try to normalize the include\n              var includes = Inclusion.normalizeInclude(query.include || []);\n              includes.forEach(function(inc) {\n                var relationName = inc;\n                if (utils.isPlainObject(inc)) {\n                  relationName = Object.keys(inc)[0];\n                }\n\n                // Promote the included model as a direct property\n                var included = obj.__cachedRelations[relationName];\n                if (Array.isArray(included)) {\n                  included = new List(included, null, obj);\n                }\n                if (included) obj.__data[relationName] = included;\n              });\n              delete obj.__data.__cachedRelations;\n            }\n          }\n\n          callback(null, obj);\n        }\n\n        function withNotify(data, callback) {\n          var context = {\n            Model: Model,\n            data: data,\n            isNewInstance: false,\n            hookState: hookState,\n            options: options,\n          };\n\n          Model.notifyObserversOf('loaded', context, function(err) {\n            if (err) return callback(err);\n            buildResult(context.data, callback);\n          });\n        }\n      },\n      function(err, results) {\n        if (err) return cb(err);\n\n        // When applying query.collect, some root items may not have\n        // any related/linked item. We store `undefined` in the results\n        // array in such case, which is not desirable from API consumer's\n        // point of view.\n        results = results.filter(isDefined);\n\n        if (data && data.countBeforeLimit) {\n          results.countBeforeLimit = data.countBeforeLimit;\n        }\n        if (!supportsGeo && near) {\n          results = geo.filter(results, near);\n        }\n\n        cb(err, results);\n      });\n    } else {\n      cb(err, data || []);\n    }\n  };\n\n  if (options.notify === false) {\n    if (connector.all.length === 4) {\n      connector.all(self.modelName, query, options, allCb);\n    } else {\n      connector.all(self.modelName, query, allCb);\n    }\n  } else {\n    var context =  {\n      Model: this,\n      query: query,\n      hookState: hookState,\n      options: options,\n    };\n    this.notifyObserversOf('access', context, function(err, ctx) {\n      if (err) return cb(err);\n\n      connector.all.length === 4 ?\n        connector.all(self.modelName, ctx.query, options, allCb) :\n        connector.all(self.modelName, ctx.query, allCb);\n    });\n  }\n  return cb.promise;\n};\n\nfunction isDefined(value) {\n  return value !== undefined;\n}\n\n/**\n * Find one record, same as `find`, but limited to one result. This function returns an object, not a collection.\n *\n * @param {Object} query Search conditions.  See [find](#dataaccessobjectfindquery-callback) for query format.\n * For example: `{where: {test: 'me'}}`.\n * @param {Object} [options] Options\n * @param {Function} cb Callback function called with (err, instance)\n */\nDataAccessObject.findOne = function findOne(query, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (options === undefined && cb === undefined) {\n    if (typeof query === 'function') {\n      cb = query;\n      query = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  query = query || {};\n  options = options || {};\n\n  assert(typeof query === 'object', 'The query argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  query.limit = 1;\n  this.find(query, options, function(err, collection) {\n    if (err || !collection || !collection.length > 0) return cb(err, null);\n    cb(err, collection[0]);\n  });\n  return cb.promise;\n};\n\n/**\n * Destroy all matching records.\n * Delete all model instances from data source. Note: destroyAll method does not destroy hooks.\n * Example:\n *````js\n * Product.destroyAll({price: {gt: 99}}, function(err) {\n   // removed matching products\n * });\n * ````\n *\n * @param {Object} [where] Optional object that defines the criteria.  This is a \"where\" object. Do NOT pass a filter object.\n * @param {Object) [options] Options\n * @param {Function} [cb] Callback called with (err, info)\n */\nDataAccessObject.remove =\nDataAccessObject.deleteAll =\nDataAccessObject.destroyAll = function destroyAll(where, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  var Model = this;\n  var connector = Model.getConnector();\n\n  assert(typeof connector.destroyAll === 'function',\n    'destroyAll() must be implemented by the connector');\n\n  if (options === undefined && cb === undefined) {\n    if (typeof where === 'function') {\n      cb = where;\n      where = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  where = where || {};\n  options = options || {};\n\n  assert(typeof where === 'object', 'The where argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var hookState = {};\n\n  var query = {where: where};\n  this.applyScope(query);\n  where = query.where;\n\n  if (options.notify === false) {\n    doDelete(where);\n  } else {\n    query = {where: whereIsEmpty(where) ? {} : where};\n    var context = {\n      Model: Model,\n      query: query,\n      hookState: hookState,\n      options: options,\n    };\n    Model.notifyObserversOf('access', context, function(err, ctx) {\n      if (err) return cb(err);\n      var context = {\n        Model: Model,\n        where: ctx.query.where,\n        hookState: hookState,\n        options: options,\n      };\n      Model.notifyObserversOf('before delete', context, function(err, ctx) {\n        if (err) return cb(err);\n        doDelete(ctx.where);\n      });\n    });\n  }\n\n  function doDelete(where) {\n    var context = {\n      Model: Model,\n      where: whereIsEmpty(where) ? {} : where,\n      hookState: hookState,\n      options: options,\n    };\n\n    if (whereIsEmpty(where)) {\n      if (connector.destroyAll.length === 4) {\n        connector.destroyAll(Model.modelName, {}, options, done);\n      } else {\n        connector.destroyAll(Model.modelName, {}, done);\n      }\n    } else {\n      try {\n        // Support an optional where object\n        where = removeUndefined(where);\n        where = Model._coerce(where, options);\n      } catch (err) {\n        return process.nextTick(function() {\n          cb(err);\n        });\n      }\n\n      if (connector.destroyAll.length === 4) {\n        connector.destroyAll(Model.modelName, where, options, done);\n      } else {\n        connector.destroyAll(Model.modelName, where, done);\n      }\n    }\n\n    function done(err, info) {\n      if (err) return cb(err);\n\n      if (options.notify === false) {\n        return cb(err, info);\n      }\n\n      var context = {\n        Model: Model,\n        where: where,\n        hookState: hookState,\n        options: options,\n        info: info,\n      };\n      Model.notifyObserversOf('after delete', context, function(err) {\n        cb(err, info);\n      });\n    }\n  }\n  return cb.promise;\n};\n\nfunction whereIsEmpty(where) {\n  return !where ||\n     (typeof where === 'object' && Object.keys(where).length === 0);\n}\n\n/**\n * Delete the record with the specified ID.\n * Aliases are `destroyById` and `deleteById`.\n * @param {*} id The id value\n * @param {Function} cb Callback called with (err)\n */\n\n// [FIXME] rfeng: This is a hack to set up 'deleteById' first so that\n// 'deleteById' will be used as the name for strong-remoting to keep it backward\n// compatible for angular SDK\nDataAccessObject.removeById =\nDataAccessObject.destroyById =\nDataAccessObject.deleteById = function deleteById(id, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  assert(arguments.length >= 1, 'The id argument is required');\n  if (cb === undefined) {\n    if (typeof options === 'function') {\n      // destroyById(id, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  if (isPKMissing(this, cb)) {\n    return cb.promise;\n  } else if (id == null || id === '') {\n    process.nextTick(function() {\n      cb(new Error(g.f('{{Model::deleteById}} requires the {{id}} argument')));\n    });\n    return cb.promise;\n  }\n\n  var Model = this;\n\n  this.remove(byIdQuery(this, id).where, options, function(err, info) {\n    if (err) return cb(err);\n    var deleted = info && info.count > 0;\n    if (Model.settings.strictDelete && !deleted) {\n      err = new Error(g.f('No instance with {{id}} %s found for %s', id, Model.modelName));\n      err.code = 'NOT_FOUND';\n      err.statusCode = 404;\n      return cb(err);\n    }\n\n    cb(null, info);\n  });\n  return cb.promise;\n};\n\n/**\n * Return count of matched records. Optional query parameter allows you to count filtered set of model instances.\n * Example:\n *\n *```js\n * User.count({approved: true}, function(err, count) {\n *     console.log(count); // 2081\n * });\n * ```\n *\n * @param {Object} [where] Search conditions (optional)\n * @param {Object} [options] Options\n * @param {Function} cb Callback, called with (err, count)\n */\nDataAccessObject.count = function(where, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (options === undefined && cb === undefined) {\n    if (typeof where === 'function') {\n      // count(cb)\n      cb = where;\n      where = {};\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // count(where, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  where = where || {};\n  options = options || {};\n\n  assert(typeof where === 'object', 'The where argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var Model = this;\n  var connector = Model.getConnector();\n  assert(typeof connector.count === 'function',\n    'count() must be implemented by the connector');\n  assert(connector.count.length >= 3,\n    'count() must take at least 3 arguments');\n\n  var hookState = {};\n\n  var query = {where: where};\n  this.applyScope(query);\n  where = query.where;\n\n  try {\n    where = removeUndefined(where);\n    where = this._coerce(where, options);\n  } catch (err) {\n    process.nextTick(function() {\n      cb(err);\n    });\n    return cb.promise;\n  }\n\n  var context = {\n    Model: Model,\n    query: {where: where},\n    hookState: hookState,\n    options: options,\n  };\n  this.notifyObserversOf('access', context, function(err, ctx) {\n    if (err) return cb(err);\n    where = ctx.query.where;\n\n    if (connector.count.length <= 3) {\n      // Old signature, please note where is the last\n      // count(model, cb, where)\n      connector.count(Model.modelName, cb, where);\n    } else {\n      // New signature\n      // count(model, where, options, cb)\n      connector.count(Model.modelName, where, options, cb);\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Save instance. If the instance does not have an ID, call `create` instead.\n * Triggers: validate, save, update or create.\n * @options {Object} options Optional options to use.\n * @property {Boolean} validate Default is true.\n * @property {Boolean} throws  Default is false.\n * @param {Function} cb Callback function with err and object arguments\n */\nDataAccessObject.prototype.save = function(options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n  var Model = this.constructor;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n\n  assert(typeof options === 'object', 'The options argument should be an object');\n  assert(typeof cb === 'function', 'The cb argument should be a function');\n\n  if (isPKMissing(Model, cb)) {\n    return cb.promise;\n  }  else if (this.isNewRecord()) {\n    return Model.create(this, options, cb);\n  }\n\n  var hookState = {};\n\n  if (options.validate === undefined) {\n    if (Model.settings.automaticValidation === undefined) {\n      options.validate = true;\n    } else {\n      options.validate = Model.settings.automaticValidation;\n    }\n  }\n\n  if (options.throws === undefined) {\n    options.throws = false;\n  }\n\n  var inst = this;\n  var connector = inst.getConnector();\n  var modelName = Model.modelName;\n\n  var context = {\n    Model: Model,\n    instance: inst,\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('before save', context, function(err) {\n    if (err) return cb(err);\n\n    var data = inst.toObject(true);\n    Model.applyProperties(data, inst);\n    inst.setAttributes(data);\n\n    // validate first\n    if (!options.validate) {\n      return save();\n    }\n\n    inst.isValid(function(valid) {\n      if (valid) {\n        save();\n      } else {\n        var err = new ValidationError(inst);\n        // throws option is dangerous for async usage\n        if (options.throws) {\n          throw err;\n        }\n        cb(err, inst);\n      }\n    }, data, options);\n\n    // then save\n    function save() {\n      inst.trigger('save', function(saveDone) {\n        inst.trigger('update', function(updateDone) {\n          data = removeUndefined(data);\n          function saveCallback(err, unusedData, result) {\n            if (err) {\n              return cb(err, inst);\n            }\n\n            var context = {\n              Model: Model,\n              data: data,\n              isNewInstance: result && result.isNewInstance,\n              hookState: hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('loaded', context, function(err) {\n              if (err) return cb(err);\n\n              inst._initProperties(data, {persisted: true});\n\n              var context = {\n                Model: Model,\n                instance: inst,\n                isNewInstance: result && result.isNewInstance,\n                hookState: hookState,\n                options: options,\n              };\n              Model.notifyObserversOf('after save', context, function(err) {\n                if (err) return cb(err, inst);\n                updateDone.call(inst, function() {\n                  saveDone.call(inst, function() {\n                    cb(err, inst);\n                  });\n                });\n              });\n            });\n          }\n\n          context = {\n            Model: Model,\n            data: data,\n            where: byIdQuery(Model, getIdValue(Model, inst)).where,\n            currentInstance: inst,\n            hookState: hookState,\n            options: options,\n          };\n\n          Model.notifyObserversOf('persist', context, function(err) {\n            if (err) return cb(err);\n\n            if (connector.save.length === 4) {\n              connector.save(modelName, inst.constructor._forDB(data), options, saveCallback);\n            } else {\n              connector.save(modelName, inst.constructor._forDB(data), saveCallback);\n            }\n          });\n        }, data, cb);\n      }, data, cb);\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Update multiple instances that match the where clause\n *\n * Example:\n *\n *```js\n * Employee.update({managerId: 'x001'}, {managerId: 'x002'}, function(err) {\n *     ...\n * });\n * ```\n *\n * @param {Object} [where] Search conditions (optional)\n * @param {Object} data Changes to be made\n * @param {Object} [options] Options for update\n * @param {Function} cb Callback, called with (err, info)\n */\nDataAccessObject.update =\nDataAccessObject.updateAll = function(where, data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  assert(arguments.length >= 1, 'At least one argument is required');\n\n  if (data === undefined && options === undefined && cb === undefined && arguments.length === 1) {\n    data = where;\n    where = {};\n  } else if (options === undefined && cb === undefined) {\n    // One of:\n    // updateAll(data, cb)\n    // updateAll(where, data) -> Promise\n    if (typeof data === 'function') {\n      cb = data;\n      data = where;\n      where = {};\n    }\n  } else if (cb === undefined) {\n    // One of:\n    // updateAll(where, data, options) -> Promise\n    // updateAll(where, data, cb)\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n  }\n\n  data = data || {};\n  options = options || {};\n  cb = cb || utils.createPromiseCallback();\n\n  assert(typeof where === 'object', 'The where argument must be an object');\n  assert(typeof data === 'object', 'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var Model = this;\n  var connector = Model.getDataSource().connector;\n  assert(typeof connector.update === 'function',\n    'update() must be implemented by the connector');\n\n  var hookState = {};\n\n  var query = {where: where};\n  this.applyScope(query);\n  this.applyProperties(data);\n\n  where = query.where;\n\n  var context = {\n    Model: Model,\n    query: {where: where},\n    hookState: hookState,\n    options: options,\n  };\n  Model.notifyObserversOf('access', context, function(err, ctx) {\n    if (err) return cb(err);\n    var context = {\n      Model: Model,\n      where: ctx.query.where,\n      data: data,\n      hookState: hookState,\n      options: options,\n    };\n    Model.notifyObserversOf('before save', context,\n      function(err, ctx) {\n        if (err) return cb(err);\n        doUpdate(ctx.where, ctx.data);\n      });\n  });\n\n  function doUpdate(where, data) {\n    try {\n      where = removeUndefined(where);\n      where = Model._coerce(where, options);\n      data = removeUndefined(data);\n      data = Model._coerce(data, options);\n    } catch (err) {\n      return process.nextTick(function() {\n        cb(err);\n      });\n    }\n\n    function updateCallback(err, info) {\n      if (err) return cb(err);\n\n      var context = {\n        Model: Model,\n        where: where,\n        data: data,\n        hookState: hookState,\n        options: options,\n        info: info,\n      };\n      Model.notifyObserversOf('after save', context, function(err, ctx) {\n        return cb(err, info);\n      });\n    }\n\n    var context = {\n      Model: Model,\n      where: where,\n      data: data,\n      hookState: hookState,\n      options: options,\n    };\n    Model.notifyObserversOf('persist', context, function(err, ctx) {\n      if (err) return cb(err);\n\n      if (connector.update.length === 5) {\n        connector.update(Model.modelName, where, data, options, updateCallback);\n      } else {\n        connector.update(Model.modelName, where, data, updateCallback);\n      }\n    });\n  }\n  return cb.promise;\n};\n\nDataAccessObject.prototype.isNewRecord = function() {\n  return !this.__persisted;\n};\n\n/**\n * Return connector of current record\n * @private\n */\nDataAccessObject.prototype.getConnector = function() {\n  return this.getDataSource().connector;\n};\n\n/**\n * Delete object from persistence\n *\n * Triggers `destroy` hook (async) before and after destroying object\n *\n * @param {Object} [options] Options for delete\n * @param {Function} cb Callback\n */\nDataAccessObject.prototype.remove =\n  DataAccessObject.prototype.delete =\n    DataAccessObject.prototype.destroy = function(options, cb) {\n      var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n      if (connectionPromise) {\n        return connectionPromise;\n      }\n\n      if (cb === undefined && typeof options === 'function') {\n        cb = options;\n        options = {};\n      }\n\n      cb = cb || utils.createPromiseCallback();\n      options = options || {};\n\n      assert(typeof options === 'object', 'The options argument should be an object');\n      assert(typeof cb === 'function', 'The cb argument should be a function');\n\n      var inst = this;\n      var connector = this.getConnector();\n\n      var Model = this.constructor;\n      var id = getIdValue(this.constructor, this);\n      var hookState = {};\n\n      if (isPKMissing(Model, cb))\n        return cb.promise;\n\n      var context = {\n        Model: Model,\n        query: byIdQuery(Model, id),\n        hookState: hookState,\n        options: options,\n      };\n\n      Model.notifyObserversOf('access', context, function(err, ctx) {\n        if (err) return cb(err);\n        var context = {\n          Model: Model,\n          where: ctx.query.where,\n          instance: inst,\n          hookState: hookState,\n          options: options,\n        };\n        Model.notifyObserversOf('before delete', context, function(err, ctx) {\n          if (err) return cb(err);\n          doDeleteInstance(ctx.where);\n        });\n      });\n\n      function doDeleteInstance(where) {\n        if (!isWhereByGivenId(Model, where, id)) {\n          // A hook modified the query, it is no longer\n          // a simple 'delete model with the given id'.\n          // We must switch to full query-based delete.\n          Model.deleteAll(where, {notify: false}, function(err, info) {\n            if (err) return cb(err, false);\n            var deleted = info && info.count > 0;\n            if (Model.settings.strictDelete && !deleted) {\n              err = new Error(g.f('No instance with {{id}} %s found for %s', id, Model.modelName));\n              err.code = 'NOT_FOUND';\n              err.statusCode = 404;\n              return cb(err, false);\n            }\n            var context = {\n              Model: Model,\n              where: where,\n              instance: inst,\n              hookState: hookState,\n              options: options,\n              info: info,\n            };\n            Model.notifyObserversOf('after delete', context, function(err) {\n              cb(err, info);\n            });\n          });\n          return;\n        }\n\n        inst.trigger('destroy', function(destroyed) {\n          function destroyCallback(err, info) {\n            if (err) return cb(err);\n            var deleted = info && info.count > 0;\n            if (Model.settings.strictDelete && !deleted) {\n              err = new Error(g.f('No instance with {{id}} %s found for %s', id, Model.modelName));\n              err.code = 'NOT_FOUND';\n              err.statusCode = 404;\n              return cb(err);\n            }\n\n            destroyed(function() {\n              var context = {\n                Model: Model,\n                where: where,\n                instance: inst,\n                hookState: hookState,\n                options: options,\n                info: info,\n              };\n              Model.notifyObserversOf('after delete', context, function(err) {\n                cb(err, info);\n              });\n            });\n          }\n\n          if (connector.destroy.length === 4) {\n            connector.destroy(inst.constructor.modelName, id, options, destroyCallback);\n          } else {\n            connector.destroy(inst.constructor.modelName, id, destroyCallback);\n          }\n        }, null, cb);\n      }\n      return cb.promise;\n    };\n\n/**\n * Set a single attribute.\n * Equivalent to `setAttributes({name: value})`\n *\n * @param {String} name Name of property\n * @param {Mixed} value Value of property\n */\nDataAccessObject.prototype.setAttribute = function setAttribute(name, value) {\n  this[name] = value; // TODO [fabien] - currently not protected by applyProperties\n};\n\n/**\n * Update a single attribute.\n * Equivalent to `updateAttributes({name: value}, cb)`\n *\n * @param {String} name Name of property\n * @param {Mixed} value Value of property\n * @param {Function} cb Callback function called with (err, instance)\n */\nDataAccessObject.prototype.updateAttribute = function updateAttribute(name, value, options, cb) {\n  var data = {};\n  data[name] = value;\n  return this.updateAttributes(data, options, cb);\n};\n\n/**\n * Update set of attributes.\n *\n * @trigger `change` hook\n * @param {Object} data Data to update\n */\nDataAccessObject.prototype.setAttributes = function setAttributes(data) {\n  if (typeof data !== 'object') return;\n\n  this.constructor.applyProperties(data, this);\n\n  var Model = this.constructor;\n  var inst = this;\n\n  // update instance's properties\n  for (var key in data) {\n    inst.setAttribute(key, data[key]);\n  }\n\n  Model.emit('set', inst);\n};\n\nDataAccessObject.prototype.unsetAttribute = function unsetAttribute(name, nullify) {\n  if (nullify || this.constructor.definition.settings.persistUndefinedAsNull) {\n    this[name] = this.__data[name] = null;\n  } else {\n    delete this[name];\n    delete this.__data[name];\n  }\n};\n\n/**\n * Replace set of attributes.\n * Performs validation before replacing.\n *\n * @trigger `validation`, `save` and `update` hooks\n * @param {Object} data Data to replace\n * @param {Object} [options] Options for replace\n * @param {Function} cb Callback function called with (err, instance)\n */\nDataAccessObject.prototype.replaceAttributes = function(data, options, cb) {\n  var Model = this.constructor;\n  var id = getIdValue(this.constructor, this);\n  return Model.replaceById(id, data, options, cb);\n};\n\nDataAccessObject.replaceById = function(id, data, options, cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (cb === undefined) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n\n  assert((typeof data === 'object') && (data !== null),\n          'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var connector = this.getConnector();\n\n  var err;\n  if (typeof connector.replaceById !== 'function') {\n    err = new Error(g.f(\n      'The connector %s does not support {{replaceById}} operation. This is not a bug in LoopBack. ' +\n      'Please contact the authors of the connector, preferably via GitHub issues.',\n      connector.name));\n    return cb(err);\n  }\n\n  var pkName = idName(this);\n  if (!data[pkName]) data[pkName] = id;\n\n  var Model = this;\n  var inst = new Model(data, {persisted: true});\n  var enforced = {};\n  this.applyProperties(enforced, inst);\n  inst.setAttributes(enforced);\n  Model = this.lookupModel(data); // data-specific\n  if (Model !== inst.constructor) inst = new Model(data);\n  var strict = inst.__strict;\n\n  if (isPKMissing(Model, cb))\n    return cb.promise;\n\n  var model = Model.modelName;\n  var hookState = {};\n\n  if (id !== data[pkName]) {\n    err = new Error(g.f('{{id}} property (%s) ' +\n            'cannot be updated from %s to %s', pkName, id, data[pkName]));\n    err.statusCode = 400;\n    process.nextTick(function() { cb(err); });\n    return cb.promise;\n  }\n\n  var context = {\n    Model: Model,\n    instance: inst,\n    isNewInstance: false,\n    hookState: hookState,\n    options: options,\n  };\n\n  Model.notifyObserversOf('before save', context, function(err, ctx) {\n    if (err) return cb(err);\n\n    if (ctx.instance[pkName] !== id && !Model._warned.cannotOverwritePKInBeforeSaveHook) {\n      Model._warned.cannotOverwritePKInBeforeSaveHook = true;\n      g.warn('WARNING: {{id}} property cannot be changed from %s to %s for model:%s ' +\n        'in {{\\'before save\\'}} operation hook', id, inst[pkName], Model.modelName);\n    }\n\n    data = inst.toObject(false);\n\n    if (strict) {\n      applyStrictCheck(Model, strict, data, inst, validateAndCallConnector);\n    } else {\n      validateAndCallConnector(null, data);\n    }\n\n    function validateAndCallConnector(err, data) {\n      if (err) return cb(err);\n      data = removeUndefined(data);\n      // update instance's properties\n      inst.setAttributes(data);\n\n      var doValidate = true;\n      if (options.validate === undefined) {\n        if (Model.settings.automaticValidation !== undefined) {\n          doValidate = Model.settings.automaticValidation;\n        }\n      } else {\n        doValidate = options.validate;\n      }\n\n      if (doValidate) {\n        inst.isValid(function(valid) {\n          if (!valid) return cb(new ValidationError(inst), inst);\n\n          callConnector();\n        }, data, options);\n      } else {\n        callConnector();\n      }\n\n      function callConnector() {\n        copyData(data, inst);\n        var typedData = convertSubsetOfPropertiesByType(inst, data);\n        context.data = typedData;\n\n        function replaceCallback(err, data) {\n          if (err) return cb(err);\n\n          var ctx = {\n            Model: Model,\n            hookState: hookState,\n            data: context.data,\n            isNewInstance: false,\n            options: options,\n          };\n          Model.notifyObserversOf('loaded', ctx, function(err) {\n            if (err) return cb(err);\n\n            if (ctx.data[pkName] !== id && !Model._warned.cannotOverwritePKInLoadedHook) {\n              Model._warned.cannotOverwritePKInLoadedHook = true;\n              g.warn('WARNING: {{id}} property cannot be changed from %s to %s for model:%s in ' +\n                '{{\\'loaded\\'}} operation hook',\n                id, ctx.data[pkName], Model.modelName);\n            }\n\n            inst.__persisted = true;\n            ctx.data[pkName] = id;\n            inst.setAttributes(ctx.data);\n\n            var context = {\n              Model: Model,\n              instance: inst,\n              isNewInstance: false,\n              hookState: hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('after save', context, function(err) {\n              cb(err, inst);\n            });\n          });\n        }\n\n        var ctx = {\n          Model: Model,\n          where: byIdQuery(Model, id).where,\n          data: context.data,\n          isNewInstance: false,\n          currentInstance: inst,\n          hookState: hookState,\n          options: options,\n        };\n        Model.notifyObserversOf('persist', ctx, function(err) {\n          connector.replaceById(model, id,\n            inst.constructor._forDB(context.data), options, replaceCallback);\n        });\n      }\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Update set of attributes.\n * Performs validation before updating.\n * NOTE: `patchOrCreate` is an alias.\n *\n * @trigger `validation`, `save` and `update` hooks\n * @param {Object} data Data to update\n * @param {Object} [options] Options for updateAttributes\n * @param {Function} cb Callback function called with (err, instance)\n */\nDataAccessObject.prototype.updateAttributes =\nDataAccessObject.prototype.patchAttributes =\nfunction(data, options, cb) {\n  var self = this;\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  if (options === undefined && cb === undefined) {\n    if (typeof data === 'function') {\n      // updateAttributes(cb)\n      cb = data;\n      data = undefined;\n    }\n  } else if (cb === undefined) {\n    if (typeof options === 'function') {\n      // updateAttributes(data, cb)\n      cb = options;\n      options = {};\n    }\n  }\n\n  cb = cb || utils.createPromiseCallback();\n  options = options || {};\n\n  assert((typeof data === 'object') && (data !== null),\n    'The data argument must be an object');\n  assert(typeof options === 'object', 'The options argument must be an object');\n  assert(typeof cb === 'function', 'The cb argument must be a function');\n\n  var inst = this;\n  var Model = this.constructor;\n  var connector = inst.getConnector();\n  assert(typeof connector.updateAttributes === 'function',\n    'updateAttributes() must be implemented by the connector');\n\n  if (isPKMissing(Model, cb))\n    return cb.promise;\n\n  var allowExtendedOperators = Model._allowExtendedOperators(options);\n  var strict = this.__strict;\n  var model = Model.modelName;\n  var hookState = {};\n\n  // Convert the data to be plain object so that update won't be confused\n  if (data instanceof Model) {\n    data = data.toObject(false);\n  }\n  data = removeUndefined(data);\n\n  // Make sure id(s) cannot be changed\n  var idNames = Model.definition.idNames();\n  for (var i = 0, n = idNames.length; i < n; i++) {\n    var idName = idNames[i];\n    if (data[idName] !== undefined && !idEquals(data[idName], inst[idName])) {\n      var err = new Error(g.f('{{id}} cannot be updated from ' +\n        '%s to %s when {{forceId}} is set to true',\n        inst[idName], data[idName]));\n      err.statusCode = 400;\n      process.nextTick(function() {\n        cb(err);\n      });\n      return cb.promise;\n    }\n  }\n\n  var context = {\n    Model: Model,\n    where: byIdQuery(Model, getIdValue(Model, inst)).where,\n    data: data,\n    currentInstance: inst,\n    hookState: hookState,\n    options: options,\n  };\n\n  Model.notifyObserversOf('before save', context, function(err, ctx) {\n    if (err) return cb(err);\n    data = ctx.data;\n\n    if (strict && !allowExtendedOperators) {\n      applyStrictCheck(self.constructor, strict, data, inst, validateAndSave);\n    } else {\n      validateAndSave(null, data);\n    }\n\n    function validateAndSave(err, data) {\n      if (err) return cb(err);\n      data = removeUndefined(data);\n      var doValidate = true;\n      if (options.validate === undefined) {\n        if (Model.settings.automaticValidation !== undefined) {\n          doValidate = Model.settings.automaticValidation;\n        }\n      } else {\n        doValidate = options.validate;\n      }\n\n      // update instance's properties\n      try {\n        inst.setAttributes(data);\n      } catch (err) {\n        return cb(err);\n      }\n\n      if (doValidate) {\n        inst.isValid(function(valid) {\n          if (!valid) {\n            cb(new ValidationError(inst), inst);\n            return;\n          }\n\n          triggerSave();\n        }, data, options);\n      } else {\n        triggerSave();\n      }\n\n      function triggerSave() {\n        inst.trigger('save', function(saveDone) {\n          inst.trigger('update', function(done) {\n            copyData(data, inst);\n            var typedData = convertSubsetOfPropertiesByType(inst, data);\n            context.data = typedData;\n\n            function updateAttributesCallback(err) {\n              if (err) return cb(err);\n              var ctx = {\n                Model: Model,\n                data: context.data,\n                hookState: hookState,\n                options: options,\n                isNewInstance: false,\n              };\n              Model.notifyObserversOf('loaded', ctx, function(err) {\n                if (err) return cb(err);\n\n                inst.__persisted = true;\n\n                // By default, the instance passed to updateAttributes callback is NOT updated\n                // with the changes made through persist/loaded hooks. To preserve\n                // backwards compatibility, we introduced a new setting updateOnLoad,\n                // which if set, will apply these changes to the model instance too.\n                if (Model.settings.updateOnLoad) {\n                  inst.setAttributes(ctx.data);\n                }\n                done.call(inst, function() {\n                  saveDone.call(inst, function() {\n                    if (err) return cb(err, inst);\n\n                    var context = {\n                      Model: Model,\n                      instance: inst,\n                      isNewInstance: false,\n                      hookState: hookState,\n                      options: options,\n                    };\n                    Model.notifyObserversOf('after save', context, function(err) {\n                      cb(err, inst);\n                    });\n                  });\n                });\n              });\n            }\n\n            var ctx = {\n              Model: Model,\n              where: byIdQuery(Model, getIdValue(Model, inst)).where,\n              data: context.data,\n              currentInstance: inst,\n              isNewInstance: false,\n              hookState: hookState,\n              options: options,\n            };\n            Model.notifyObserversOf('persist', ctx, function(err) {\n              if (connector.updateAttributes.length === 5) {\n                connector.updateAttributes(model, getIdValue(inst.constructor, inst),\n                  inst.constructor._forDB(context.data), options, updateAttributesCallback);\n              } else {\n                connector.updateAttributes(model, getIdValue(inst.constructor, inst),\n                  inst.constructor._forDB(context.data), updateAttributesCallback);\n              }\n            });\n          }, data, cb);\n        }, data, cb);\n      }\n    }\n  });\n  return cb.promise;\n};\n\n/**\n * Reload object from persistence\n * Requires `id` member of `object` to be able to call `find`\n * @param {Function} cb Called with (err, instance) arguments\n * @private\n */\nDataAccessObject.prototype.reload = function reload(cb) {\n  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  return this.constructor.findById(getIdValue(this.constructor, this), cb);\n};\n\n/*\n * Define readonly property on object\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Mixed} value\n * @private\n */\nfunction defineReadonlyProp(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    writable: false,\n    enumerable: true,\n    configurable: true,\n    value: value,\n  });\n}\n\nvar defineScope = require('./scope.js').defineScope;\n\n/**\n * Define a scope for the model class. Scopes enable you to specify commonly-used\n * queries that you can reference as method calls on a model.\n *\n * @param {String} name The scope name\n * @param {Object} query The query object for DataAccessObject.find()\n * @param {ModelClass} [targetClass] The model class for the query, default to\n * the declaring model\n */\nDataAccessObject.scope = function(name, query, targetClass, methods, options) {\n  var cls = this;\n  if (options && options.isStatic === false) {\n    cls = cls.prototype;\n  }\n  return defineScope(cls, targetClass || cls, name, query, methods, options);\n};\n\n/*\n * Add 'include'\n */\njutil.mixin(DataAccessObject, Inclusion);\n\n/*\n * Add 'relation'\n */\njutil.mixin(DataAccessObject, Relation);\n\n/*\n * Add 'transaction'\n */\njutil.mixin(DataAccessObject, require('./transaction'));\n\nfunction PKMissingError(modelName) {\n  this.name = 'PKMissingError';\n  this.message = 'Primary key is missing for the ' + modelName + ' model';\n}\nPKMissingError.prototype = new Error();\n\nfunction isPKMissing(modelClass, cb) {\n  var hasPK = modelClass.definition.hasPK();\n  if (hasPK) return false;\n  process.nextTick(function() {\n    cb(new PKMissingError(modelClass.modelName));\n  });\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/relations.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\n/*!\n * Dependencies\n */\nvar relation = require('./relation-definition');\nvar RelationDefinition = relation.RelationDefinition;\n\nmodule.exports = RelationMixin;\n\n/**\n * RelationMixin class.  Use to define relationships between models.\n *\n * @class RelationMixin\n */\nfunction RelationMixin() {\n}\n\n/**\n * Define a \"one to many\" relationship by specifying the model name\n *\n * Examples:\n * ```\n * User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});\n * ```\n *\n * ```\n * Book.hasMany(Chapter);\n * ```\n * Or, equivalently:\n * ```\n * Book.hasMany('chapters', {model: Chapter});\n * ```\n *\n * Query and create related models:\n *\n * ```js\n * Book.create(function(err, book) {\n *\n *   // Create a chapter instance ready to be saved in the data source.\n *   var chapter = book.chapters.build({name: 'Chapter 1'});\n *\n *   // Save the new chapter\n *   chapter.save();\n *\n *  // you can also call the Chapter.create method with the `chapters` property which will build a chapter\n *  // instance and save the it in the data source.\n *  book.chapters.create({name: 'Chapter 2'}, function(err, savedChapter) {\n *  // this callback is optional\n *  });\n *\n *   // Query chapters for the book\n *   book.chapters(function(err, chapters) {  // all chapters with bookId = book.id\n *     console.log(chapters);\n *   });\n *\n *   book.chapters({where: {name: 'test'}, function(err, chapters) {\n *    // All chapters with bookId = book.id and name = 'test'\n *     console.log(chapters);\n *   });\n * });\n *```\n * @param {Object|String} modelTo Model object (or String name of model) to which you are creating the relationship.\n * @options {Object} parameters Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationMixin.hasMany = function hasMany(modelTo, params) {\n  return RelationDefinition.hasMany(this, modelTo, params);\n};\n\n/**\n * Declare \"belongsTo\" relation that sets up a one-to-one connection with another model, such that each\n * instance of the declaring model \"belongs to\" one instance of the other model.\n *\n * For example, if an application includes users and posts, and each post can be written by exactly one user.\n * The following code specifies that `Post` has a reference called `author` to the `User` model via the `userId` property of `Post`\n * as the foreign key.\n * ```\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n * ```\n * You can then access the author in one of the following styles.\n * Get the User object for the post author asynchronously:\n * ```\n * post.author(callback);\n * ```\n * Get the User object for the post author synchronously:\n * ```\n * post.author();\n * ```\n * Set the author to be the given user:\n * ```\n * post.author(user)\n * ```\n * Examples:\n *\n * Suppose the model Post has a *belongsTo* relationship with User (the author of the post). You could declare it this way:\n * ```js\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n * ```\n *\n * When a post is loaded, you can load the related author with:\n * ```js\n * post.author(function(err, user) {\n *     // the user variable is your user object\n * });\n * ```\n *\n * The related object is cached, so if later you try to get again the author, no additional request will be made.\n * But there is an optional boolean parameter in first position that set whether or not you want to reload the cache:\n * ```js\n * post.author(true, function(err, user) {\n *     // The user is reloaded, even if it was already cached.\n * });\n * ```\n * This optional parameter default value is false, so the related object will be loaded from cache if available.\n *\n * @param {Class|String} modelTo Model object (or String name of model) to which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Name of foreign key property.\n *\n */\nRelationMixin.belongsTo = function(modelTo, params) {\n  return RelationDefinition.belongsTo(this, modelTo, params);\n};\n\n/**\n * A hasAndBelongsToMany relation creates a direct many-to-many connection with another model, with no intervening model.\n * For example, if your application includes users and groups, with each group having many users and each user appearing\n * in many groups, you could declare the models this way:\n * ```\n *  User.hasAndBelongsToMany('groups', {model: Group, foreignKey: 'groupId'});\n * ```\n *  Then, to get the groups to which the user belongs:\n * ```\n *  user.groups(callback);\n * ```\n *  Create a new group and connect it with the user:\n * ```\n *  user.groups.create(data, callback);\n * ```\n *  Connect an existing group with the user:\n * ```\n *  user.groups.add(group, callback);\n * ```\n *  Remove the user from the group:\n * ```\n *  user.groups.remove(group, callback);\n * ```\n *\n * @param {String|Object} modelTo Model object (or String name of model) to which you are creating the relationship.\n * the relation\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationMixin.hasAndBelongsToMany = function hasAndBelongsToMany(modelTo, params) {\n  return RelationDefinition.hasAndBelongsToMany(this, modelTo, params);\n};\n\nRelationMixin.hasOne = function hasOne(modelTo, params) {\n  return RelationDefinition.hasOne(this, modelTo, params);\n};\n\nRelationMixin.referencesMany = function referencesMany(modelTo, params) {\n  return RelationDefinition.referencesMany(this, modelTo, params);\n};\n\nRelationMixin.embedsOne = function embedsOne(modelTo, params) {\n  return RelationDefinition.embedsOne(this, modelTo, params);\n};\n\nRelationMixin.embedsMany = function embedsMany(modelTo, params) {\n  return RelationDefinition.embedsMany(this, modelTo, params);\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/include.js":"// Copyright IBM Corp. 2013,2015. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar async = require('async');\nvar g = require('strong-globalize')();\nvar utils = require('./utils');\nvar List = require('./list');\nvar includeUtils = require('./include_utils');\nvar isPlainObject = utils.isPlainObject;\nvar defineCachedRelations = utils.defineCachedRelations;\nvar uniq = utils.uniq;\nvar idName = utils.idName;\n\n/*!\n * Normalize the include to be an array\n * @param include\n * @returns {*}\n */\nfunction normalizeInclude(include) {\n  var newInclude;\n  if (typeof include === 'string') {\n    return [include];\n  } else if (isPlainObject(include)) {\n    // Build an array of key/value pairs\n    newInclude = [];\n    var rel = include.rel || include.relation;\n    var obj = {};\n    if (typeof rel === 'string') {\n      obj[rel] = new IncludeScope(include.scope);\n      newInclude.push(obj);\n    } else {\n      for (var key in include) {\n        obj[key] = include[key];\n        newInclude.push(obj);\n      }\n    }\n    return newInclude;\n  } else if (Array.isArray(include)) {\n    newInclude = [];\n    for (var i = 0, n = include.length; i < n; i++) {\n      var subIncludes = normalizeInclude(include[i]);\n      newInclude = newInclude.concat(subIncludes);\n    }\n    return newInclude;\n  } else {\n    return include;\n  }\n}\n\nfunction IncludeScope(scope) {\n  this._scope = utils.deepMerge({}, scope || {});\n  if (this._scope.include) {\n    this._include = normalizeInclude(this._scope.include);\n    delete this._scope.include;\n  } else {\n    this._include = null;\n  }\n}\n\nIncludeScope.prototype.conditions = function() {\n  return utils.deepMerge({}, this._scope);\n};\n\nIncludeScope.prototype.include = function() {\n  return this._include;\n};\n\n/*!\n * Look up a model by name from the list of given models\n * @param {Object} models Models keyed by name\n * @param {String} modelName The model name\n * @returns {*} The matching model class\n */\nfunction lookupModel(models, modelName) {\n  if (models[modelName]) {\n    return models[modelName];\n  }\n  var lookupClassName = modelName.toLowerCase();\n  for (var name in models) {\n    if (name.toLowerCase() === lookupClassName) {\n      return models[name];\n    }\n  }\n}\n\n/**\n * Utility Function to allow interleave before and after high computation tasks\n * @param tasks\n * @param callback\n */\nfunction execTasksWithInterLeave(tasks, callback) {\n  // let's give others some time to process.\n  // Context Switch BEFORE Heavy Computation\n  process.nextTick(function() {\n    // Heavy Computation\n    try {\n      async.parallel(tasks, function(err, info) {\n        // Context Switch AFTER Heavy Computation\n        process.nextTick(function() {\n          callback(err, info);\n        });\n      });\n    } catch (err) {\n      callback(err);\n    }\n  });\n}\n\n/*!\n * Include mixin for ./model.js\n */\nmodule.exports = Inclusion;\n\n/**\n * Inclusion - Model mixin.\n *\n * @class\n */\n\nfunction Inclusion() {\n}\n\n/**\n * Normalize includes - used in DataAccessObject\n *\n */\n\nInclusion.normalizeInclude = normalizeInclude;\n\n/**\n * Enables you to load relations of several objects and optimize numbers of requests.\n *\n * Examples:\n *\n * Load all users' posts with only one additional request:\n * `User.include(users, 'posts', function() {});`\n * Or\n * `User.include(users, ['posts'], function() {});`\n *\n * Load all users posts and passports with two additional requests:\n * `User.include(users, ['posts', 'passports'], function() {});`\n *\n * Load all passports owner (users), and all posts of each owner loaded:\n *```Passport.include(passports, {owner: 'posts'}, function() {});\n *``` Passport.include(passports, {owner: ['posts', 'passports']});\n *``` Passport.include(passports, {owner: [{posts: 'images'}, 'passports']});\n *\n * @param {Array} objects Array of instances\n * @param {String|Object|Array} include Which relations to load.\n * @param {Object} [options] Options for CRUD\n * @param {Function} cb Callback called when relations are loaded\n *\n */\nInclusion.include = function(objects, include, options, cb) {\n  if (typeof options === 'function' && cb === undefined) {\n    cb = options;\n    options = {};\n  }\n  var self = this;\n\n  if (!include || (Array.isArray(include) && include.length === 0) ||\n      (Array.isArray(objects) && objects.length === 0) ||\n      (isPlainObject(include) && Object.keys(include).length === 0)) {\n    // The objects are empty\n    return process.nextTick(function() {\n      cb && cb(null, objects);\n    });\n  }\n\n  include = normalizeInclude(include);\n\n  // Find the limit of items for `inq`\n  var inqLimit = 256;\n  if (self.dataSource && self.dataSource.settings &&\n    self.dataSource.settings.inqLimit) {\n    inqLimit = self.dataSource.settings.inqLimit;\n  }\n\n  async.each(include, function(item, callback) {\n    processIncludeItem(objects, item, options, callback);\n  }, function(err) {\n    cb && cb(err, objects);\n  });\n\n  /**\n   * Find related items with an array of foreign keys by page\n   * @param model The model class\n   * @param filter The query filter\n   * @param fkName The name of the foreign key property\n   * @param pageSize The size of page\n   * @param options Options\n   * @param cb\n   */\n  function findWithForeignKeysByPage(model, filter, fkName, pageSize, options, cb) {\n    var foreignKeys = [];\n    if (filter.where[fkName]) {\n      foreignKeys = filter.where[fkName].inq;\n    } else if (filter.where.and) {\n      // The inq can be embedded inside 'and: []'. No or: [] is needed as\n      // include only uses and. We only deal with the generated inq for include.\n      for (var j in filter.where.and) {\n        if (filter.where.and[j][fkName] &&\n          Array.isArray(filter.where.and[j][fkName].inq)) {\n          foreignKeys = filter.where.and[j][fkName].inq;\n          break;\n        }\n      }\n    }\n    if (!foreignKeys.length) {\n      return cb(null, []);\n    }\n    if (filter.limit || filter.skip || filter.offset) {\n      // Force the find to be performed per FK to honor the pagination\n      pageSize = 1;\n    }\n    var size = foreignKeys.length;\n    if (size > inqLimit && pageSize <= 0) {\n      pageSize = inqLimit;\n    }\n    if (pageSize <= 0) {\n      return model.find(filter, options, cb);\n    }\n\n    var listOfFKs = [];\n\n    for (var i = 0; i < size; i += pageSize) {\n      var end = i + pageSize;\n      if (end > size) {\n        end = size;\n      }\n      listOfFKs.push(foreignKeys.slice(i, end));\n    }\n\n    var items = [];\n    // Optimization: no need to resolve keys that are an empty array\n    listOfFKs = listOfFKs.filter(function(keys) {\n      return keys.length > 0;\n    });\n    async.each(listOfFKs, function(foreignKeys, done) {\n      var newFilter = {};\n      for (var f in filter) {\n        newFilter[f] = filter[f];\n      }\n      if (filter.where) {\n        newFilter.where = {};\n        for (var w in filter.where) {\n          newFilter.where[w] = filter.where[w];\n        }\n      }\n      newFilter.where[fkName] = {\n        inq: foreignKeys,\n      };\n      model.find(newFilter, options, function(err, results) {\n        if (err) return done(err);\n        items = items.concat(results);\n        done();\n      });\n    }, function(err) {\n      if (err) return cb(err);\n      cb(null, items);\n    });\n  }\n\n  function processIncludeItem(objs, include, options, cb) {\n    var relations = self.relations;\n\n    var relationName;\n    var subInclude = null, scope = null;\n\n    if (isPlainObject(include)) {\n      relationName = Object.keys(include)[0];\n      if (include[relationName] instanceof IncludeScope) {\n        scope = include[relationName];\n        subInclude = scope.include();\n      } else {\n        subInclude = include[relationName];\n        // when include = {user:true}, it does not have subInclude\n        if (subInclude === true) {\n          subInclude = null;\n        }\n      }\n    } else {\n      relationName = include;\n      subInclude = null;\n    }\n\n    var relation = relations[relationName];\n    if (!relation) {\n      cb(new Error(g.f('Relation \"%s\" is not defined for %s model', relationName, self.modelName)));\n      return;\n    }\n    var polymorphic = relation.polymorphic;\n    // if (polymorphic && !polymorphic.discriminator) {\n    //  cb(new Error('Relation \"' + relationName + '\" is polymorphic but ' +\n    //    'discriminator is not present'));\n    //  return;\n    // }\n    if (!relation.modelTo) {\n      if (!relation.polymorphic) {\n        cb(new Error(g.f('{{Relation.modelTo}} is not defined for relation %s and is no {{polymorphic}}',\n          relationName)));\n        return;\n      }\n    }\n\n    // Just skip if inclusion is disabled\n    if (relation.options.disableInclude) {\n      return cb();\n    }\n    // prepare filter and fields for making DB Call\n    var filter = (scope && scope.conditions()) || {};\n    if ((relation.multiple || relation.type === 'belongsTo') && scope) {\n      var includeScope = {};\n      // make sure not to miss any fields for sub includes\n      if (filter.fields && Array.isArray(subInclude) &&\n        relation.modelTo.relations) {\n        includeScope.fields = [];\n        subInclude.forEach(function(name) {\n          var rel = relation.modelTo.relations[name];\n          if (rel && rel.type === 'belongsTo') {\n            includeScope.fields.push(rel.keyFrom);\n          }\n        });\n      }\n      utils.mergeQuery(filter, includeScope, {fields: false});\n    }\n    // Let's add a placeholder where query\n    filter.where = filter.where || {};\n    // if fields are specified, make sure target foreign key is present\n    var fields = filter.fields;\n    if (typeof fields === 'string') {\n      // transform string into array containing this string\n      filter.fields = fields = [fields];\n    }\n    if (Array.isArray(fields) && fields.indexOf(relation.keyTo) === -1) {\n      fields.push(relation.keyTo);\n    } else if (isPlainObject(fields) && !fields[relation.keyTo]) {\n      fields[relation.keyTo] = true;\n    }\n\n    //\n    // call relation specific include functions\n    //\n    if (relation.multiple) {\n      if (relation.modelThrough) {\n        // hasManyThrough needs separate handling\n        return includeHasManyThrough(cb);\n      }\n      // This will also include embedsMany with belongsTo.\n      // Might need to optimize db calls for this.\n      if (relation.type === 'embedsMany') {\n        // embedded docs are part of the objects, no need to make db call.\n        // proceed as implemented earlier.\n        return includeEmbeds(cb);\n      }\n      if (relation.type === 'referencesMany') {\n        return includeReferencesMany(cb);\n      }\n\n      // This handles exactly hasMany. Fast and straightforward. Without parallel, each and other boilerplate.\n      if (relation.type === 'hasMany' && relation.multiple && !subInclude) {\n        return includeHasManySimple(cb);\n      }\n      // assuming all other relations with multiple=true as hasMany\n      return includeHasMany(cb);\n    } else {\n      if (polymorphic) {\n        if (relation.type === 'hasOne') {\n          return includePolymorphicHasOne(cb);\n        }\n        return includePolymorphicBelongsTo(cb);\n      }\n      if (relation.type === 'embedsOne') {\n        return includeEmbeds(cb);\n      }\n      // hasOne or belongsTo\n      return includeOneToOne(cb);\n    }\n\n    /**\n     * Handle inclusion of HasManyThrough/HasAndBelongsToMany/Polymorphic\n     * HasManyThrough relations\n     * @param callback\n     */\n    function includeHasManyThrough(callback) {\n      var sourceIds = [];\n      // Map for Indexing objects by their id for faster retrieval\n      var objIdMap = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        // one-to-many: foreign key reference is modelTo -> modelFrom.\n        // use modelFrom.keyFrom in where filter later\n        var sourceId = obj[relation.keyFrom];\n        if (sourceId) {\n          sourceIds.push(sourceId);\n          objIdMap[sourceId.toString()] = obj;\n        }\n        // sourceId can be null. but cache empty data as result\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = [];\n      }\n      // default filters are not applicable on through model. should be applied\n      // on modelTo later in 2nd DB call.\n      var throughFilter = {\n        where: {},\n      };\n      throughFilter.where[relation.keyTo] = {\n        inq: uniq(sourceIds),\n      };\n      if (polymorphic) {\n        // handle polymorphic hasMany (reverse) in which case we need to filter\n        // by discriminator to filter other types\n        throughFilter.where[polymorphic.discriminator] =\n          relation.modelFrom.definition.name;\n      }\n      /**\n       * 1st DB Call of 2 step process. Get through model objects first\n       */\n      findWithForeignKeysByPage(relation.modelThrough, throughFilter,\n        relation.keyTo, 0, options, throughFetchHandler);\n\n      /**\n       * Handle the results of Through model objects and fetch the modelTo items\n       * @param err\n       * @param {Array<Model>} throughObjs\n       * @returns {*}\n       */\n      function throughFetchHandler(err, throughObjs) {\n        if (err) {\n          return callback(err);\n        }\n        // start preparing for 2nd DB call.\n        var targetIds = [];\n        var targetObjsMap = {};\n        for (var i = 0; i < throughObjs.length; i++) {\n          var throughObj = throughObjs[i];\n          var targetId = throughObj[relation.keyThrough];\n          if (targetId) {\n            // save targetIds for 2nd DB Call\n            targetIds.push(targetId);\n            var sourceObj = objIdMap[throughObj[relation.keyTo]];\n            var targetIdStr = targetId.toString();\n            // Since targetId can be duplicates, multiple source objs are put\n            // into buckets.\n            var objList = targetObjsMap[targetIdStr] =\n              targetObjsMap[targetIdStr] || [];\n            objList.push(sourceObj);\n          }\n        }\n        // Polymorphic relation does not have idKey of modelTo. Find it manually\n        var modelToIdName = idName(relation.modelTo);\n        filter.where[modelToIdName] = {\n          inq: uniq(targetIds),\n        };\n\n        // make sure that the modelToIdName is included if fields are specified\n        if (Array.isArray(fields) && fields.indexOf(modelToIdName) === -1) {\n          fields.push(modelToIdName);\n        } else if (isPlainObject(fields) && !fields[modelToIdName]) {\n          fields[modelToIdName] = true;\n        }\n\n        /**\n         * 2nd DB Call of 2 step process. Get modelTo (target) objects\n         */\n        findWithForeignKeysByPage(relation.modelTo, filter,\n          modelToIdName, 0, options, targetsFetchHandler);\n\n        // relation.modelTo.find(filter, options, targetsFetchHandler);\n        function targetsFetchHandler(err, targets) {\n          if (err) {\n            return callback(err);\n          }\n          var tasks = [];\n          // simultaneously process subIncludes. Call it first as it is an async\n          // process.\n          if (subInclude && targets) {\n            tasks.push(function subIncludesTask(next) {\n              relation.modelTo.include(targets, subInclude, options, next);\n            });\n          }\n          // process & link each target with object\n          tasks.push(targetLinkingTask);\n          function targetLinkingTask(next) {\n            async.each(targets, linkManyToMany, next);\n            function linkManyToMany(target, next) {\n              var targetId = target[modelToIdName];\n              if (!targetId) {\n                var err = new Error(g.f('LinkManyToMany received target that doesn\\'t contain required \"%s\"',\n                  modelToIdName));\n                return next(err);\n              }\n              var objList = targetObjsMap[targetId.toString()];\n              async.each(objList, function(obj, next) {\n                if (!obj) return next();\n                obj.__cachedRelations[relationName].push(target);\n                processTargetObj(obj, next);\n              }, next);\n            }\n          }\n\n          execTasksWithInterLeave(tasks, callback);\n        }\n      }\n    }\n\n    /**\n     * Handle inclusion of ReferencesMany relation\n     * @param callback\n     */\n    function includeReferencesMany(callback) {\n      var modelToIdName = idName(relation.modelTo);\n      var allTargetIds = [];\n      // Map for Indexing objects by their id for faster retrieval\n      var targetObjsMap = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        // one-to-many: foreign key reference is modelTo -> modelFrom.\n        // use modelFrom.keyFrom in where filter later\n        var targetIds = obj[relation.keyFrom];\n        if (targetIds) {\n          if (typeof targetIds === 'string') {\n            // For relational DBs, the array is stored as stringified json\n            // Please note obj is a plain object at this point\n            targetIds = JSON.parse(targetIds);\n          }\n          // referencesMany has multiple targetIds per obj. We need to concat\n          // them into allTargetIds before DB Call\n          allTargetIds = allTargetIds.concat(targetIds);\n          for (var j = 0; j < targetIds.length; j++) {\n            var targetId = targetIds[j];\n            var targetIdStr = targetId.toString();\n            var objList = targetObjsMap[targetIdStr] =\n              targetObjsMap[targetIdStr] || [];\n            objList.push(obj);\n          }\n        }\n        // sourceId can be null. but cache empty data as result\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = [];\n      }\n      filter.where[relation.keyTo] = {\n        inq: uniq(allTargetIds),\n      };\n      relation.applyScope(null, filter);\n      /**\n       * Make the DB Call, fetch all target objects\n       */\n      findWithForeignKeysByPage(relation.modelTo, filter,\n        relation.keyTo, 0, options, targetFetchHandler);\n      /**\n       * Handle the fetched target objects\n       * @param err\n       * @param {Array<Model>}targets\n       * @returns {*}\n       */\n      function targetFetchHandler(err, targets) {\n        if (err) {\n          return callback(err);\n        }\n        var tasks = [];\n        // simultaneously process subIncludes\n        if (subInclude && targets) {\n          tasks.push(function subIncludesTask(next) {\n            relation.modelTo.include(targets, subInclude, options, next);\n          });\n        }\n        targets = utils.sortObjectsByIds(modelToIdName, allTargetIds, targets);\n        // process each target object\n        tasks.push(targetLinkingTask);\n        function targetLinkingTask(next) {\n          async.each(targets, linkManyToMany, next);\n          function linkManyToMany(target, next) {\n            var objList = targetObjsMap[target[relation.keyTo].toString()];\n            async.each(objList, function(obj, next) {\n              if (!obj) return next();\n              obj.__cachedRelations[relationName].push(target);\n              processTargetObj(obj, next);\n            }, next);\n          }\n        }\n\n        execTasksWithInterLeave(tasks, callback);\n      }\n    }\n\n    /**\n     * Handle inclusion of HasMany relation\n     * @param callback\n     */\n    function includeHasManySimple(callback) {\n      // Map for Indexing objects by their id for faster retrieval\n      var objIdMap2 = includeUtils.buildOneToOneIdentityMapWithOrigKeys(objs, relation.keyFrom);\n\n      filter.where[relation.keyTo] = {\n        inq: uniq(objIdMap2.getKeys()),\n      };\n\n      relation.applyScope(null, filter);\n\n      findWithForeignKeysByPage(relation.modelTo, filter,\n        relation.keyTo, 0, options, targetFetchHandler);\n\n      function targetFetchHandler(err, targets) {\n        if (err) {\n          return callback(err);\n        }\n        var targetsIdMap = includeUtils.buildOneToManyIdentityMapWithOrigKeys(targets, relation.keyTo);\n        includeUtils.join(objIdMap2, targetsIdMap, function(obj1, valueToMergeIn) {\n          defineCachedRelations(obj1);\n          obj1.__cachedRelations[relationName] = valueToMergeIn;\n          processTargetObj(obj1, function() {});\n        });\n        callback(err, objs);\n      }\n    }\n\n    /**\n     * Handle inclusion of HasMany relation\n     * @param callback\n     */\n    function includeHasMany(callback) {\n      var sourceIds = [];\n      // Map for Indexing objects by their id for faster retrieval\n      var objIdMap = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        // one-to-many: foreign key reference is modelTo -> modelFrom.\n        // use modelFrom.keyFrom in where filter later\n        var sourceId = obj[relation.keyFrom];\n        if (sourceId) {\n          sourceIds.push(sourceId);\n          objIdMap[sourceId.toString()] = obj;\n        }\n        // sourceId can be null. but cache empty data as result\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = [];\n      }\n      filter.where[relation.keyTo] = {\n        inq: uniq(sourceIds),\n      };\n      relation.applyScope(null, filter);\n      options.partitionBy = relation.keyTo;\n\n      findWithForeignKeysByPage(relation.modelTo, filter,\n        relation.keyTo, 0, options, targetFetchHandler);\n\n      /**\n       * Process fetched related objects\n       * @param err\n       * @param {Array<Model>} targets\n       * @returns {*}\n       */\n      function targetFetchHandler(err, targets) {\n        if (err) {\n          return callback(err);\n        }\n        var tasks = [];\n        // simultaneously process subIncludes\n        if (subInclude && targets) {\n          tasks.push(function subIncludesTask(next) {\n            relation.modelTo.include(targets, subInclude, options, next);\n          });\n        }\n        // process each target object\n        tasks.push(targetLinkingTask);\n        function targetLinkingTask(next) {\n          if (targets.length === 0) {\n            return async.each(objs, function(obj, next) {\n              processTargetObj(obj, next);\n            }, next);\n          }\n\n          async.each(targets, linkManyToOne, next);\n          function linkManyToOne(target, next) {\n            // fix for bug in hasMany with referencesMany\n            var targetIds = [].concat(target[relation.keyTo]);\n            async.each(targetIds, function(targetId, next) {\n              var obj = objIdMap[targetId.toString()];\n              if (!obj) return next();\n              obj.__cachedRelations[relationName].push(target);\n              processTargetObj(obj, next);\n            }, function(err, processedTargets) {\n              if (err) {\n                return next(err);\n              }\n\n              var objsWithEmptyRelation = objs.filter(function(obj) {\n                return obj.__cachedRelations[relationName].length === 0;\n              });\n              async.each(objsWithEmptyRelation, function(obj, next) {\n                processTargetObj(obj, next);\n              }, function(err) {\n                next(err, processedTargets);\n              });\n            });\n          }\n        }\n\n        execTasksWithInterLeave(tasks, callback);\n      }\n    }\n\n    /**\n     * Handle Inclusion of Polymorphic BelongsTo relation\n     * @param callback\n     */\n    function includePolymorphicBelongsTo(callback) {\n      var targetIdsByType = {};\n      // Map for Indexing objects by their type and targetId for faster retrieval\n      var targetObjMapByType = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        var discriminator = polymorphic.discriminator;\n        var modelType = obj[discriminator];\n        if (modelType) {\n          targetIdsByType[modelType] = targetIdsByType[modelType] || [];\n          targetObjMapByType[modelType] = targetObjMapByType[modelType] || {};\n          var targetIds = targetIdsByType[modelType];\n          var targetObjsMap = targetObjMapByType[modelType];\n          var targetId = obj[relation.keyFrom];\n          if (targetId) {\n            targetIds.push(targetId);\n            var targetIdStr = targetId.toString();\n            targetObjsMap[targetIdStr] = targetObjsMap[targetIdStr] || [];\n            // Is belongsTo. Multiple objects can have the same\n            // targetId and therefore map value is an array\n            targetObjsMap[targetIdStr].push(obj);\n          }\n        }\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = null;\n      }\n      async.each(Object.keys(targetIdsByType), processPolymorphicType,\n        callback);\n      /**\n       * Process Polymorphic objects of each type (modelType)\n       * @param {String} modelType\n       * @param callback\n       */\n      function processPolymorphicType(modelType, callback) {\n        var typeFilter = {where: {}};\n        utils.mergeQuery(typeFilter, filter);\n        var targetIds = targetIdsByType[modelType];\n        typeFilter.where[relation.keyTo] = {\n          inq: uniq(targetIds),\n        };\n        var Model = lookupModel(relation.modelFrom.dataSource.modelBuilder.\n          models, modelType);\n        if (!Model) {\n          callback(new Error(g.f('Discriminator type %s specified but no model exists with such name',\n            modelType)));\n          return;\n        }\n        relation.applyScope(null, typeFilter);\n\n        findWithForeignKeysByPage(Model, typeFilter,\n          relation.keyTo, 0, options, targetFetchHandler);\n\n        /**\n         * Process fetched related objects\n         * @param err\n         * @param {Array<Model>} targets\n         * @returns {*}\n         */\n        function targetFetchHandler(err, targets) {\n          if (err) {\n            return callback(err);\n          }\n          var tasks = [];\n\n          // simultaneously process subIncludes\n          if (subInclude && targets) {\n            tasks.push(function subIncludesTask(next) {\n              Model.include(targets, subInclude, options, next);\n            });\n          }\n          // process each target object\n          tasks.push(targetLinkingTask);\n          function targetLinkingTask(next) {\n            var targetObjsMap = targetObjMapByType[modelType];\n            async.each(targets, linkOneToMany, next);\n            function linkOneToMany(target, next) {\n              var objList = targetObjsMap[target[relation.keyTo].toString()];\n              async.each(objList, function(obj, next) {\n                if (!obj) return next();\n                obj.__cachedRelations[relationName] = target;\n                processTargetObj(obj, next);\n              }, next);\n            }\n          }\n\n          execTasksWithInterLeave(tasks, callback);\n        }\n      }\n    }\n\n    /**\n     * Handle Inclusion of Polymorphic HasOne relation\n     * @param callback\n     */\n    function includePolymorphicHasOne(callback) {\n      var sourceIds = [];\n      // Map for Indexing objects by their id for faster retrieval\n      var objIdMap = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        // one-to-one: foreign key reference is modelTo -> modelFrom.\n        // use modelFrom.keyFrom in where filter later\n        var sourceId = obj[relation.keyFrom];\n        if (sourceId) {\n          sourceIds.push(sourceId);\n          objIdMap[sourceId.toString()] = obj;\n        }\n        // sourceId can be null. but cache empty data as result\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = null;\n      }\n      filter.where[relation.keyTo] = {\n        inq: uniq(sourceIds),\n      };\n      relation.applyScope(null, filter);\n\n      findWithForeignKeysByPage(relation.modelTo, filter,\n        relation.keyTo, 0, options, targetFetchHandler);\n\n      /**\n       * Process fetched related objects\n       * @param err\n       * @param {Array<Model>} targets\n       * @returns {*}\n       */\n      function targetFetchHandler(err, targets) {\n        if (err) {\n          return callback(err);\n        }\n        var tasks = [];\n        // simultaneously process subIncludes\n        if (subInclude && targets) {\n          tasks.push(function subIncludesTask(next) {\n            relation.modelTo.include(targets, subInclude, options, next);\n          });\n        }\n        // process each target object\n        tasks.push(targetLinkingTask);\n        function targetLinkingTask(next) {\n          async.each(targets, linkOneToOne, next);\n          function linkOneToOne(target, next) {\n            var sourceId = target[relation.keyTo];\n            if (!sourceId) return next();\n            var obj = objIdMap[sourceId.toString()];\n            if (!obj) return next();\n            obj.__cachedRelations[relationName] = target;\n            processTargetObj(obj, next);\n          }\n        }\n\n        execTasksWithInterLeave(tasks, callback);\n      }\n    }\n\n    /**\n     * Handle Inclusion of BelongsTo/HasOne relation\n     * @param callback\n     */\n    function includeOneToOne(callback) {\n      var targetIds = [];\n      var objTargetIdMap = {};\n      for (var i = 0; i < objs.length; i++) {\n        var obj = objs[i];\n        if (relation.type === 'belongsTo') {\n          if (obj[relation.keyFrom] === null ||\n            obj[relation.keyFrom] === undefined) {\n            defineCachedRelations(obj);\n            obj.__cachedRelations[relationName] = null;\n            continue;\n          }\n        }\n        var targetId = obj[relation.keyFrom];\n        if (targetId) {\n          targetIds.push(targetId);\n          var targetIdStr = targetId.toString();\n          objTargetIdMap[targetIdStr] = objTargetIdMap[targetIdStr] || [];\n          objTargetIdMap[targetIdStr].push(obj);\n        }\n        defineCachedRelations(obj);\n        obj.__cachedRelations[relationName] = null;\n      }\n      filter.where[relation.keyTo] = {\n        inq: uniq(targetIds),\n      };\n      relation.applyScope(null, filter);\n\n      findWithForeignKeysByPage(relation.modelTo, filter,\n        relation.keyTo, 0, options, targetFetchHandler);\n\n      /**\n       * Process fetched related objects\n       * @param err\n       * @param {Array<Model>} targets\n       * @returns {*}\n       */\n      function targetFetchHandler(err, targets) {\n        if (err) {\n          return callback(err);\n        }\n        var tasks = [];\n        // simultaneously process subIncludes\n        if (subInclude && targets) {\n          tasks.push(function subIncludesTask(next) {\n            relation.modelTo.include(targets, subInclude, options, next);\n          });\n        }\n        // process each target object\n        tasks.push(targetLinkingTask);\n        function targetLinkingTask(next) {\n          async.each(targets, linkOneToMany, next);\n          function linkOneToMany(target, next) {\n            var targetId = target[relation.keyTo];\n            var objList = objTargetIdMap[targetId.toString()];\n            async.each(objList, function(obj, next) {\n              if (!obj) return next();\n              obj.__cachedRelations[relationName] = target;\n              processTargetObj(obj, next);\n            }, next);\n          }\n        }\n\n        execTasksWithInterLeave(tasks, callback);\n      }\n    }\n\n    /**\n     * Handle Inclusion of EmbedsMany/EmbedsManyWithBelongsTo/EmbedsOne\n     * Relations. Since Embedded docs are part of parents, no need to make\n     * db calls. Let the related function be called for each object to fetch\n     * the results from cache.\n     *\n     * TODO: Optimize EmbedsManyWithBelongsTo relation DB Calls\n     * @param callback\n     */\n    function includeEmbeds(callback) {\n      async.each(objs, function(obj, next) {\n        processTargetObj(obj, next);\n      }, callback);\n    }\n\n    /**\n     * Process Each Model Object and make sure specified relations are included\n     * @param {Model} obj - Single Mode object for which inclusion is needed\n     * @param callback\n     * @returns {*}\n     */\n    function processTargetObj(obj, callback) {\n      var isInst = obj instanceof self;\n\n      // Calling the relation method on the instance\n      if (relation.type === 'belongsTo') {\n        // If the belongsTo relation doesn't have an owner\n        if (obj[relation.keyFrom] === null || obj[relation.keyFrom] === undefined) {\n          defineCachedRelations(obj);\n          // Set to null if the owner doesn't exist\n          obj.__cachedRelations[relationName] = null;\n          if (isInst) {\n            obj.__data[relationName] = null;\n          } else {\n            obj[relationName] = null;\n          }\n          return callback();\n        }\n      }\n      /**\n       * Sets the related objects as a property of Parent Object\n       * @param {Array<Model>|Model|null} result - Related Object/Objects\n       * @param cb\n       */\n      function setIncludeData(result, cb) {\n        if (isInst) {\n          if (Array.isArray(result) && !(result instanceof List)) {\n            result = new List(result, relation.modelTo);\n          }\n          obj.__data[relationName] = result;\n          // obj.setStrict(false); issue #1252\n        } else {\n          obj[relationName] = result;\n        }\n        cb(null, result);\n      }\n\n      // obj.__cachedRelations[relationName] can be null if no data was returned\n      if (obj.__cachedRelations &&\n        obj.__cachedRelations[relationName] !== undefined) {\n        return setIncludeData(obj.__cachedRelations[relationName],\n          callback);\n      }\n\n      var inst = (obj instanceof self) ? obj : new self(obj);\n\n      // If related objects are not cached by include Handlers, directly call\n      // related accessor function even though it is not very efficient\n      var related; // relation accessor function\n\n      if ((relation.multiple || relation.type === 'belongsTo') && scope) {\n        var includeScope = {};\n        var filter = scope.conditions();\n\n        // make sure not to miss any fields for sub includes\n        if (filter.fields && Array.isArray(subInclude) && relation.modelTo.relations) {\n          includeScope.fields = [];\n          subInclude.forEach(function(name) {\n            var rel = relation.modelTo.relations[name];\n            if (rel && rel.type === 'belongsTo') {\n              includeScope.fields.push(rel.keyFrom);\n            }\n          });\n        }\n\n        utils.mergeQuery(filter, includeScope, {fields: false});\n\n        related = inst[relationName].bind(inst, filter);\n      } else {\n        related = inst[relationName].bind(inst, undefined);\n      }\n\n      related(options, function(err, result) {\n        if (err) {\n          return callback(err);\n        } else {\n          defineCachedRelations(obj);\n          obj.__cachedRelations[relationName] = result;\n\n          return setIncludeData(result, callback);\n        }\n      });\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/include_utils.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nmodule.exports.buildOneToOneIdentityMapWithOrigKeys = buildOneToOneIdentityMapWithOrigKeys;\nmodule.exports.buildOneToManyIdentityMapWithOrigKeys = buildOneToManyIdentityMapWithOrigKeys;\nmodule.exports.join = join;\nmodule.exports.KVMap = KVMap;\n\n/**\n * Effectively builds associative map on id -> object relation and stores original keys.\n * Map returned in form of object with ids in keys and object as values.\n * @param objs array of objects to build from\n * @param idName name of property to be used as id. Such property considered to be unique across array.\n * In case of collisions last wins. For non-unique ids use buildOneToManyIdentityMap()\n * @returns {} object where keys are ids and values are objects itself\n */\nfunction buildOneToOneIdentityMapWithOrigKeys(objs, idName) {\n  var kvMap = new KVMap();\n  for (var i = 0; i < objs.length; i++) {\n    var obj = objs[i];\n    var id = obj[idName];\n    kvMap.set(id, obj);\n  }\n  return kvMap;\n}\n\nfunction buildOneToManyIdentityMapWithOrigKeys(objs, idName) {\n  var kvMap = new KVMap();\n  for (var i = 0; i < objs.length; i++) {\n    var obj = objs[i];\n    var id = obj[idName];\n    var value = kvMap.get(id) || [];\n    value.push(obj);\n    kvMap.set(id, value);\n  }\n  return kvMap;\n}\n\n/**\n * Yeah, it joins. You need three things id -> obj1 map, id -> [obj2] map and merge function.\n * This functions will take each obj1, locate all data to join in map2 and call merge function.\n * @param oneToOneIdMap\n * @param oneToManyIdMap\n * @param mergeF  function(obj, objectsToMergeIn)\n */\nfunction join(oneToOneIdMap, oneToManyIdMap, mergeF) {\n  var ids = oneToOneIdMap.getKeys();\n  for (var i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var obj = oneToOneIdMap.get(id);\n    var objectsToMergeIn = oneToManyIdMap.get(id) || [];\n    mergeF(obj, objectsToMergeIn);\n  }\n}\n\n/**\n * Map with arbitrary keys and values. User .set() and .get() to work with values instead of []\n * @returns {{set: Function, get: Function, remove: Function, exist: Function, getKeys: Function}}\n * @constructor\n */\nfunction KVMap() {\n  var _originalKeyFieldName = 'originalKey';\n  var _valueKeyFieldName = 'value';\n  var _dict = {};\n  var keyToString = function(key) { return key.toString(); };\n  var mapImpl = {\n    set: function(key, value) {\n      var recordObj = {};\n      recordObj[_originalKeyFieldName] = key;\n      recordObj[_valueKeyFieldName] = value;\n      _dict[keyToString(key)] = recordObj;\n      return true;\n    },\n    get: function(key) {\n      var storeObj = _dict[keyToString(key)];\n      if (storeObj) {\n        return storeObj[_valueKeyFieldName];\n      } else {\n        return undefined;\n      }\n    },\n    remove: function(key) {\n      delete _dict[keyToString(key)];\n      return true;\n    },\n    exist: function(key) {\n      var result = _dict.hasOwnProperty(keyToString(key));\n      return result;\n    },\n    getKeys: function() {\n      var result = [];\n      for (var key in _dict) {\n        result.push(_dict[key][_originalKeyFieldName]);\n      }\n      return result;\n    },\n\n  };\n  return mapImpl;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/transaction.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback-datasource-juggler\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n'use strict';\n\nvar g = require('strong-globalize')();\nvar debug = require('debug')('loopback:connector:transaction');\nvar uuid = require('uuid');\nvar utils = require('./utils');\nvar jutil = require('./jutil');\nvar ObserverMixin = require('./observer');\n\nvar Transaction = require('loopback-connector').Transaction;\n\nmodule.exports = TransactionMixin;\n\n/**\n * TransactionMixin class.  Use to add transaction APIs to a model class.\n *\n * @class TransactionMixin\n */\nfunction TransactionMixin() {\n}\n\n/**\n * Begin a new transaction\n * @param {Object|String} [options] Options can be one of the forms:\n * - Object: {isolationLevel: '...', timeout: 1000}\n * - String: isolationLevel\n *\n * Valid values of `isolationLevel` are:\n *\n * - Transaction.READ_COMMITTED = 'READ COMMITTED'; // default\n * - Transaction.READ_UNCOMMITTED = 'READ UNCOMMITTED';\n * - Transaction.SERIALIZABLE = 'SERIALIZABLE';\n * - Transaction.REPEATABLE_READ = 'REPEATABLE READ';\n *\n * @param {Function} cb Callback function. It calls back with (err, transaction).\n * To pass the transaction context to one of the CRUD methods, use the `options`\n * argument with `transaction` property, for example,\n *\n * ```js\n *\n * MyModel.beginTransaction('READ COMMITTED', function(err, tx) {\n *   MyModel.create({x: 1, y: 'a'}, {transaction: tx}, function(err, inst) {\n *     MyModel.find({x: 1}, {transaction: tx}, function(err, results) {\n *       // ...\n *       tx.commit(function(err) {...});\n *     });\n *   });\n * });\n * ```\n *\n * The transaction can be committed or rolled back. If timeout happens, the\n * transaction will be rolled back. Please note a transaction is typically\n * associated with a pooled connection. Committing or rolling back a transaction\n * will release the connection back to the pool.\n *\n * Once the transaction is committed or rolled back, the connection property\n * will be set to null to mark the transaction to be inactive. Trying to commit\n * or rollback an inactive transaction will receive an error from the callback.\n *\n * Please also note that the transaction is only honored with the same data\n * source/connector instance. CRUD methods will not join the current transaction\n * if its model is not attached the same data source.\n *\n */\nTransactionMixin.beginTransaction = function(options, cb) {\n  cb = cb || utils.createPromiseCallback();\n  if (Transaction) {\n    var connector = this.getConnector();\n    Transaction.begin(connector, options, function(err, transaction) {\n      if (err) return cb(err);\n      if (transaction) {\n        // Set an informational transaction id\n        transaction.id = uuid.v1();\n      }\n      if (options.timeout) {\n        setTimeout(function() {\n          var context = {\n            transaction: transaction,\n            operation: 'timeout',\n          };\n          transaction.notifyObserversOf('timeout', context, function(err) {\n            if (!err) {\n              transaction.rollback(function() {\n                debug('Transaction %s is rolled back due to timeout',\n                  transaction.id);\n              });\n            }\n          });\n        }, options.timeout);\n      }\n      cb(err, transaction);\n    });\n  } else {\n    process.nextTick(function() {\n      var err = new Error(g.f('{{Transaction}} is not supported'));\n      cb(err);\n    });\n  }\n  return cb.promise;\n};\n\n// Promisify the transaction apis\nif (Transaction) {\n  jutil.mixin(Transaction.prototype, ObserverMixin);\n  /**\n   * Commit a transaction and release it back to the pool\n   * @param {Function} cb Callback function\n   * @returns {Promise|undefined}\n   */\n  Transaction.prototype.commit = function(cb) {\n    var self = this;\n    cb = cb || utils.createPromiseCallback();\n    // Report an error if the transaction is not active\n    if (!self.connection) {\n      process.nextTick(function() {\n        cb(new Error(g.f('The {{transaction}} is not active: %s', self.id)));\n      });\n      return cb.promise;\n    }\n    var context = {\n      transaction: self,\n      operation: 'commit',\n    };\n\n    function work(done) {\n      self.connector.commit(self.connection, done);\n    }\n\n    self.notifyObserversAround('commit', context, work, function(err) {\n      // Deference the connection to mark the transaction is not active\n      // The connection should have been released back the pool\n      self.connection = null;\n      cb(err);\n    });\n\n    return cb.promise;\n  };\n\n  /**\n   * Rollback a transaction and release it back to the pool\n   * @param {Function} cb Callback function\n   * @returns {Promise|undefined}\n   */\n  Transaction.prototype.rollback = function(cb) {\n    var self = this;\n    cb = cb || utils.createPromiseCallback();\n    // Report an error if the transaction is not active\n    if (!self.connection) {\n      process.nextTick(function() {\n        cb(new Error(g.f('The {{transaction}} is not active: %s', self.id)));\n      });\n      return cb.promise;\n    }\n    var context = {\n      transaction: self,\n      operation: 'rollback',\n    };\n\n    function work(done) {\n      self.connector.rollback(self.connection, done);\n    }\n\n    self.notifyObserversAround('rollback', context, work, function(err) {\n      // Deference the connection to mark the transaction is not active\n      // The connection should have been released back the pool\n      self.connection = null;\n      cb(err);\n    });\n\n    return cb.promise;\n  };\n\n  Transaction.prototype.toJSON = function() {\n    return this.id;\n  };\n\n  Transaction.prototype.toString = function() {\n    return this.id;\n  };\n}\n\nTransactionMixin.Transaction = Transaction;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/index.js":"'use strict';\n\nfunction KeyValueAccessObject() {\n};\n\nmodule.exports = KeyValueAccessObject;\n\nKeyValueAccessObject.delete = require('./delete');\nKeyValueAccessObject.deleteAll = require('./delete-all');\nKeyValueAccessObject.get = require('./get');\nKeyValueAccessObject.set = require('./set');\nKeyValueAccessObject.expire = require('./expire');\nKeyValueAccessObject.ttl = require('./ttl');\nKeyValueAccessObject.iterateKeys = require('./iterate-keys');\nKeyValueAccessObject.keys = require('./keys');\n\nKeyValueAccessObject.getConnector = function() {\n  return this.getDataSource().connector;\n};\n\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/delete.js":"'use strict';\n\nvar assert = require('assert');\nvar debug = require('debug')('loopback:kvao:delete');\nvar utils = require('../utils');\n\n/**\n * Delete the key-value pair associated to the given key.\n *\n * @param {String} key Key to use when searching the database.\n * @options {Object} options\n * @callback {Function} callback\n * @param {Error} err Error object.\n * @param {*} result Value associated with the given key.\n * @promise\n *\n * @header KVAO.prototype.delete(key[, options], cb)\n */\nmodule.exports = function keyValueDelete(key, options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof key === 'string' && key, 'key must be a non-empty string');\n\n  callback = callback || utils.createPromiseCallback();\n\n  var connector = this.getConnector();\n  if (typeof connector.delete === 'function') {\n    connector.delete(this.modelName, key, options, callback);\n  } else {\n    var errMsg = 'Connector does not support key-value pair deletion';\n    debug(errMsg);\n    process.nextTick(function() {\n      var err = new Error(errMsg);\n      err.statusCode = 501;\n      callback(err);\n    });\n  }\n\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/delete-all.js":"'use strict';\n\nvar assert = require('assert');\nvar async = require('async');\nvar debug = require('debug')('loopback:kvao:delete-all');\nvar utils = require('../utils');\n\n/**\n * Delete all keys (and values) associated to the current model.\n *\n * @options {Object} options Unused ATM, placeholder for future options.\n * @callback {Function} callback\n * @param {Error} err Error object.\n * @promise\n *\n * @header KVAO.prototype.deleteAll([options, ]cb)\n */\nmodule.exports = function deleteAll(options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof options === 'object', 'options must be an object');\n\n  callback = callback || utils.createPromiseCallback();\n\n  var connector = this.getConnector();\n  if (typeof connector.deleteAll === 'function') {\n    connector.deleteAll(this.modelName, options, callback);\n  } else if (typeof connector.delete === 'function') {\n    debug('Falling back to unoptimized key-value pair deletion');\n    iterateAndDelete(connector, this.modelName, options, callback);\n  } else {\n    var errMsg = 'Connector does not support key-value pair deletion';\n    debug(errMsg);\n    process.nextTick(function() {\n      var err = new Error(errMsg);\n      err.statusCode = 501;\n      callback(err);\n    });\n  }\n  return callback.promise;\n};\n\nfunction iterateAndDelete(connector, modelName, options, callback) {\n  var iter = connector.iterateKeys(modelName, {});\n  var keys = [];\n  iter.next(onNextKey);\n\n  function onNextKey(err, key) {\n    if (err) return callback(err);\n    if (key === undefined) return callback();\n    connector.delete(modelName, key, options, onDeleted);\n  }\n\n  function onDeleted(err) {\n    if (err) return callback(err);\n    iter.next(onNextKey);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/get.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Return the value associated with a given key.\n *\n * @param {String} key Key to use when searching the database.\n * @options {Object} options\n * @callback {Function} callback\n * @param {Error} err Error object.\n * @param {*} result Value associated with the given key.\n * @promise\n *\n * @header KVAO.get(key, cb)\n */\nmodule.exports = function keyValueGet(key, options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof key === 'string' && key, 'key must be a non-empty string');\n\n  callback = callback || utils.createPromiseCallback();\n  this.getConnector().get(this.modelName, key, options, function(err, result) {\n    // TODO convert raw result to Model instance (?)\n    callback(err, result);\n  });\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/set.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Persist a value and associate it with the given key.\n *\n * @param {String} key Key to associate with the given value.\n * @param {*} value Value to persist.\n * @options {Number|Object} options Optional settings for the key-value\n *   pair. If a Number is provided, it is set as the TTL (time to live) in ms\n *   (milliseconds) for the key-value pair.\n * @property {Number} ttl TTL for the key-value pair in ms.\n * @callback {Function} callback\n * @param {Error} err Error object.\n * @promise\n *\n * @header KVAO.set(key, value, cb)\n */\nmodule.exports = function keyValueSet(key, value, options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (typeof options === 'number') {\n    options = {ttl: options};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof key === 'string' && key, 'key must be a non-empty string');\n  assert(value != null, 'value must be defined and not null');\n  assert(typeof options === 'object', 'options must be an object');\n  if (options && 'ttl' in options) {\n    assert(typeof options.ttl === 'number' && options.ttl > 0,\n      'options.ttl must be a positive number');\n  }\n\n  callback = callback || utils.createPromiseCallback();\n\n  // TODO convert possible model instance in \"value\" to raw data via toObect()\n  this.getConnector().set(this.modelName, key, value, options, callback);\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/expire.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Set the TTL (time to live) in ms (milliseconds) for a given key. TTL is the\n * remaining time before a key-value pair is discarded from the database.\n *\n * @param {String} key Key to use when searching the database.\n * @param {Number} ttl TTL in ms to set for the key.\n * @options {Object} options\n * @callback {Function} callback\n * @param {Error} err Error object.\n * @promise\n *\n * @header KVAO.expire(key, ttl, cb)\n */\nmodule.exports = function keyValueExpire(key, ttl, options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof key === 'string' && key, 'key must be a non-empty string');\n  assert(typeof ttl === 'number' && ttl > 0, 'ttl must be a positive integer');\n  assert(typeof options === 'object', 'options must be an object');\n\n  callback = callback || utils.createPromiseCallback();\n  this.getConnector().expire(this.modelName, key, ttl, options, callback);\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/ttl.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Return the TTL (time to live) for a given key. TTL is the remaining time\n * before a key-value pair is discarded from the database.\n *\n * @param {String} key Key to use when searching the database.\n * @options {Object} options\n * @callback {Function} callback\n * @param {Error} error\n * @param {Number} ttl Expiration time for the key-value pair. `undefined` if\n *   TTL was not initially set.\n * @promise\n *\n * @header KVAO.ttl(key, cb)\n */\nmodule.exports = function keyValueTtl(key, options, callback) {\n  if (callback == undefined && typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  assert(typeof key === 'string' && key, 'key must be a non-empty string');\n  assert(typeof options === 'object', 'options must be an object');\n\n  callback = callback || utils.createPromiseCallback();\n  this.getConnector().ttl(this.modelName, key, options, callback);\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/iterate-keys.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Asynchronously iterate all keys in the database. Similar to `.keys()` but\n * instead allows for iteration over large data sets without having to load\n * everything into memory at once.\n *\n * @param {Object} filter An optional filter object with the following\n * @param {String} filter.match Glob string to use to filter returned\n *   keys (i.e. `userid.*`). All connectors are required to support `*` and\n *   `?`. They may also support additional special characters that are\n *   specific to the backing database.\n * @param {Object} options\n * @returns {AsyncIterator} An Object implementing `next(cb) -> Promise`\n *   function that can be used to iterate all keys.\n *\n * @header KVAO.iterateKeys(filter)\n */\nmodule.exports = function keyValueIterateKeys(filter, options) {\n  filter = filter || {};\n  options = options || {};\n\n  assert(typeof filter === 'object', 'filter must be an object');\n  assert(typeof options === 'object', 'options must be an object');\n\n  var iter = this.getConnector().iterateKeys(this.modelName, filter, options);\n  // promisify the returned iterator\n  return {\n    next: function(callback) {\n      callback = callback || utils.createPromiseCallback();\n      iter.next(callback);\n      return callback.promise;\n    },\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-datasource-juggler/lib/kvao/keys.js":"'use strict';\n\nvar assert = require('assert');\nvar utils = require('../utils');\n\n/**\n * Return all keys in the database.\n *\n * **WARNING**: This method is not suitable for large data sets as all\n * key-values pairs are loaded into memory at once. For large data sets,\n * use `iterateKeys()` instead.\n *\n * @param {Object} filter An optional filter object with the following\n * @param {String} filter.match Glob string used to filter returned\n *   keys (i.e. `userid.*`). All connectors are required to support `*` and\n *   `?`, but may also support additional special characters specific to the\n *   database.\n * @param {Object} options\n * @callback {Function} callback\n * @promise\n *\n *\n * @header KVAO.keys(filter, callback)\n */\nmodule.exports = function keyValueKeys(filter, options, callback) {\n  if (callback === undefined) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options === undefined && typeof filter === 'function') {\n      callback = filter;\n      filter = undefined;\n    }\n  }\n\n  filter = filter || {};\n  options = options || {};\n\n  assert(typeof filter === 'object', 'filter must be an object');\n  assert(typeof options === 'object', 'options must be an object');\n\n  callback = callback || utils.createPromiseCallback();\n\n  var iter = this.iterateKeys(filter, options);\n  var keys = [];\n  iter.next(onNextKey);\n\n  function onNextKey(err, key) {\n    if (err) return callback(err);\n    if (key === undefined) return callback(null, keys);\n    keys.push(key);\n    iter.next(onNextKey);\n  }\n\n  return callback.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/registry.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('./globalize');\nvar assert = require('assert');\nvar extend = require('util')._extend;\nvar juggler = require('loopback-datasource-juggler');\nvar debug = require('debug')('loopback:registry');\nvar DataSource = juggler.DataSource;\nvar ModelBuilder = juggler.ModelBuilder;\nvar deprecated = require('depd')('strong-remoting');\n\nmodule.exports = Registry;\n\n/**\n * Define and reference `Models` and `DataSources`.\n *\n * @class\n */\n\nfunction Registry() {\n  this.defaultDataSources = {};\n  this.modelBuilder = new ModelBuilder();\n  require('./model')(this);\n  require('./persisted-model')(this);\n\n  // Set the default model base class.\n  this.modelBuilder.defaultModelBaseClass = this.getModel('Model');\n}\n\n/**\n * Create a named vanilla JavaScript class constructor with an attached\n * set of properties and options.\n *\n * This function comes with two variants:\n *  * `loopback.createModel(name, properties, options)`\n *  * `loopback.createModel(config)`\n *\n * In the second variant, the parameters `name`, `properties` and `options`\n * are provided in the config object. Any additional config entries are\n * interpreted as `options`, i.e. the following two configs are identical:\n *\n * ```js\n * { name: 'Customer', base: 'User' }\n * { name: 'Customer', options: { base: 'User' } }\n * ```\n *\n * **Example**\n *\n * Create an `Author` model using the three-parameter variant:\n *\n * ```js\n * loopback.createModel(\n *   'Author',\n *   {\n *     firstName: 'string',\n *     lastName: 'string'\n *   },\n *   {\n *     relations: {\n *       books: {\n *         model: 'Book',\n *         type: 'hasAndBelongsToMany'\n *       }\n *     }\n *   }\n * );\n * ```\n *\n * Create the same model using a config object:\n *\n * ```js\n * loopback.createModel({\n *   name: 'Author',\n *   properties: {\n *     firstName: 'string',\n *     lastName: 'string'\n *   },\n *   relations: {\n *     books: {\n *       model: 'Book',\n *       type: 'hasAndBelongsToMany'\n *     }\n *   }\n * });\n * ```\n *\n * @param {String} name Unique name.\n * @param {Object} properties\n * @param {Object} options (optional)\n *\n * @header loopback.createModel\n */\n\nRegistry.prototype.createModel = function(name, properties, options) {\n  if (arguments.length === 1 && typeof name === 'object') {\n    var config = name;\n    name = config.name;\n    properties = config.properties;\n    options = buildModelOptionsFromConfig(config);\n\n    assert(typeof name === 'string',\n      'The model-config property `name` must be a string');\n  }\n\n  options = options || {};\n  var BaseModel = options.base || options.super;\n\n  if (typeof BaseModel === 'string') {\n    var baseName = BaseModel;\n    BaseModel = this.findModel(BaseModel);\n    if (!BaseModel) {\n      throw new Error(g.f('Model not found: model `%s` is extending an unknown model `%s`.',\n        name, baseName));\n    }\n  }\n\n  BaseModel = BaseModel || this.getModel('PersistedModel');\n  var model = BaseModel.extend(name, properties, options);\n  model.registry = this;\n\n  this._defineRemoteMethods(model, model.settings.methods);\n\n  return model;\n};\n\nfunction buildModelOptionsFromConfig(config) {\n  var options = extend({}, config.options);\n  for (var key in config) {\n    if (['name', 'properties', 'options'].indexOf(key) !== -1) {\n      // Skip items which have special meaning\n      continue;\n    }\n\n    if (options[key] !== undefined) {\n      // When both `config.key` and `config.options.key` are set,\n      // use the latter one\n      continue;\n    }\n\n    options[key] = config[key];\n  }\n  return options;\n}\n\n/*\n * Add the acl entry to the acls\n * @param {Object[]} acls\n * @param {Object} acl\n */\nfunction addACL(acls, acl) {\n  for (var i = 0, n = acls.length; i < n; i++) {\n    // Check if there is a matching acl to be overriden\n    if (acls[i].property === acl.property &&\n      acls[i].accessType === acl.accessType &&\n      acls[i].principalType === acl.principalType &&\n      acls[i].principalId === acl.principalId) {\n      acls[i] = acl;\n      return;\n    }\n  }\n  acls.push(acl);\n}\n\n/**\n * Alter an existing Model class.\n * @param {Model} ModelCtor The model constructor to alter.\n * @options {Object} config Additional configuration to apply\n * @property {DataSource} dataSource Attach the model to a dataSource.\n * @property {Object} [relations] Model relations to add/update.\n *\n * @header loopback.configureModel(ModelCtor, config)\n */\n\nRegistry.prototype.configureModel = function(ModelCtor, config) {\n  var settings = ModelCtor.settings;\n  var modelName = ModelCtor.modelName;\n\n  // Relations\n  if (typeof config.relations === 'object' && config.relations !== null) {\n    var relations = settings.relations = settings.relations || {};\n    Object.keys(config.relations).forEach(function(key) {\n      // FIXME: [rfeng] We probably should check if the relation exists\n      relations[key] = extend(relations[key] || {}, config.relations[key]);\n    });\n  } else if (config.relations != null) {\n    g.warn('The relations property of `%s` configuration ' +\n      'must be an object', modelName);\n  }\n\n  // ACLs\n  if (Array.isArray(config.acls)) {\n    var acls = settings.acls = settings.acls || [];\n    config.acls.forEach(function(acl) {\n      addACL(acls, acl);\n    });\n  } else if (config.acls != null) {\n    g.warn('The acls property of `%s` configuration ' +\n      'must be an array of objects', modelName);\n  }\n\n  // Settings\n  var excludedProperties = {\n    base: true,\n    'super': true,\n    relations: true,\n    acls: true,\n    dataSource: true,\n  };\n  if (typeof config.options === 'object' && config.options !== null) {\n    for (var p in config.options) {\n      if (!(p in excludedProperties)) {\n        settings[p] = config.options[p];\n      } else {\n        g.warn('Property `%s` cannot be reconfigured for `%s`',\n          p, modelName);\n      }\n    }\n  } else if (config.options != null) {\n    g.warn('The options property of `%s` configuration ' +\n      'must be an object', modelName);\n  }\n\n  // It's important to attach the datasource after we have updated\n  // configuration, so that the datasource picks up updated relations\n  if (config.dataSource) {\n    assert(config.dataSource instanceof DataSource,\n        'Cannot configure ' + ModelCtor.modelName +\n        ': config.dataSource must be an instance of DataSource');\n    ModelCtor.attachTo(config.dataSource);\n    debug('Attached model `%s` to dataSource `%s`',\n      modelName, config.dataSource.name);\n  } else if (config.dataSource === null || config.dataSource === false) {\n    debug('Model `%s` is not attached to any DataSource by configuration.',\n      modelName);\n  } else {\n    debug('Model `%s` is not attached to any DataSource, possibly by a mistake.',\n      modelName);\n    g.warn(\n      'The configuration of `%s` is missing {{`dataSource`}} property.\\n' +\n      'Use `null` or `false` to mark models not attached to any data source.',\n      modelName);\n  }\n\n  var newMethodNames = config.methods && Object.keys(config.methods);\n  var hasNewMethods = newMethodNames && newMethodNames.length;\n  var hasDescendants = this.getModelByType(ModelCtor) !== ModelCtor;\n  if (hasNewMethods && hasDescendants) {\n    g.warn(\n      'Child models of `%s` will not inherit newly defined remote methods %s.',\n      modelName, newMethodNames);\n  }\n\n  // Remote methods\n  this._defineRemoteMethods(ModelCtor, config.methods);\n};\n\nRegistry.prototype._defineRemoteMethods = function(ModelCtor, methods) {\n  if (!methods) return;\n  if (typeof methods !== 'object') {\n    g.warn('Ignoring non-object \"methods\" setting of \"%s\".',\n      ModelCtor.modelName);\n    return;\n  }\n\n  Object.keys(methods).forEach(function(key) {\n    var meta = methods[key];\n    var m = key.match(/^prototype\\.(.*)$/);\n    var isStatic = !m;\n\n    if (typeof meta.isStatic !== 'boolean') {\n      key = isStatic ? key : m[1];\n      meta.isStatic = isStatic;\n    } else if (meta.isStatic && m) {\n      throw new Error(g.f('Remoting metadata for %s.%s {{\"isStatic\"}} does ' +\n      'not match new method name-based style.', ModelCtor.modelName, key));\n    } else {\n      key = isStatic ? key : m[1];\n      deprecated(g.f('Remoting metadata {{\"isStatic\"}} is deprecated. Please ' +\n      'specify {{\"prototype.name\"}} in method name instead for {{isStatic=false}}.'));\n    }\n    ModelCtor.remoteMethod(key, meta);\n  });\n};\n\n/**\n * Look up a model class by name from all models created by\n * `loopback.createModel()`\n * @param {String|Function} modelOrName The model name or a `Model` constructor.\n * @returns {Model} The model class\n *\n * @header loopback.findModel(modelName)\n */\nRegistry.prototype.findModel = function(modelName) {\n  if (typeof modelName === 'function') return modelName;\n  return this.modelBuilder.models[modelName];\n};\n\n/**\n * Look up a model class by name from all models created by\n * `loopback.createModel()`. **Throw an error when no such model exists.**\n *\n * @param {String} modelOrName The model name or a `Model` constructor.\n * @returns {Model} The model class\n *\n * @header loopback.getModel(modelName)\n */\nRegistry.prototype.getModel = function(modelName) {\n  var model = this.findModel(modelName);\n  if (model) return model;\n\n  throw new Error(g.f('Model not found: %s', modelName));\n};\n\n/**\n * Look up a model class by the base model class.\n * The method can be used by LoopBack\n * to find configured models in models.json over the base model.\n * @param {Model} modelType The base model class\n * @returns {Model} The subclass if found or the base class\n *\n * @header loopback.getModelByType(modelType)\n */\nRegistry.prototype.getModelByType = function(modelType) {\n  var type = typeof modelType;\n  var accepted = ['function', 'string'];\n\n  assert(accepted.indexOf(type) > -1,\n    'The model type must be a constructor or model name');\n\n  if (type === 'string') {\n    modelType = this.getModel(modelType);\n  }\n\n  var models = this.modelBuilder.models;\n  for (var m in models) {\n    if (models[m].prototype instanceof modelType) {\n      return models[m];\n    }\n  }\n  return modelType;\n};\n\n/**\n * Create a data source with passing the provided options to the connector.\n *\n * @param {String} name Optional name.\n * @options {Object} options Data Source options\n * @property {Object} connector LoopBack connector.\n * @property {*} [*] Other&nbsp;connector properties.\n *   See the relevant connector documentation.\n */\n\nRegistry.prototype.createDataSource = function(name, options) {\n  var self = this;\n\n  var ds = new DataSource(name, options, self.modelBuilder);\n  ds.createModel = function(name, properties, settings) {\n    settings = settings || {};\n    var BaseModel = settings.base || settings.super;\n    if (!BaseModel) {\n      // Check the connector types\n      var connectorTypes = ds.getTypes();\n      if (Array.isArray(connectorTypes) && connectorTypes.indexOf('db') !== -1) {\n        // Only set up the base model to PersistedModel if the connector is DB\n        BaseModel = self.PersistedModel;\n      } else {\n        BaseModel = self.Model;\n      }\n      settings.base = BaseModel;\n    }\n    var ModelCtor = self.createModel(name, properties, settings);\n    ModelCtor.attachTo(ds);\n    return ModelCtor;\n  };\n\n  if (ds.settings && ds.settings.defaultForType) {\n    var msg = g.f('{{DataSource}} option {{\"defaultForType\"}} is no longer supported');\n    throw new Error(msg);\n  }\n\n  return ds;\n};\n\n/**\n * Get an in-memory data source. Use one if it already exists.\n *\n * @param {String} [name] The name of the data source.\n * If not provided, the `'default'` is used.\n */\n\nRegistry.prototype.memory = function(name) {\n  name = name || 'default';\n  var memory = (\n    this._memoryDataSources || (this._memoryDataSources = {})\n    )[name];\n\n  if (!memory) {\n    memory = this._memoryDataSources[name] = this.createDataSource({\n      connector: 'memory',\n    });\n  }\n\n  return memory;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/model.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module Dependencies.\n */\n'use strict';\nvar g = require('./globalize');\nvar assert = require('assert');\nvar debug = require('debug')('loopback:model');\nvar RemoteObjects = require('strong-remoting');\nvar SharedClass = require('strong-remoting').SharedClass;\nvar extend = require('util')._extend;\nvar format = require('util').format;\n\nvar deprecated = require('depd')('loopback');\n\nmodule.exports = function(registry) {\n  /**\n   * The base class for **all models**.\n   *\n   * **Inheriting from `Model`**\n   *\n   * ```js\n   * var properties = {...};\n   * var options = {...};\n   * var MyModel = loopback.Model.extend('MyModel', properties, options);\n   * ```\n   *\n   * **Options**\n   *\n   *  - `trackChanges` - If true, changes to the model will be tracked. **Required\n   * for replication.**\n   *\n   * **Events**\n   *\n   * #### Event: `changed`\n   *\n   * Emitted after a model has been successfully created, saved, or updated.\n   * Argument: `inst`, model instance, object\n   *\n   * ```js\n   * MyModel.on('changed', function(inst) {\n   *   console.log('model with id %s has been changed', inst.id);\n   *   // => model with id 1 has been changed\n   * });\n   * ```\n   *\n   * #### Event: `deleted`\n   *\n   * Emitted after an individual model has been deleted.\n   * Argument: `id`, model ID (number).\n   *\n   * ```js\n   * MyModel.on('deleted', function(id) {\n   *   console.log('model with id %s has been deleted', id);\n   *   // => model with id 1 has been deleted\n   * });\n   * ```\n   *\n   * #### Event: `deletedAll`\n   *\n   * Emitted after all models have been deleted.\n   * Argument: `where` (optional), where filter, JSON object.\n   *\n   * ```js\n   * MyModel.on('deletedAll', function(where) {\n   *   if (where) {\n   *     console.log('all models where ', where, ' have been deleted');\n   *     // => all models where\n   *     // => {price: {gt: 100}}\n   *     // => have been deleted\n   *   }\n   * });\n   * ```\n   *\n   * #### Event: `attached`\n   *\n   * Emitted after a `Model` has been attached to an `app`.\n   *\n   * #### Event: `dataSourceAttached`\n   *\n   * Emitted after a `Model` has been attached to a `DataSource`.\n   *\n   * #### Event: set\n   *\n   * Emitted when model property is set.\n   * Argument: `inst`, model instance, object\n   *\n   * ```js\n   * MyModel.on('set', function(inst) {\n   *   console.log('model with id %s has been changed', inst.id);\n   *   // => model with id 1 has been changed\n   * });\n   * ```\n   *\n   * @param {Object} data\n   * @property {String} Model.modelName The name of the model. Static property.\n   * @property {DataSource} Model.dataSource Data source to which the model is connected, if any. Static property.\n   * @property {SharedClass} Model.sharedMethod The `strong-remoting` [SharedClass](http://apidocs.strongloop.com/strong-remoting/#sharedclass) that contains remoting (and http) metadata. Static property.\n   * @property {Object} settings Contains additional model settings.\n   * @property {string} settings.http.path Base URL of the model HTTP route.\n   * @property [{string}] settings.acls Array of ACLs for the model.\n   * @class\n   */\n  var Model = registry.modelBuilder.define('Model');\n\n  Model.registry = registry;\n\n  /**\n   * The `loopback.Model.extend()` method calls this when you create a model that extends another model.\n   * Add any setup or configuration code you want executed when the model is created.\n   * See  [Setting up a custom model](http://loopback.io/doc/en/lb2/Extending-built-in-models.html#setting-up-a-custom-model).\n   */\n\n  Model.setup = function() {\n    var ModelCtor = this;\n    var Parent = this.super_;\n\n    if (!ModelCtor.registry && Parent && Parent.registry) {\n      ModelCtor.registry = Parent.registry;\n    }\n\n    var options = this.settings;\n    var typeName = this.modelName;\n\n    // support remoting prototype methods\n    // it's important to setup this function *before* calling `new SharedClass`\n    // otherwise remoting metadata from our base model is picked up\n    ModelCtor.sharedCtor = function(data, id, options, fn) {\n      var ModelCtor = this;\n\n      var isRemoteInvocationWithOptions = typeof data !== 'object' &&\n        typeof id === 'object' &&\n        typeof options === 'function';\n      if (isRemoteInvocationWithOptions) {\n        // sharedCtor(id, options, fn)\n        fn = options;\n        options = id;\n        id = data;\n        data = null;\n      } else if (typeof data === 'function') {\n        // sharedCtor(fn)\n        fn = data;\n        data = null;\n        id = null;\n        options = null;\n      } else if (typeof id === 'function') {\n        // sharedCtor(data, fn)\n        // sharedCtor(id, fn)\n        fn = id;\n        options = null;\n\n        if (typeof data !== 'object') {\n          id = data;\n          data = null;\n        } else {\n          id = null;\n        }\n      }\n\n      if (id && data) {\n        var model = new ModelCtor(data);\n        model.id = id;\n        fn(null, model);\n      } else if (data) {\n        fn(null, new ModelCtor(data));\n      } else if (id) {\n        var filter = {};\n        ModelCtor.findById(id, filter, options, function(err, model) {\n          if (err) {\n            fn(err);\n          } else if (model) {\n            fn(null, model);\n          } else {\n            err = new Error(g.f('could not find a model with {{id}} %s', id));\n            err.statusCode = 404;\n            err.code = 'MODEL_NOT_FOUND';\n            fn(err);\n          }\n        });\n      } else {\n        fn(new Error(g.f('must specify an {{id}} or {{data}}')));\n      }\n    };\n\n    var idDesc = ModelCtor.modelName + ' id';\n    ModelCtor.sharedCtor.accepts = [\n      {arg: 'id', type: 'any', required: true, http: {source: 'path'},\n        description: idDesc},\n      // {arg: 'instance', type: 'object', http: {source: 'body'}}\n      {arg: 'options', type: 'object', http: createOptionsViaModelMethod},\n    ];\n\n    ModelCtor.sharedCtor.http = [\n      {path: '/:id'},\n    ];\n\n    ModelCtor.sharedCtor.returns = {root: true};\n\n    var remotingOptions = {};\n    extend(remotingOptions, options.remoting || {});\n\n    // create a sharedClass\n    var sharedClass = ModelCtor.sharedClass = new SharedClass(\n      ModelCtor.modelName,\n      ModelCtor,\n      remotingOptions\n    );\n\n    // before remote hook\n    ModelCtor.beforeRemote = function(name, fn) {\n      var className = this.modelName;\n      this._runWhenAttachedToApp(function(app) {\n        var remotes = app.remotes();\n        remotes.before(className + '.' + name, function(ctx, next) {\n          return fn(ctx, ctx.result, next);\n        });\n      });\n    };\n\n    // after remote hook\n    ModelCtor.afterRemote = function(name, fn) {\n      var className = this.modelName;\n      this._runWhenAttachedToApp(function(app) {\n        var remotes = app.remotes();\n        remotes.after(className + '.' + name, function(ctx, next) {\n          return fn(ctx, ctx.result, next);\n        });\n      });\n    };\n\n    ModelCtor.afterRemoteError = function(name, fn) {\n      var className = this.modelName;\n      this._runWhenAttachedToApp(function(app) {\n        var remotes = app.remotes();\n        remotes.afterError(className + '.' + name, fn);\n      });\n    };\n\n    ModelCtor._runWhenAttachedToApp = function(fn) {\n      if (this.app) return fn(this.app);\n      var self = this;\n      self.once('attached', function() {\n        fn(self.app);\n      });\n    };\n\n    if ('injectOptionsFromRemoteContext' in options) {\n      console.warn(g.f(\n        '%s is using model setting %s which is no longer available.',\n        typeName, 'injectOptionsFromRemoteContext'));\n      console.warn(g.f(\n        'Please rework your app to use the offical solution for injecting ' +\n          '\"options\" argument from request context,\\nsee %s',\n        'http://loopback.io/doc/en/lb3/Using-current-context.html'));\n    }\n\n    // resolve relation functions\n    sharedClass.resolve(function resolver(define) {\n      var relations = ModelCtor.relations || {};\n      var defineRaw = define;\n      define = function(name, options, fn) {\n        if (options.accepts) {\n          options = extend({}, options);\n          options.accepts = setupOptionsArgs(options.accepts);\n        }\n        defineRaw(name, options, fn);\n      };\n\n      // get the relations\n      for (var relationName in relations) {\n        var relation = relations[relationName];\n        if (relation.type === 'belongsTo') {\n          ModelCtor.belongsToRemoting(relationName, relation, define);\n        } else if (\n          relation.type === 'hasOne' ||\n          relation.type === 'embedsOne'\n        ) {\n          ModelCtor.hasOneRemoting(relationName, relation, define);\n        } else if (\n          relation.type === 'hasMany' ||\n          relation.type === 'embedsMany' ||\n          relation.type === 'referencesMany') {\n          ModelCtor.hasManyRemoting(relationName, relation, define);\n        }\n      }\n\n      // handle scopes\n      var scopes = ModelCtor.scopes || {};\n      for (var scopeName in scopes) {\n        ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);\n      }\n    });\n\n    return ModelCtor;\n  };\n\n  /*!\n   * Get the reference to ACL in a lazy fashion to avoid race condition in require\n   */\n  var _aclModel = null;\n  Model._ACL = function getACL(ACL) {\n    var registry = this.registry;\n    if (ACL !== undefined) {\n      // The function is used as a setter\n      _aclModel = ACL;\n    }\n    if (_aclModel) {\n      return _aclModel;\n    }\n    var aclModel = registry.getModel('ACL');\n    _aclModel = registry.getModelByType(aclModel);\n    return _aclModel;\n  };\n\n  /**\n   * Check if the given access token can invoke the specified method.\n   *\n   * @param {AccessToken} token The access token.\n   * @param {*} modelId The model ID.\n   * @param {SharedMethod} sharedMethod The method in question.\n   * @param {Object} ctx The remote invocation context.\n   * @callback {Function} callback The callback function.\n   * @param {String|Error} err The error object.\n   * @param {Boolean} allowed True if the request is allowed; false otherwise.\n   */\n\n  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {\n    var ANONYMOUS = registry.getModel('AccessToken').ANONYMOUS;\n    token = token || ANONYMOUS;\n    var aclModel = Model._ACL();\n\n    ctx = ctx || {};\n    if (typeof ctx === 'function' && callback === undefined) {\n      callback = ctx;\n      ctx = {};\n    }\n\n    aclModel.checkAccessForContext({\n      accessToken: token,\n      model: this,\n      property: sharedMethod.name,\n      method: sharedMethod.name,\n      sharedMethod: sharedMethod,\n      modelId: modelId,\n      accessType: this._getAccessTypeForMethod(sharedMethod),\n      remotingContext: ctx,\n    }, function(err, accessRequest) {\n      if (err) return callback(err);\n      callback(null, accessRequest.isAllowed());\n    });\n  };\n\n  /*!\n   * Determine the access type for the given `RemoteMethod`.\n   *\n   * @api private\n   * @param {RemoteMethod} method\n   */\n\n  Model._getAccessTypeForMethod = function(method) {\n    if (typeof method === 'string') {\n      method = {name: method};\n    }\n    assert(\n      typeof method === 'object',\n      'method is a required argument and must be a RemoteMethod object'\n    );\n\n    var ACL = Model._ACL();\n\n    // Check the explicit setting of accessType\n    if (method.accessType) {\n      assert(method.accessType === ACL.READ ||\n        method.accessType === ACL.REPLICATE ||\n        method.accessType === ACL.WRITE ||\n        method.accessType === ACL.EXECUTE, 'invalid accessType ' +\n        method.accessType +\n        '. It must be \"READ\", \"REPLICATE\", \"WRITE\", or \"EXECUTE\"');\n      return method.accessType;\n    }\n\n    // Default GET requests to READ\n    var verb = method.http && method.http.verb;\n    if (typeof verb === 'string') {\n      verb = verb.toUpperCase();\n    }\n    if (verb === 'GET' || verb === 'HEAD') {\n      return ACL.READ;\n    }\n\n    switch (method.name) {\n      case 'create':\n        return ACL.WRITE;\n      case 'updateOrCreate':\n        return ACL.WRITE;\n      case 'upsertWithWhere':\n        return ACL.WRITE;\n      case 'upsert':\n        return ACL.WRITE;\n      case 'exists':\n        return ACL.READ;\n      case 'findById':\n        return ACL.READ;\n      case 'find':\n        return ACL.READ;\n      case 'findOne':\n        return ACL.READ;\n      case 'destroyById':\n        return ACL.WRITE;\n      case 'deleteById':\n        return ACL.WRITE;\n      case 'removeById':\n        return ACL.WRITE;\n      case 'count':\n        return ACL.READ;\n      default:\n        return ACL.EXECUTE;\n    }\n  };\n\n  /**\n   * Get the `Application` object to which the Model is attached.\n   *\n   * @callback {Function} callback Callback function called with `(err, app)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Application} app Attached application object.\n   * @end\n   */\n\n  Model.getApp = function(callback) {\n    var self = this;\n    self._runWhenAttachedToApp(function(app) {\n      assert(self.app);\n      assert.equal(app, self.app);\n      callback(null, app);\n    });\n  };\n\n  /**\n   * Enable remote invocation for the specified method.\n   * See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.\n   *\n   * Static method example:\n   * ```js\n   * Model.myMethod();\n   * Model.remoteMethod('myMethod');\n   * ```\n   *\n   * @param {String} name The name of the method.\n   * @param {Object} options The remoting options.\n   * See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).\n   */\n\n  Model.remoteMethod = function(name, options) {\n    if (options.isStatic === undefined) {\n      var m = name.match(/^prototype\\.(.*)$/);\n      options.isStatic = !m;\n      name = options.isStatic ? name : m[1];\n    }\n\n    if (options.accepts) {\n      options = extend({}, options);\n      options.accepts = setupOptionsArgs(options.accepts);\n    }\n\n    this.sharedClass.defineMethod(name, options);\n    this.emit('remoteMethodAdded', this.sharedClass);\n  };\n\n  function setupOptionsArgs(accepts) {\n    if (!Array.isArray(accepts))\n      accepts = [accepts];\n\n    return accepts.map(function(arg) {\n      if (arg.http && arg.http === 'optionsFromRequest') {\n        // clone to preserve the input value\n        arg = extend({}, arg);\n        arg.http = createOptionsViaModelMethod;\n      }\n      return arg;\n    });\n  }\n\n  function createOptionsViaModelMethod(ctx) {\n    var EMPTY_OPTIONS = {};\n    var ModelCtor = ctx.method && ctx.method.ctor;\n    if (!ModelCtor)\n      return EMPTY_OPTIONS;\n    if (typeof ModelCtor.createOptionsFromRemotingContext !== 'function')\n      return EMPTY_OPTIONS;\n    debug('createOptionsFromRemotingContext for %s', ctx.method.stringName);\n    return ModelCtor.createOptionsFromRemotingContext(ctx);\n  }\n\n  /**\n   * Disable remote invocation for the method with the given name.\n   *\n   * @param {String} name The name of the method.\n   * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass\n   * `false` if the method defined on the prototype (eg.\n   * `MyModel.prototype.myMethod`).\n   */\n\n  Model.disableRemoteMethod = function(name, isStatic) {\n    deprecated('Model.disableRemoteMethod is deprecated. ' +\n      'Use Model.disableRemoteMethodByName instead.');\n    var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);\n    this.sharedClass.disableMethodByName(key);\n    this.emit('remoteMethodDisabled', this.sharedClass, key);\n  };\n\n  /**\n   * Disable remote invocation for the method with the given name.\n   *\n   * @param {String} name The name of the method (include \"prototype.\" if the method is defined on the prototype).\n   *\n   */\n\n  Model.disableRemoteMethodByName = function(name) {\n    this.sharedClass.disableMethodByName(name);\n    this.emit('remoteMethodDisabled', this.sharedClass, name);\n  };\n\n  Model.belongsToRemoting = function(relationName, relation, define) {\n    var modelName = relation.modelTo && relation.modelTo.modelName;\n    modelName = modelName || 'PersistedModel';\n    var fn = this.prototype[relationName];\n    var pathName = (relation.options.http && relation.options.http.path) || relationName;\n    define('__get__' + relationName, {\n      isStatic: false,\n      http: {verb: 'get', path: '/' + pathName},\n      accepts: [\n        {arg: 'refresh', type: 'boolean', http: {source: 'query'}},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      accessType: 'READ',\n      description: format('Fetches belongsTo relation %s.', relationName),\n      returns: {arg: relationName, type: modelName, root: true},\n    }, fn);\n  };\n\n  function convertNullToNotFoundError(toModelName, ctx, cb) {\n    if (ctx.result !== null) return cb();\n\n    var fk = ctx.getArgByName('fk');\n    var msg = g.f('Unknown \"%s\" id \"%s\".', toModelName, fk);\n    var error = new Error(msg);\n    error.statusCode = error.status = 404;\n    error.code = 'MODEL_NOT_FOUND';\n    cb(error);\n  }\n\n  Model.hasOneRemoting = function(relationName, relation, define) {\n    var pathName = (relation.options.http && relation.options.http.path) || relationName;\n    var toModelName = relation.modelTo.modelName;\n\n    define('__get__' + relationName, {\n      isStatic: false,\n      http: {verb: 'get', path: '/' + pathName},\n      accepts: [\n        {arg: 'refresh', type: 'boolean', http: {source: 'query'}},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Fetches hasOne relation %s.', relationName),\n      accessType: 'READ',\n      returns: {arg: relationName, type: relation.modelTo.modelName, root: true},\n      rest: {after: convertNullToNotFoundError.bind(null, toModelName)},\n    });\n\n    define('__create__' + relationName, {\n      isStatic: false,\n      http: {verb: 'post', path: '/' + pathName},\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: toModelName,\n          http: {source: 'body'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Creates a new instance in %s of this model.', relationName),\n      accessType: 'WRITE',\n      returns: {arg: 'data', type: toModelName, root: true},\n    });\n\n    define('__update__' + relationName, {\n      isStatic: false,\n      http: {verb: 'put', path: '/' + pathName},\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: toModelName,\n          http: {source: 'body'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Update %s of this model.', relationName),\n      accessType: 'WRITE',\n      returns: {arg: 'data', type: toModelName, root: true},\n    });\n\n    define('__destroy__' + relationName, {\n      isStatic: false,\n      http: {verb: 'delete', path: '/' + pathName},\n      accepts: [\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Deletes %s of this model.', relationName),\n      accessType: 'WRITE',\n    });\n  };\n\n  Model.hasManyRemoting = function(relationName, relation, define) {\n    var pathName = (relation.options.http && relation.options.http.path) || relationName;\n    var toModelName = relation.modelTo.modelName;\n\n    var findByIdFunc = this.prototype['__findById__' + relationName];\n    define('__findById__' + relationName, {\n      isStatic: false,\n      http: {verb: 'get', path: '/' + pathName + '/:fk'},\n      accepts: [\n        {\n          arg: 'fk', type: 'any',\n          description: format('Foreign key for %s', relationName),\n          required: true,\n          http: {source: 'path'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Find a related item by id for %s.', relationName),\n      accessType: 'READ',\n      returns: {arg: 'result', type: toModelName, root: true},\n      rest: {after: convertNullToNotFoundError.bind(null, toModelName)},\n    }, findByIdFunc);\n\n    var destroyByIdFunc = this.prototype['__destroyById__' + relationName];\n    define('__destroyById__' + relationName, {\n      isStatic: false,\n      http: {verb: 'delete', path: '/' + pathName + '/:fk'},\n      accepts: [\n        {\n          arg: 'fk', type: 'any',\n          description: format('Foreign key for %s', relationName),\n          required: true,\n          http: {source: 'path'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Delete a related item by id for %s.', relationName),\n      accessType: 'WRITE',\n      returns: [],\n    }, destroyByIdFunc);\n\n    var updateByIdFunc = this.prototype['__updateById__' + relationName];\n    define('__updateById__' + relationName, {\n      isStatic: false,\n      http: {verb: 'put', path: '/' + pathName + '/:fk'},\n      accepts: [\n        {arg: 'fk', type: 'any',\n          description: format('Foreign key for %s', relationName),\n          required: true,\n          http: {source: 'path'}},\n        {arg: 'data', type: 'object', model: toModelName, http: {source: 'body'}},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Update a related item by id for %s.', relationName),\n      accessType: 'WRITE',\n      returns: {arg: 'result', type: toModelName, root: true},\n    }, updateByIdFunc);\n\n    if (relation.modelThrough || relation.type === 'referencesMany') {\n      var modelThrough = relation.modelThrough || relation.modelTo;\n\n      var accepts = [];\n      if (relation.type === 'hasMany' && relation.modelThrough) {\n        // Restrict: only hasManyThrough relation can have additional properties\n        accepts.push({\n          arg: 'data', type: 'object', model: modelThrough.modelName,\n          http: {source: 'body'},\n        });\n      }\n\n      var addFunc = this.prototype['__link__' + relationName];\n      define('__link__' + relationName, {\n        isStatic: false,\n        http: {verb: 'put', path: '/' + pathName + '/rel/:fk'},\n        accepts: [{arg: 'fk', type: 'any',\n          description: format('Foreign key for %s', relationName),\n          required: true,\n          http: {source: 'path'}},\n        ].concat(accepts).concat([\n          {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n        ]),\n        description: format('Add a related item by id for %s.', relationName),\n        accessType: 'WRITE',\n        returns: {arg: relationName, type: modelThrough.modelName, root: true},\n      }, addFunc);\n\n      var removeFunc = this.prototype['__unlink__' + relationName];\n      define('__unlink__' + relationName, {\n        isStatic: false,\n        http: {verb: 'delete', path: '/' + pathName + '/rel/:fk'},\n        accepts: [\n          {\n            arg: 'fk', type: 'any',\n            description: format('Foreign key for %s', relationName),\n            required: true,\n            http: {source: 'path'},\n          },\n          {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n        ],\n        description: format('Remove the %s relation to an item by id.', relationName),\n        accessType: 'WRITE',\n        returns: [],\n      }, removeFunc);\n\n      // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?\n      // true --> 200 and false --> 404?\n      var existsFunc = this.prototype['__exists__' + relationName];\n      define('__exists__' + relationName, {\n        isStatic: false,\n        http: {verb: 'head', path: '/' + pathName + '/rel/:fk'},\n        accepts: [\n          {\n            arg: 'fk', type: 'any',\n            description: format('Foreign key for %s', relationName),\n            required: true,\n            http: {source: 'path'},\n          },\n          {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n        ],\n        description: format('Check the existence of %s relation to an item by id.', relationName),\n        accessType: 'READ',\n        returns: {arg: 'exists', type: 'boolean', root: true},\n        rest: {\n          // After hook to map exists to 200/404 for HEAD\n          after: function(ctx, cb) {\n            if (ctx.result === false) {\n              var modelName = ctx.method.sharedClass.name;\n              var id = ctx.getArgByName('id');\n              var msg = g.f('Unknown \"%s\" {{id}} \"%s\".', modelName, id);\n              var error = new Error(msg);\n              error.statusCode = error.status = 404;\n              error.code = 'MODEL_NOT_FOUND';\n              cb(error);\n            } else {\n              cb();\n            }\n          },\n        },\n      }, existsFunc);\n    }\n  };\n\n  Model.scopeRemoting = function(scopeName, scope, define) {\n    var pathName =\n      (scope.options && scope.options.http && scope.options.http.path) || scopeName;\n\n    var isStatic = scope.isStatic;\n    var toModelName = scope.modelTo.modelName;\n\n    // https://github.com/strongloop/loopback/issues/811\n    // Check if the scope is for a hasMany relation\n    var relation = this.relations[scopeName];\n    if (relation && relation.modelTo) {\n      // For a relation with through model, the toModelName should be the one\n      // from the target model\n      toModelName = relation.modelTo.modelName;\n    }\n\n    define('__get__' + scopeName, {\n      isStatic: isStatic,\n      http: {verb: 'get', path: '/' + pathName},\n      accepts: [\n        {arg: 'filter', type: 'object'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Queries %s of %s.', scopeName, this.modelName),\n      accessType: 'READ',\n      returns: {arg: scopeName, type: [toModelName], root: true},\n    });\n\n    define('__create__' + scopeName, {\n      isStatic: isStatic,\n      http: {verb: 'post', path: '/' + pathName},\n      accepts: [\n        {\n          arg: 'data',\n          type: 'object',\n          allowArray: true,\n          model: toModelName,\n          http: {source: 'body'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Creates a new instance in %s of this model.', scopeName),\n      accessType: 'WRITE',\n      returns: {arg: 'data', type: toModelName, root: true},\n    });\n\n    define('__delete__' + scopeName, {\n      isStatic: isStatic,\n      http: {verb: 'delete', path: '/' + pathName},\n      accepts: [\n        {\n          arg: 'where', type: 'object',\n          // The \"where\" argument is not exposed in the REST API\n          // but we need to provide a value so that we can pass \"options\"\n          // as the third argument.\n          http: function(ctx) { return undefined; },\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Deletes all %s of this model.', scopeName),\n      accessType: 'WRITE',\n    });\n\n    define('__count__' + scopeName, {\n      isStatic: isStatic,\n      http: {verb: 'get', path: '/' + pathName + '/count'},\n      accepts: [\n        {\n          arg: 'where', type: 'object',\n          description: 'Criteria to match model instances',\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      description: format('Counts %s of %s.', scopeName, this.modelName),\n      accessType: 'READ',\n      returns: {arg: 'count',  type: 'number'},\n    });\n  };\n\n  /**\n  * Enabled deeply-nested queries of related models via REST API.\n  *\n  * @param {String} relationName Name of the nested relation.\n  * @options {Object} [options] It is optional. See below.\n  * @param {String} pathName The HTTP path (relative to the model) at which your remote method is exposed.\n  * @param {String} filterMethod The filter name.\n  * @param {String} paramName The argument name that the remote method accepts.\n  * @param {String} getterName The getter name.\n  * @param {Boolean} hooks Whether to inherit before/after hooks.\n  * @callback {Function} filterCallback The Optional filter function.\n  * @param {Object} SharedMethod object. See [here](https://apidocs.strongloop.com/strong-remoting/#sharedmethod).\n  * @param {Object} RelationDefinition object which includes relation `type`, `ModelConstructor` of `modelFrom`, `modelTo`, `keyFrom`, `keyTo` and more relation definitions.\n   */\n\n  Model.nestRemoting = function(relationName, options, filterCallback) {\n    if (typeof options === 'function' && !filterCallback) {\n      filterCallback = options;\n      options = {};\n    }\n    options = options || {};\n\n    var regExp = /^__([^_]+)__([^_]+)$/;\n    var relation = this.relations[relationName];\n    if (relation && relation.modelTo && relation.modelTo.sharedClass) {\n      var self = this;\n      var sharedClass = this.sharedClass;\n      var sharedToClass = relation.modelTo.sharedClass;\n      var toModelName = relation.modelTo.modelName;\n\n      var pathName = options.pathName || relation.options.path || relationName;\n      var paramName = options.paramName || 'nk';\n\n      var http = [].concat(sharedToClass.http || [])[0];\n      var httpPath, acceptArgs;\n\n      if (relation.multiple) {\n        httpPath = pathName + '/:' + paramName;\n        acceptArgs = [\n          {\n            arg: paramName, type: 'any', http: {source: 'path'},\n            description: format('Foreign key for %s.',  relation.name),\n            required: true,\n          },\n        ];\n      } else {\n        httpPath = pathName;\n        acceptArgs = [];\n      }\n\n      if (httpPath[0] !== '/') {\n        httpPath = '/' + httpPath;\n      }\n\n      // A method should return the method name to use, if it is to be\n      // included as a nested method - a falsy return value will skip.\n      var filter = filterCallback || options.filterMethod || function(method, relation) {\n        var matches = method.name.match(regExp);\n        if (matches) {\n          return '__' + matches[1] + '__' + relation.name + '__' + matches[2];\n        }\n      };\n\n      sharedToClass.methods().forEach(function(method) {\n        var methodName;\n        if (!method.isStatic && (methodName = filter(method, relation))) {\n          var prefix = relation.multiple ? '__findById__' : '__get__';\n          var getterName = options.getterName || (prefix + relationName);\n\n          var getterFn = relation.modelFrom.prototype[getterName];\n          if (typeof getterFn !== 'function') {\n            throw new Error(g.f('Invalid remote method: `%s`', getterName));\n          }\n\n          var nestedFn = relation.modelTo.prototype[method.name];\n          if (typeof nestedFn !== 'function') {\n            throw new Error(g.f('Invalid remote method: `%s`', method.name));\n          }\n\n          var opts = {};\n\n          opts.accepts = acceptArgs.concat(method.accepts || []);\n          opts.returns = [].concat(method.returns || []);\n          opts.description = method.description;\n          opts.accessType = method.accessType;\n          opts.rest = extend({}, method.rest || {});\n          opts.rest.delegateTo = method;\n\n          opts.http = [];\n          var routes = [].concat(method.http || []);\n          routes.forEach(function(route) {\n            if (route.path) {\n              var copy = extend({}, route);\n              copy.path = httpPath + route.path;\n              opts.http.push(copy);\n            }\n          });\n\n          if (relation.multiple) {\n            sharedClass.defineMethod(methodName, opts, function(fkId) {\n              var args = Array.prototype.slice.call(arguments, 1);\n              var last = args[args.length - 1];\n              var cb = typeof last === 'function' ? last : null;\n              this[getterName](fkId, function(err, inst) {\n                if (err && cb) return cb(err);\n                if (inst instanceof relation.modelTo) {\n                  try {\n                    nestedFn.apply(inst, args);\n                  } catch (err) {\n                    if (cb) return cb(err);\n                  }\n                } else if (cb) {\n                  cb(err, null);\n                }\n              });\n            }, method.isStatic);\n          } else {\n            sharedClass.defineMethod(methodName, opts, function() {\n              var args = Array.prototype.slice.call(arguments);\n              var last = args[args.length - 1];\n              var cb = typeof last === 'function' ? last : null;\n              this[getterName](function(err, inst) {\n                if (err && cb) return cb(err);\n                if (inst instanceof relation.modelTo) {\n                  try {\n                    nestedFn.apply(inst, args);\n                  } catch (err) {\n                    if (cb) return cb(err);\n                  }\n                } else if (cb) {\n                  cb(err, null);\n                }\n              });\n            }, method.isStatic);\n          }\n        }\n      });\n\n      this.emit('remoteMethodAdded', this.sharedClass);\n\n      if (options.hooks === false) return; // don't inherit before/after hooks\n\n      self.once('mounted', function(app, sc, remotes) {\n        var listenerTree = extend({}, remotes.listenerTree || {});\n        listenerTree.before = listenerTree.before || {};\n        listenerTree.after = listenerTree.after || {};\n\n        var beforeListeners = listenerTree.before[toModelName] || {};\n        var afterListeners = listenerTree.after[toModelName] || {};\n\n        sharedClass.methods().forEach(function(method) {\n          var delegateTo = method.rest && method.rest.delegateTo;\n          if (delegateTo && delegateTo.ctor == relation.modelTo) {\n            var before = method.isStatic ? beforeListeners : beforeListeners['prototype'];\n            var after = method.isStatic ? afterListeners : afterListeners['prototype'];\n            var m = method.isStatic ? method.name : 'prototype.' + method.name;\n            if (before && before[delegateTo.name]) {\n              self.beforeRemote(m, function(ctx, result, next) {\n                before[delegateTo.name]._listeners.call(null, ctx, next);\n              });\n            }\n            if (after && after[delegateTo.name]) {\n              self.afterRemote(m, function(ctx, result, next) {\n                after[delegateTo.name]._listeners.call(null, ctx, next);\n              });\n            }\n          }\n        });\n      });\n    } else {\n      var msg = g.f('Relation `%s` does not exist for model `%s`', relationName, this.modelName);\n      throw new Error(msg);\n    }\n  };\n\n  Model.ValidationError = require('loopback-datasource-juggler').ValidationError;\n\n  /**\n   * Create \"options\" value to use when invoking model methods\n   * via strong-remoting (e.g. REST).\n   *\n   * Example\n   *\n   * ```js\n   * MyModel.myMethod = function(options, cb) {\n   *   // by default, options contains only one property \"accessToken\"\n   *   var accessToken = options && options.accessToken;\n   *   var userId = accessToken && accessToken.userId;\n   *   var message = 'Hello ' + (userId ? 'user #' + userId : 'anonymous');\n   *   cb(null, message);\n   * });\n   *\n   * MyModel.remoteMethod('myMethod', {\n   *   accepts: {\n   *     arg: 'options',\n   *     type: 'object',\n   *     // \"optionsFromRequest\" is a loopback-specific HTTP mapping that\n   *     // calls Model's createOptionsFromRemotingContext\n   *     // to build the argument value\n   *     http: 'optionsFromRequest'\n   *    },\n   *    returns: {\n   *      arg: 'message',\n   *      type: 'string'\n   *    }\n   * });\n   * ```\n   *\n   * @param {Object} ctx A strong-remoting Context instance\n   * @returns {Object} The value to pass to \"options\" argument.\n   */\n  Model.createOptionsFromRemotingContext = function(ctx) {\n    return {\n      accessToken: ctx.req.accessToken,\n    };\n  };\n\n  // setup the initial model\n  Model.setup();\n\n  return Model;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/persisted-model.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module Dependencies.\n */\n'use strict';\nvar g = require('./globalize');\nvar runtime = require('./runtime');\nvar assert = require('assert');\nvar async = require('async');\nvar deprecated = require('depd')('loopback');\nvar debug = require('debug')('loopback:persisted-model');\nvar PassThrough = require('stream').PassThrough;\nvar utils = require('./utils');\nvar REPLICATION_CHUNK_SIZE = -1;\n\nmodule.exports = function(registry) {\n  var Model = registry.getModel('Model');\n\n  /**\n   * Extends Model with basic query and CRUD support.\n   *\n   * **Change Event**\n   *\n   * Listen for model changes using the `change` event.\n   *\n   * ```js\n   * MyPersistedModel.on('changed', function(obj) {\n   *    console.log(obj) // => the changed model\n   * });\n   * ```\n   *\n   * @class PersistedModel\n   */\n\n  var PersistedModel = Model.extend('PersistedModel');\n\n  /*!\n   * Setup the `PersistedModel` constructor.\n   */\n\n  PersistedModel.setup = function setupPersistedModel() {\n    // call Model.setup first\n    Model.setup.call(this);\n\n    var PersistedModel = this;\n\n    // enable change tracking (usually for replication)\n    if (this.settings.trackChanges) {\n      PersistedModel._defineChangeModel();\n      PersistedModel.once('dataSourceAttached', function() {\n        PersistedModel.enableChangeTracking();\n      });\n    } else if (this.settings.enableRemoteReplication) {\n      PersistedModel._defineChangeModel();\n    }\n\n    PersistedModel.setupRemoting();\n  };\n\n  /*!\n   * Throw an error telling the user that the method is not available and why.\n   */\n\n  function throwNotAttached(modelName, methodName) {\n    throw new Error(\n      g.f('Cannot call %s.%s().' +\n      ' The %s method has not been setup.' +\n      ' The {{PersistedModel}} has not been correctly attached to a {{DataSource}}!',\n      modelName, methodName, methodName)\n    );\n  }\n\n  /*!\n   * Convert null callbacks to 404 error objects.\n   * @param  {HttpContext} ctx\n   * @param  {Function} cb\n   */\n\n  function convertNullToNotFoundError(ctx, cb) {\n    if (ctx.result !== null) return cb();\n\n    var modelName = ctx.method.sharedClass.name;\n    var id = ctx.getArgByName('id');\n    var msg = g.f('Unknown \"%s\" {{id}} \"%s\".', modelName, id);\n    var error = new Error(msg);\n    error.statusCode = error.status = 404;\n    error.code = 'MODEL_NOT_FOUND';\n    cb(error);\n  }\n\n  /**\n   * Create new instance of Model, and save to database.\n   *\n   * @param {Object|Object[]} [data] Optional data argument.  Can be either a single model instance or an array of instances.\n   *\n   * @callback {Function} callback Callback function called with `cb(err, obj)` signature.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} models Model instances or null.\n   */\n\n  PersistedModel.create = function(data, callback) {\n    throwNotAttached(this.modelName, 'create');\n  };\n\n  /**\n   * Update or insert a model instance\n   * @param {Object} data The model instance data to insert.\n   * @callback {Function} callback Callback function called with `cb(err, obj)` signature.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} model Updated model instance.\n   */\n\n  PersistedModel.upsert = PersistedModel.updateOrCreate = PersistedModel.patchOrCreate =\n  function upsert(data, callback) {\n    throwNotAttached(this.modelName, 'upsert');\n  };\n\n  /**\n   * Update or insert a model instance based on the search criteria.\n   * If there is a single instance retrieved, update the retrieved model.\n   * Creates a new model if no model instances were found.\n   * Returns an error if multiple instances are found.\n   * @param {Object} [where]  `where` filter, like\n   * ```\n   * { key: val, key2: {gt: 'val2'}, ...}\n   * ```\n   * <br/>see\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-other-methods).\n   * @param {Object} data The model instance data to insert.\n   * @callback {Function} callback Callback function called with `cb(err, obj)` signature.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} model Updated model instance.\n   */\n\n  PersistedModel.upsertWithWhere =\n  PersistedModel.patchOrCreateWithWhere = function upsertWithWhere(where, data, callback) {\n    throwNotAttached(this.modelName, 'upsertWithWhere');\n  };\n\n  /**\n   * Replace or insert a model instance; replace existing record if one is found,\n   * such that parameter `data.id` matches `id` of model instance; otherwise,\n   * insert a new record.\n   * @param {Object} data The model instance data.\n   * @options {Object} [options] Options for replaceOrCreate\n   * @property {Boolean} validate Perform validation before saving.  Default is true.\n   * @callback {Function} callback Callback function called with `cb(err, obj)` signature.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} model Replaced model instance.\n   */\n\n  PersistedModel.replaceOrCreate = function replaceOrCreate(data, callback) {\n    throwNotAttached(this.modelName, 'replaceOrCreate');\n  };\n\n  /**\n   * Finds one record matching the optional filter object. If not found, creates\n   * the object using the data provided as second argument. In this sense it is\n   * the same as `find`, but limited to one object. Returns an object, not\n   * collection. If you don't provide the filter object argument, it tries to\n   * locate an existing object that matches the `data` argument.\n   *\n   * @options {Object} [filter] Optional Filter object; see below.\n   * @property {String|Object|Array} fields Identify fields to include in return result.\n   * <br/>See [Fields filter](http://loopback.io/doc/en/lb2/Fields-filter.html).\n   * @property {String|Object|Array} include  See PersistedModel.include documentation.\n   * <br/>See [Include filter](http://loopback.io/doc/en/lb2/Include-filter.html).\n   * @property {Number} limit Maximum number of instances to return.\n   * <br/>See [Limit filter](http://loopback.io/doc/en/lb2/Limit-filter.html).\n   * @property {String} order Sort order: either \"ASC\" for ascending or \"DESC\" for descending.\n   * <br/>See [Order filter](http://loopback.io/doc/en/lb2/Order-filter.html).\n   * @property {Number} skip Number of results to skip.\n   * <br/>See [Skip filter](http://loopback.io/doc/en/lb2/Skip-filter.html).\n   * @property {Object} where Where clause, like\n   * ```\n   * {where: {key: val, key2: {gt: val2}, ...}}\n   * ```\n   * <br/>See\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-queries).\n   * @param {Object} data Data to insert if object matching the `where` filter is not found.\n   * @callback {Function} callback Callback function called with `cb(err, instance, created)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Model instance matching the `where` filter, if found.\n   * @param {Boolean} created True if the instance does not exist and gets created.\n   */\n\n  PersistedModel.findOrCreate = function findOrCreate(query, data, callback) {\n    throwNotAttached(this.modelName, 'findOrCreate');\n  };\n\n  PersistedModel.findOrCreate._delegate = true;\n\n  /**\n   * Check whether a model instance exists in database.\n   *\n   * @param {id} id Identifier of object (primary key value).\n   *\n   * @callback {Function} callback Callback function called with `(err, exists)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Boolean} exists True if the instance with the specified ID exists; false otherwise.\n   */\n\n  PersistedModel.exists = function exists(id, cb) {\n    throwNotAttached(this.modelName, 'exists');\n  };\n\n  /**\n   * Find object by ID with an optional filter for include/fields.\n   *\n   * @param {*} id Primary key value\n   * @options {Object} [filter] Optional Filter JSON object; see below.\n   * @property {String|Object|Array} fields Identify fields to include in return result.\n   * <br/>See [Fields filter](http://loopback.io/doc/en/lb2/Fields-filter.html).\n   * @property {String|Object|Array} include  See PersistedModel.include documentation.\n   * <br/>See [Include filter](http://loopback.io/doc/en/lb2/Include-filter.html).\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Model instance matching the specified ID or null if no instance matches.\n   */\n\n  PersistedModel.findById = function findById(id, filter, cb) {\n    throwNotAttached(this.modelName, 'findById');\n  };\n\n  /**\n   * Find all model instances that match `filter` specification.\n   * See [Querying models](http://loopback.io/doc/en/lb2/Querying-data.html).\n   *\n   * @options {Object} [filter] Optional Filter JSON object; see below.\n   * @property {String|Object|Array} fields Identify fields to include in return result.\n   * <br/>See [Fields filter](http://loopback.io/doc/en/lb2/Fields-filter.html).\n   * @property {String|Object|Array} include  See PersistedModel.include documentation.\n   * <br/>See [Include filter](http://loopback.io/doc/en/lb2/Include-filter.html).\n   * @property {Number} limit Maximum number of instances to return.\n   * <br/>See [Limit filter](http://loopback.io/doc/en/lb2/Limit-filter.html).\n   * @property {String} order Sort order: either \"ASC\" for ascending or \"DESC\" for descending.\n   * <br/>See [Order filter](http://loopback.io/doc/en/lb2/Order-filter.html).\n   * @property {Number} skip Number of results to skip.\n   * <br/>See [Skip filter](http://loopback.io/doc/en/lb2/Skip-filter.html).\n   * @property {Object} where Where clause, like\n   * ```\n   * { where: { key: val, key2: {gt: 'val2'}, ...} }\n   * ```\n   * <br/>See\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-queries).\n   *\n   * @callback {Function} callback Callback function called with `(err, returned-instances)` arguments.    Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Array} models Model instances matching the filter, or null if none found.\n   */\n\n  PersistedModel.find = function find(filter, cb) {\n    throwNotAttached(this.modelName, 'find');\n  };\n\n  /**\n   * Find one model instance that matches `filter` specification.\n   * Same as `find`, but limited to one result;\n   * Returns object, not collection.\n   *\n   * @options {Object} [filter] Optional Filter JSON object; see below.\n   * @property {String|Object|Array} fields Identify fields to include in return result.\n   * <br/>See [Fields filter](http://loopback.io/doc/en/lb2/Fields-filter.html).\n   * @property {String|Object|Array} include  See PersistedModel.include documentation.\n   * <br/>See [Include filter](http://loopback.io/doc/en/lb2/Include-filter.html).\n   * @property {String} order Sort order: either \"ASC\" for ascending or \"DESC\" for descending.\n   * <br/>See [Order filter](http://loopback.io/doc/en/lb2/Order-filter.html).\n   * @property {Number} skip Number of results to skip.\n   * <br/>See [Skip filter](http://loopback.io/doc/en/lb2/Skip-filter.html).\n   * @property {Object} where Where clause, like\n   * ```\n   * {where: { key: val, key2: {gt: 'val2'}, ...} }\n   * ```\n   * <br/>See\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-queries).\n   *\n   * @callback {Function} callback Callback function called with `(err, returned-instance)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Array} model First model instance that matches the filter or null if none found.\n   */\n\n  PersistedModel.findOne = function findOne(filter, cb) {\n    throwNotAttached(this.modelName, 'findOne');\n  };\n\n  /**\n   * Destroy all model instances that match the optional `where` specification.\n   *\n   * @param {Object} [where] Optional where filter, like:\n   * ```\n   * {key: val, key2: {gt: 'val2'}, ...}\n   * ```\n   * <br/>See\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-other-methods).\n   *\n   * @callback {Function} callback Optional callback function called with `(err, info)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} info Additional information about the command outcome.\n   * @param {Number} info.count Number of instances (rows, documents) destroyed.\n   */\n\n  PersistedModel.destroyAll = function destroyAll(where, cb) {\n    throwNotAttached(this.modelName, 'destroyAll');\n  };\n\n  /**\n   * Alias for `destroyAll`\n   */\n  PersistedModel.remove = PersistedModel.destroyAll;\n\n  /**\n   * Alias for `destroyAll`\n   */\n  PersistedModel.deleteAll = PersistedModel.destroyAll;\n\n  /**\n   * Update multiple instances that match the where clause.\n   *\n   * Example:\n   *\n   *```js\n   * Employee.updateAll({managerId: 'x001'}, {managerId: 'x002'}, function(err, info) {\n   *     ...\n   * });\n   * ```\n   *\n   * @param {Object} [where] Optional `where` filter, like\n   * ```\n   * { key: val, key2: {gt: 'val2'}, ...}\n   * ```\n   * <br/>see\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-other-methods).\n   * @param {Object} data Object containing data to replace matching instances, if any.\n   *\n   * @callback {Function} callback Callback function called with `(err, info)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} info Additional information about the command outcome.\n   * @param {Number} info.count Number of instances (rows, documents) updated.\n   *\n   */\n  PersistedModel.updateAll = function updateAll(where, data, cb) {\n    throwNotAttached(this.modelName, 'updateAll');\n  };\n\n  /**\n   * Alias for updateAll.\n   */\n  PersistedModel.update = PersistedModel.updateAll;\n\n  /**\n   * Destroy model instance with the specified ID.\n   * @param {*} id The ID value of model instance to delete.\n   * @callback {Function} callback Callback function called with `(err)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   */\n  PersistedModel.destroyById = function deleteById(id, cb) {\n    throwNotAttached(this.modelName, 'deleteById');\n  };\n\n  /**\n   * Alias for destroyById.\n   */\n  PersistedModel.removeById = PersistedModel.destroyById;\n\n  /**\n   * Alias for destroyById.\n   */\n  PersistedModel.deleteById = PersistedModel.destroyById;\n\n  /**\n   * Return the number of records that match the optional \"where\" filter.\n   * @param {Object} [where] Optional where filter, like\n   * ```\n   * { key: val, key2: {gt: 'val2'}, ...}\n   * ```\n   * <br/>See\n   * [Where filter](http://loopback.io/doc/en/lb2/Where-filter.html#where-clause-for-other-methods).\n   * @callback {Function} callback Callback function called with `(err, count)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Number} count Number of instances.\n   */\n\n  PersistedModel.count = function(where, cb) {\n    throwNotAttached(this.modelName, 'count');\n  };\n\n  /**\n   * Save model instance. If the instance doesn't have an ID, then calls [create](#persistedmodelcreatedata-cb) instead.\n   * Triggers: validate, save, update, or create.\n   * @options {Object} [options] See below.\n   * @property {Boolean} validate Perform validation before saving.  Default is true.\n   * @property {Boolean} throws If true, throw a validation error; WARNING: This can crash Node.\n   * If false, report the error via callback.  Default is false.\n   * @callback {Function} callback Optional callback function called with `(err, obj)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Model instance saved or created.\n   */\n\n  PersistedModel.prototype.save = function(options, callback) {\n    var Model = this.constructor;\n\n    if (typeof options == 'function') {\n      callback = options;\n      options = {};\n    }\n\n    callback = callback || function() {\n    };\n    options = options || {};\n\n    if (!('validate' in options)) {\n      options.validate = true;\n    }\n    if (!('throws' in options)) {\n      options.throws = false;\n    }\n\n    var inst = this;\n    var data = inst.toObject(true);\n    var id = this.getId();\n\n    if (!id) {\n      return Model.create(this, callback);\n    }\n\n    // validate first\n    if (!options.validate) {\n      return save();\n    }\n\n    inst.isValid(function(valid) {\n      if (valid) {\n        save();\n      } else {\n        var err = new Model.ValidationError(inst);\n        // throws option is dangerous for async usage\n        if (options.throws) {\n          throw err;\n        }\n        callback(err, inst);\n      }\n    });\n\n    // then save\n    function save() {\n      inst.trigger('save', function(saveDone) {\n        inst.trigger('update', function(updateDone) {\n          Model.upsert(inst, function(err) {\n            inst._initProperties(data);\n            updateDone.call(inst, function() {\n              saveDone.call(inst, function() {\n                callback(err, inst);\n              });\n            });\n          });\n        }, data);\n      }, data);\n    }\n  };\n\n  /**\n   * Determine if the data model is new.\n   * @returns {Boolean} Returns true if the data model is new; false otherwise.\n   */\n\n  PersistedModel.prototype.isNewRecord = function() {\n    throwNotAttached(this.constructor.modelName, 'isNewRecord');\n  };\n\n  /**\n   * Deletes the model from persistence.\n   * Triggers `destroy` hook (async) before and after destroying object.\n   * @param {Function} callback Callback function.\n   */\n\n  PersistedModel.prototype.destroy = function(cb) {\n    throwNotAttached(this.constructor.modelName, 'destroy');\n  };\n\n  /**\n   * Alias for destroy.\n   * @header PersistedModel.remove\n   */\n  PersistedModel.prototype.remove = PersistedModel.prototype.destroy;\n\n  /**\n   * Alias for destroy.\n   * @header PersistedModel.delete\n   */\n  PersistedModel.prototype.delete = PersistedModel.prototype.destroy;\n\n  PersistedModel.prototype.destroy._delegate = true;\n\n  /**\n   * Update a single attribute.\n   * Equivalent to `updateAttributes({name: 'value'}, cb)`\n   *\n   * @param {String} name Name of property.\n   * @param {Mixed} value Value of property.\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Updated instance.\n   */\n\n  PersistedModel.prototype.updateAttribute = function updateAttribute(name, value, callback) {\n    throwNotAttached(this.constructor.modelName, 'updateAttribute');\n  };\n\n  /**\n   * Update set of attributes.  Performs validation before updating.\n   *\n   * Triggers: `validation`, `save` and `update` hooks\n   * @param {Object} data Data to update.\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Updated instance.\n   */\n\n  PersistedModel.prototype.updateAttributes = PersistedModel.prototype.patchAttributes =\n  function updateAttributes(data, cb) {\n    throwNotAttached(this.modelName, 'updateAttributes');\n  };\n\n  /**\n   * Replace attributes for a model instance and persist it into the datasource.\n   * Performs validation before replacing.\n   *\n   * @param {Object} data Data to replace.\n   * @options {Object} [options] Options for replace\n   * @property {Boolean} validate Perform validation before saving.  Default is true.\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Replaced instance.\n   */\n\n  PersistedModel.prototype.replaceAttributes = function replaceAttributes(data, cb) {\n    throwNotAttached(this.modelName, 'replaceAttributes');\n  };\n\n  /**\n   * Replace attributes for a model instance whose id is the first input\n   * argument and persist it into the datasource.\n   * Performs validation before replacing.\n   *\n   * @param {*} id The ID value of model instance to replace.\n   * @param {Object} data Data to replace.\n   * @options {Object} [options] Options for replace\n   * @property {Boolean} validate Perform validation before saving.  Default is true.\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Replaced instance.\n   */\n\n  PersistedModel.replaceById = function replaceById(id, data, cb) {\n    throwNotAttached(this.modelName, 'replaceById');\n  };\n\n  /**\n   * Reload object from persistence.  Requires `id` member of `object` to be able to call `find`.\n   * @callback {Function} callback Callback function called with `(err, instance)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} instance Model instance.\n   */\n\n  PersistedModel.prototype.reload = function reload(callback) {\n    throwNotAttached(this.constructor.modelName, 'reload');\n  };\n\n  /**\n   * Set the correct `id` property for the `PersistedModel`. Uses the `setId` method if the model is attached to\n   * connector that defines it.  Otherwise, uses the default lookup.\n   * Override this method to handle complex IDs.\n   *\n   * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.\n   */\n\n  PersistedModel.prototype.setId = function(val) {\n    var ds = this.getDataSource();\n    this[this.getIdName()] = val;\n  };\n\n  /**\n   * Get the `id` value for the `PersistedModel`.\n   *\n   * @returns {*} The `id` value\n   */\n\n  PersistedModel.prototype.getId = function() {\n    var data = this.toObject();\n    if (!data) return;\n    return data[this.getIdName()];\n  };\n\n  /**\n   * Get the `id` property name of the constructor.\n   *\n   * @returns {String} The `id` property name\n   */\n\n  PersistedModel.prototype.getIdName = function() {\n    return this.constructor.getIdName();\n  };\n\n  /**\n   * Get the `id` property name of the constructor.\n   *\n   * @returns {String} The `id` property name\n   */\n\n  PersistedModel.getIdName = function() {\n    var Model = this;\n    var ds = Model.getDataSource();\n\n    if (ds.idName) {\n      return ds.idName(Model.modelName);\n    } else {\n      return 'id';\n    }\n  };\n\n  PersistedModel.setupRemoting = function() {\n    var PersistedModel = this;\n    var typeName = PersistedModel.modelName;\n    var options = PersistedModel.settings;\n\n    // This is just for LB 3.x\n    options.replaceOnPUT = options.replaceOnPUT !== false;\n\n    function setRemoting(scope, name, options) {\n      var fn = scope[name];\n      fn._delegate = true;\n      options.isStatic = scope === PersistedModel;\n      PersistedModel.remoteMethod(name, options);\n    }\n\n    setRemoting(PersistedModel, 'create', {\n      description: 'Create a new instance of the model and persist it into the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: typeName, allowArray: true,\n          description: 'Model instance data',\n          http: {source: 'body'},\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: {verb: 'post', path: '/'},\n    });\n\n    var upsertOptions = {\n      aliases: ['upsert', 'updateOrCreate'],\n      description: 'Patch an existing model instance or insert a new one ' +\n        'into the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: typeName, http: {source: 'body'},\n          description: 'Model instance data',\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: [{verb: 'patch', path: '/'}],\n    };\n\n    if (!options.replaceOnPUT) {\n      upsertOptions.http.unshift({verb: 'put', path: '/'});\n    }\n    setRemoting(PersistedModel, 'patchOrCreate', upsertOptions);\n\n    var replaceOrCreateOptions = {\n      description: 'Replace an existing model instance or insert a new one into the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: typeName,\n          http: {source: 'body'},\n          description: 'Model instance data',\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: [{verb: 'post', path: '/replaceOrCreate'}],\n    };\n\n    if (options.replaceOnPUT) {\n      replaceOrCreateOptions.http.push({verb: 'put', path: '/'});\n    }\n\n    setRemoting(PersistedModel, 'replaceOrCreate', replaceOrCreateOptions);\n\n    setRemoting(PersistedModel, 'upsertWithWhere', {\n      aliases: ['patchOrCreateWithWhere'],\n      description: 'Update an existing model instance or insert a new one into ' +\n        'the data source based on the where criteria.',\n      accessType: 'WRITE',\n      accepts: [\n        {arg: 'where', type: 'object', http: {source: 'query'},\n          description: 'Criteria to match model instances'},\n        {arg: 'data', type: 'object', model: typeName, http: {source: 'body'},\n          description: 'An object of model property name/value pairs'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: {verb: 'post', path: '/upsertWithWhere'},\n    });\n\n    setRemoting(PersistedModel, 'exists', {\n      description: 'Check whether a model instance exists in the data source.',\n      accessType: 'READ',\n      accepts: [\n        {arg: 'id', type: 'any', description: 'Model id', required: true},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'exists', type: 'boolean'},\n      http: [\n        {verb: 'get', path: '/:id/exists'},\n        {verb: 'head', path: '/:id'},\n      ],\n      rest: {\n        // After hook to map exists to 200/404 for HEAD\n        after: function(ctx, cb) {\n          if (ctx.req.method === 'GET') {\n            // For GET, return {exists: true|false} as is\n            return cb();\n          }\n          if (!ctx.result.exists) {\n            var modelName = ctx.method.sharedClass.name;\n            var id = ctx.getArgByName('id');\n            var msg = 'Unknown \"' + modelName + '\" id \"' + id + '\".';\n            var error = new Error(msg);\n            error.statusCode = error.status = 404;\n            error.code = 'MODEL_NOT_FOUND';\n            cb(error);\n          } else {\n            cb();\n          }\n        },\n      },\n    });\n\n    setRemoting(PersistedModel, 'findById', {\n      description: 'Find a model instance by {{id}} from the data source.',\n      accessType: 'READ',\n      accepts: [\n        {arg: 'id', type: 'any', description: 'Model id', required: true,\n          http: {source: 'path'}},\n        {arg: 'filter', type: 'object',\n          description:\n          'Filter defining fields and include - must be a JSON-encoded string (' +\n          '{\"something\":\"value\"})'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: {verb: 'get', path: '/:id'},\n      rest: {after: convertNullToNotFoundError},\n    });\n\n    var replaceByIdOptions = {\n      description: 'Replace attributes for a model instance and persist it into the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {arg: 'id', type: 'any', description: 'Model id', required: true,\n          http: {source: 'path'}},\n        {arg: 'data', type: 'object', model: typeName, http: {source: 'body'}, description:\n          'Model instance data'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: [{verb: 'post', path: '/:id/replace'}],\n    };\n\n    if (options.replaceOnPUT) {\n      replaceByIdOptions.http.push({verb: 'put', path: '/:id'});\n    }\n\n    setRemoting(PersistedModel, 'replaceById', replaceByIdOptions);\n\n    setRemoting(PersistedModel, 'find', {\n      description: 'Find all instances of the model matched by filter from the data source.',\n      accessType: 'READ',\n      accepts: [\n        {arg: 'filter', type: 'object', description:\n        'Filter defining fields, where, include, order, offset, and limit - must be a ' +\n        'JSON-encoded string ({\"something\":\"value\"})'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: [typeName], root: true},\n      http: {verb: 'get', path: '/'},\n    });\n\n    setRemoting(PersistedModel, 'findOne', {\n      description: 'Find first instance of the model matched by filter from the data source.',\n      accessType: 'READ',\n      accepts: [\n        {arg: 'filter', type: 'object', description:\n        'Filter defining fields, where, include, order, offset, and limit - must be a ' +\n        'JSON-encoded string ({\"something\":\"value\"})'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: {verb: 'get', path: '/findOne'},\n      rest: {after: convertNullToNotFoundError},\n    });\n\n    setRemoting(PersistedModel, 'destroyAll', {\n      description: 'Delete all matching records.',\n      accessType: 'WRITE',\n      accepts: [\n        {arg: 'where', type: 'object', description: 'filter.where object'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {\n        arg: 'count',\n        type: 'object',\n        description: 'The number of instances deleted',\n        root: true,\n      },\n      http: {verb: 'del', path: '/'},\n      shared: false,\n    });\n\n    setRemoting(PersistedModel, 'updateAll', {\n      aliases: ['update'],\n      description: 'Update instances of the model matched by {{where}} from the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {arg: 'where', type: 'object', http: {source: 'query'},\n          description: 'Criteria to match model instances'},\n        {arg: 'data', type: 'object', model: typeName, http: {source: 'body'},\n          description: 'An object of model property name/value pairs'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {\n        arg: 'info',\n        description: 'Information related to the outcome of the operation',\n        type: {\n          count: {\n            type: 'number',\n            description: 'The number of instances updated',\n          },\n        },\n        root: true,\n      },\n      http: {verb: 'post', path: '/update'},\n    });\n\n    setRemoting(PersistedModel, 'deleteById', {\n      aliases: ['destroyById', 'removeById'],\n      description: 'Delete a model instance by {{id}} from the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {arg: 'id', type: 'any', description: 'Model id', required: true,\n          http: {source: 'path'}},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      http: {verb: 'del', path: '/:id'},\n      returns: {arg: 'count', type: 'object', root: true},\n    });\n\n    setRemoting(PersistedModel, 'count', {\n      description: 'Count instances of the model matched by where from the data source.',\n      accessType: 'READ',\n      accepts: [\n        {arg: 'where', type: 'object', description: 'Criteria to match model instances'},\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'count', type: 'number'},\n      http: {verb: 'get', path: '/count'},\n    });\n\n    var updateAttributesOptions = {\n      aliases: ['updateAttributes'],\n      description: 'Patch attributes for a model instance and persist it into ' +\n        'the data source.',\n      accessType: 'WRITE',\n      accepts: [\n        {\n          arg: 'data', type: 'object', model: typeName,\n          http: {source: 'body'},\n          description: 'An object of model property name/value pairs',\n        },\n        {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n      ],\n      returns: {arg: 'data', type: typeName, root: true},\n      http: [{verb: 'patch', path: '/'}],\n    };\n\n    setRemoting(PersistedModel.prototype, 'patchAttributes', updateAttributesOptions);\n\n    if (!options.replaceOnPUT) {\n      updateAttributesOptions.http.unshift({verb: 'put', path: '/'});\n    }\n\n    if (options.trackChanges || options.enableRemoteReplication) {\n      setRemoting(PersistedModel, 'diff', {\n        description: 'Get a set of deltas and conflicts since the given checkpoint.',\n        accessType: 'READ',\n        accepts: [\n          {arg: 'since', type: 'number', description: 'Find deltas since this checkpoint'},\n          {arg: 'remoteChanges', type: 'array', description: 'an array of change objects',\n            http: {source: 'body'}},\n        ],\n        returns: {arg: 'result', type: 'object', root: true},\n        http: {verb: 'post', path: '/diff'},\n      });\n\n      setRemoting(PersistedModel, 'changes', {\n        description: 'Get the changes to a model since a given checkpoint.' +\n          'Provide a filter object to reduce the number of results returned.',\n        accessType: 'READ',\n        accepts: [\n          {arg: 'since', type: 'number', description:\n            'Only return changes since this checkpoint'},\n          {arg: 'filter', type: 'object', description:\n            'Only include changes that match this filter'},\n        ],\n        returns: {arg: 'changes', type: 'array', root: true},\n        http: {verb: 'get', path: '/changes'},\n      });\n\n      setRemoting(PersistedModel, 'checkpoint', {\n        description: 'Create a checkpoint.',\n        // The replication algorithm needs to create a source checkpoint,\n        // even though it is otherwise not making any source changes.\n        // We need to allow this method for users that don't have full\n        // WRITE permissions.\n        accessType: 'REPLICATE',\n        returns: {arg: 'checkpoint', type: 'object', root: true},\n        http: {verb: 'post', path: '/checkpoint'},\n      });\n\n      setRemoting(PersistedModel, 'currentCheckpoint', {\n        description: 'Get the current checkpoint.',\n        accessType: 'READ',\n        returns: {arg: 'checkpoint', type: 'object', root: true},\n        http: {verb: 'get', path: '/checkpoint'},\n      });\n\n      setRemoting(PersistedModel, 'createUpdates', {\n        description: 'Create an update list from a delta list.',\n        // This operation is read-only, it does not change any local data.\n        // It is called by the replication algorithm to compile a list\n        // of changes to apply on the target.\n        accessType: 'READ',\n        accepts: {arg: 'deltas', type: 'array', http: {source: 'body'}},\n        returns: {arg: 'updates', type: 'array', root: true},\n        http: {verb: 'post', path: '/create-updates'},\n      });\n\n      setRemoting(PersistedModel, 'bulkUpdate', {\n        description: 'Run multiple updates at once. Note: this is not atomic.',\n        accessType: 'WRITE',\n        accepts: {arg: 'updates', type: 'array'},\n        http: {verb: 'post', path: '/bulk-update'},\n      });\n\n      setRemoting(PersistedModel, 'findLastChange', {\n        description: 'Get the most recent change record for this instance.',\n        accessType: 'READ',\n        accepts: {\n          arg: 'id', type: 'any', required: true, http: {source: 'path'},\n          description: 'Model id',\n        },\n        returns: {arg: 'result', type: this.Change.modelName, root: true},\n        http: {verb: 'get', path: '/:id/changes/last'},\n      });\n\n      setRemoting(PersistedModel, 'updateLastChange', {\n        description:\n          'Update the properties of the most recent change record ' +\n          'kept for this instance.',\n        accessType: 'WRITE',\n        accepts: [\n          {\n            arg: 'id', type: 'any', required: true, http: {source: 'path'},\n            description: 'Model id',\n          },\n          {\n            arg: 'data', type: 'object', model: typeName, http: {source: 'body'},\n            description: 'An object of Change property name/value pairs',\n          },\n        ],\n        returns: {arg: 'result', type: this.Change.modelName, root: true},\n        http: {verb: 'put', path: '/:id/changes/last'},\n      });\n    }\n\n    setRemoting(PersistedModel, 'createChangeStream', {\n      description: 'Create a change stream.',\n      accessType: 'READ',\n      http: [\n        {verb: 'post', path: '/change-stream'},\n        {verb: 'get', path: '/change-stream'},\n      ],\n      accepts: {\n        arg: 'options',\n        type: 'object',\n      },\n      returns: {\n        arg: 'changes',\n        type: 'ReadableStream',\n        json: true,\n      },\n    });\n  };\n\n  /**\n   * Get a set of deltas and conflicts since the given checkpoint.\n   *\n   * See [Change.diff()](#change-diff) for details.\n   *\n   * @param  {Number}  since  Find deltas since this checkpoint.\n   * @param  {Array}  remoteChanges  An array of change objects.\n   * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.\n   */\n\n  PersistedModel.diff = function(since, remoteChanges, callback) {\n    var Change = this.getChangeModel();\n    Change.diff(this.modelName, since, remoteChanges, callback);\n  };\n\n  /**\n   * Get the changes to a model since the specified checkpoint. Provide a filter object\n   * to reduce the number of results returned.\n   * @param  {Number}   since    Return only changes since this checkpoint.\n   * @param  {Object}   filter   Include only changes that match this filter, the same as for [#persistedmodel-find](find()).\n   * @callback {Function} callback Callback function called with `(err, changes)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Array} changes An array of [Change](#change) objects.\n   */\n\n  PersistedModel.changes = function(since, filter, callback) {\n    if (typeof since === 'function') {\n      filter = {};\n      callback = since;\n      since = -1;\n    }\n    if (typeof filter === 'function') {\n      callback = filter;\n      since = -1;\n      filter = {};\n    }\n\n    var idName = this.dataSource.idName(this.modelName);\n    var Change = this.getChangeModel();\n    var model = this;\n    const changeFilter = this.createChangeFilter(since, filter);\n\n    filter = filter || {};\n    filter.fields = {};\n    filter.where = filter.where || {};\n    filter.fields[idName] = true;\n\n    // TODO(ritch) this whole thing could be optimized a bit more\n    Change.find(changeFilter, function(err, changes) {\n      if (err) return callback(err);\n      if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);\n      var ids = changes.map(function(change) {\n        return change.getModelId();\n      });\n      filter.where[idName] = {inq: ids};\n      model.find(filter, function(err, models) {\n        if (err) return callback(err);\n        var modelIds = models.map(function(m) {\n          return m[idName].toString();\n        });\n        callback(null, changes.filter(function(ch) {\n          if (ch.type() === Change.DELETE) return true;\n          return modelIds.indexOf(ch.modelId) > -1;\n        }));\n      });\n    });\n  };\n\n  /**\n   * Create a checkpoint.\n   *\n   * @param  {Function} callback\n   */\n\n  PersistedModel.checkpoint = function(cb) {\n    var Checkpoint = this.getChangeModel().getCheckpointModel();\n    Checkpoint.bumpLastSeq(cb);\n  };\n\n  /**\n   * Get the current checkpoint ID.\n   *\n   * @callback {Function} callback Callback function called with `(err, currentCheckpointId)` arguments.  Required.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Number} currentCheckpointId Current checkpoint ID.\n   */\n\n  PersistedModel.currentCheckpoint = function(cb) {\n    var Checkpoint = this.getChangeModel().getCheckpointModel();\n    Checkpoint.current(cb);\n  };\n\n  /**\n   * Replicate changes since the given checkpoint to the given target model.\n   *\n   * @param  {Number}   [since]  Since this checkpoint\n   * @param  {Model}    targetModel  Target this model class\n   * @param  {Object} [options] An optional options object to pass to underlying data-access calls.\n   * @param {Object} [options.filter] Replicate models that match this filter\n   * @callback {Function} [callback] Callback function called with `(err, conflicts)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {Conflict[]} conflicts A list of changes that could not be replicated due to conflicts.\n   * @param {Object} checkpoints The new checkpoints to use as the \"since\"\n   * argument for the next replication.\n   *\n   * @promise\n   */\n\n  PersistedModel.replicate = function(since, targetModel, options, callback) {\n    var lastArg = arguments[arguments.length - 1];\n\n    if (typeof lastArg === 'function' && arguments.length > 1) {\n      callback = lastArg;\n    }\n\n    if (typeof since === 'function' && since.modelName) {\n      targetModel = since;\n      since = -1;\n    }\n\n    if (typeof since !== 'object') {\n      since = {source: since, target: since};\n    }\n\n    if (typeof options === 'function') {\n      options = {};\n    }\n\n    options = options || {};\n\n    var sourceModel = this;\n    callback = callback || utils.createPromiseCallback();\n\n    debug('replicating %s since %s to %s since %s',\n      sourceModel.modelName,\n      since.source,\n      targetModel.modelName,\n      since.target);\n    if (options.filter) {\n      debug('\\twith filter %j', options.filter);\n    }\n\n    // In order to avoid a race condition between the replication and\n    // other clients modifying the data, we must create the new target\n    // checkpoint as the first step of the replication process.\n    // As a side-effect of that, the replicated changes are associated\n    // with the new target checkpoint. This is actually desired behaviour,\n    // because that way clients replicating *from* the target model\n    // since the new checkpoint will pick these changes up.\n    // However, it increases the likelihood of (false) conflicts being detected.\n    // In order to prevent that, we run the replication multiple times,\n    // until no changes were replicated, but at most MAX_ATTEMPTS times\n    // to prevent starvation. In most cases, the second run will find no changes\n    // to replicate and we are done.\n    var MAX_ATTEMPTS = 3;\n\n    run(1, since);\n    return callback.promise;\n\n    function run(attempt, since) {\n      debug('\\titeration #%s', attempt);\n      tryReplicate(sourceModel, targetModel, since, options, next);\n\n      function next(err, conflicts, cps, updates) {\n        var finished = err || conflicts.length ||\n          !updates || updates.length === 0 ||\n          attempt >= MAX_ATTEMPTS;\n\n        if (finished)\n          return callback(err, conflicts, cps);\n        run(attempt + 1, cps);\n      }\n    }\n  };\n\n  function tryReplicate(sourceModel, targetModel, since, options, callback) {\n    var Change = sourceModel.getChangeModel();\n    var TargetChange = targetModel.getChangeModel();\n    var changeTrackingEnabled = Change && TargetChange;\n    var replicationChunkSize = REPLICATION_CHUNK_SIZE;\n\n    if (sourceModel.settings && sourceModel.settings.replicationChunkSize) {\n      replicationChunkSize = sourceModel.settings.replicationChunkSize;\n    }\n\n    assert(\n      changeTrackingEnabled,\n      'You must enable change tracking before replicating'\n    );\n\n    var diff, updates, newSourceCp, newTargetCp;\n\n    var tasks = [\n      checkpoints,\n      getSourceChanges,\n      getDiffFromTarget,\n      createSourceUpdates,\n      bulkUpdate,\n    ];\n\n    async.waterfall(tasks, done);\n\n    function getSourceChanges(cb) {\n      utils.downloadInChunks(\n        options.filter,\n        replicationChunkSize,\n        function(filter, pagingCallback) {\n          sourceModel.changes(since.source, filter, pagingCallback);\n        },\n        debug.enabled ? log : cb);\n\n      function log(err, result) {\n        if (err) return cb(err);\n        debug('\\tusing source changes');\n        result.forEach(function(it) { debug('\\t\\t%j', it); });\n        cb(err, result);\n      }\n    }\n\n    function getDiffFromTarget(sourceChanges, cb) {\n      utils.uploadInChunks(\n        sourceChanges,\n        replicationChunkSize,\n        function(smallArray, chunkCallback) {\n          return targetModel.diff(since.target, smallArray, chunkCallback);\n        },\n        debug.enabled ? log : cb);\n\n      function log(err, result) {\n        if (err) return cb(err);\n        if (result.conflicts && result.conflicts.length) {\n          debug('\\tdiff conflicts');\n          result.conflicts.forEach(function(d) { debug('\\t\\t%j', d); });\n        }\n        if (result.deltas && result.deltas.length) {\n          debug('\\tdiff deltas');\n          result.deltas.forEach(function(it) { debug('\\t\\t%j', it); });\n        }\n        cb(err, result);\n      }\n    }\n\n    function createSourceUpdates(_diff, cb) {\n      diff = _diff;\n      diff.conflicts = diff.conflicts || [];\n\n      if (diff && diff.deltas && diff.deltas.length) {\n        debug('\\tbuilding a list of updates');\n        utils.uploadInChunks(\n          diff.deltas,\n          replicationChunkSize,\n          function(smallArray, chunkCallback) {\n            return sourceModel.createUpdates(smallArray, chunkCallback);\n          },\n          cb);\n      } else {\n        // nothing to replicate\n        done();\n      }\n    }\n\n    function bulkUpdate(_updates, cb) {\n      debug('\\tstarting bulk update');\n      updates = _updates;\n      utils.uploadInChunks(\n        updates,\n        replicationChunkSize,\n        function(smallArray, chunkCallback) {\n          return targetModel.bulkUpdate(smallArray, options, function(err) {\n            // bulk update is a special case where we want to process all chunks and aggregate all errors\n            chunkCallback(null, err);\n          });\n        },\n        function(notUsed, err) {\n          var conflicts = err && err.details && err.details.conflicts;\n          if (conflicts && err.statusCode == 409) {\n            diff.conflicts = conflicts;\n            // filter out updates that were not applied\n            updates = updates.filter(function(u) {\n              return conflicts\n                .filter(function(d) { return d.modelId === u.change.modelId; })\n                .length === 0;\n            });\n            return cb();\n          }\n          cb(err);\n        });\n    }\n\n    function checkpoints() {\n      var cb = arguments[arguments.length - 1];\n      sourceModel.checkpoint(function(err, source) {\n        if (err) return cb(err);\n        newSourceCp = source.seq;\n        targetModel.checkpoint(function(err, target) {\n          if (err) return cb(err);\n          newTargetCp = target.seq;\n          debug('\\tcreated checkpoints');\n          debug('\\t\\t%s for source model %s', newSourceCp, sourceModel.modelName);\n          debug('\\t\\t%s for target model %s', newTargetCp, targetModel.modelName);\n          cb();\n        });\n      });\n    }\n\n    function done(err) {\n      if (err) return callback(err);\n\n      debug('\\treplication finished');\n      debug('\\t\\t%s conflict(s) detected', diff.conflicts.length);\n      debug('\\t\\t%s change(s) applied', updates ? updates.length : 0);\n      debug('\\t\\tnew checkpoints: { source: %j, target: %j }',\n        newSourceCp, newTargetCp);\n\n      var conflicts = diff.conflicts.map(function(change) {\n        return new Change.Conflict(\n          change.modelId, sourceModel, targetModel\n        );\n      });\n\n      if (conflicts.length) {\n        sourceModel.emit('conflicts', conflicts);\n      }\n\n      if (callback) {\n        var newCheckpoints = {source: newSourceCp, target: newTargetCp};\n        callback(null, conflicts, newCheckpoints, updates);\n      }\n    }\n  }\n\n  /**\n   * Create an update list (for `Model.bulkUpdate()`) from a delta list\n   * (result of `Change.diff()`).\n   *\n   * @param  {Array}    deltas\n   * @param  {Function} callback\n   */\n\n  PersistedModel.createUpdates = function(deltas, cb) {\n    var Change = this.getChangeModel();\n    var updates = [];\n    var Model = this;\n    var tasks = [];\n\n    deltas.forEach(function(change) {\n      change = new Change(change);\n      var type = change.type();\n      var update = {type: type, change: change};\n      switch (type) {\n        case Change.CREATE:\n        case Change.UPDATE:\n          tasks.push(function(cb) {\n            Model.findById(change.modelId, function(err, inst) {\n              if (err) return cb(err);\n              if (!inst) {\n                return cb &&\n                  cb(new Error(g.f('Missing data for change: %s', change.modelId)));\n              }\n              if (inst.toObject) {\n                update.data = inst.toObject();\n              } else {\n                update.data = inst;\n              }\n              updates.push(update);\n              cb();\n            });\n          });\n          break;\n        case Change.DELETE:\n          updates.push(update);\n          break;\n      }\n    });\n\n    async.parallel(tasks, function(err) {\n      if (err) return cb(err);\n      cb(null, updates);\n    });\n  };\n\n  /**\n   * Apply an update list.\n   *\n   * **Note: this is not atomic**\n   *\n   * @param  {Array} updates An updates list, usually from [createUpdates()](#persistedmodel-createupdates).\n   * @param  {Object} [options] An optional options object to pass to underlying data-access calls.\n   * @param  {Function} callback Callback function.\n   */\n\n  PersistedModel.bulkUpdate = function(updates, options, callback) {\n    var tasks = [];\n    var Model = this;\n    var Change = this.getChangeModel();\n    var conflicts = [];\n\n    var lastArg = arguments[arguments.length - 1];\n\n    if (typeof lastArg === 'function' && arguments.length > 1) {\n      callback = lastArg;\n    }\n\n    if (typeof options === 'function') {\n      options = {};\n    }\n\n    options = options || {};\n\n    buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {\n      if (err) return callback(err);\n\n      updates.forEach(function(update) {\n        var id = update.change.modelId;\n        var current = currentMap[id];\n        switch (update.type) {\n          case Change.UPDATE:\n            tasks.push(function(cb) {\n              applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);\n            });\n            break;\n\n          case Change.CREATE:\n            tasks.push(function(cb) {\n              applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);\n            });\n            break;\n          case Change.DELETE:\n            tasks.push(function(cb) {\n              applyDelete(Model, id, current, update.change, conflicts, options, cb);\n            });\n            break;\n        }\n      });\n\n      async.parallel(tasks, function(err) {\n        if (err) return callback(err);\n        if (conflicts.length) {\n          err = new Error(g.f('Conflict'));\n          err.statusCode = 409;\n          err.details = {conflicts: conflicts};\n          return callback(err);\n        }\n        callback();\n      });\n    });\n  };\n\n  function buildLookupOfAffectedModelData(Model, updates, callback) {\n    var idName = Model.dataSource.idName(Model.modelName);\n    var affectedIds = updates.map(function(u) { return u.change.modelId; });\n    var whereAffected = {};\n    whereAffected[idName] = {inq: affectedIds};\n    Model.find({where: whereAffected}, function(err, affectedList) {\n      if (err) return callback(err);\n      var dataLookup = {};\n      affectedList.forEach(function(it) {\n        dataLookup[it[idName]] = it;\n      });\n      callback(null, dataLookup);\n    });\n  }\n\n  function applyUpdate(Model, id, current, data, change, conflicts, options, cb) {\n    var Change = Model.getChangeModel();\n    var rev = current ?  Change.revisionForInst(current) : null;\n\n    if (rev !== change.prev) {\n      debug('Detected non-rectified change of %s %j',\n        Model.modelName, id);\n      debug('\\tExpected revision: %s', change.rev);\n      debug('\\tActual revision:   %s', rev);\n      conflicts.push(change);\n      return Change.rectifyModelChanges(Model.modelName, [id], cb);\n    }\n\n    // TODO(bajtos) modify `data` so that it instructs\n    // the connector to remove any properties included in \"inst\"\n    // but not included in `data`\n    // See https://github.com/strongloop/loopback/issues/1215\n\n    Model.updateAll(current.toObject(), data, options, function(err, result) {\n      if (err) return cb(err);\n\n      var count = result && result.count;\n      switch (count) {\n        case 1:\n          // The happy path, exactly one record was updated\n          return cb();\n\n        case 0:\n          debug('UpdateAll detected non-rectified change of %s %j',\n            Model.modelName, id);\n          conflicts.push(change);\n          // NOTE(bajtos) updateAll triggers change rectification\n          // for all model instances, even when no records were updated,\n          // thus we don't need to rectify explicitly ourselves\n          return cb();\n\n        case undefined:\n        case null:\n          return cb(new Error(\n            g.f('Cannot apply bulk updates, ' +\n            'the connector does not correctly report ' +\n            'the number of updated records.')));\n\n        default:\n          debug('%s.updateAll modified unexpected number of instances: %j',\n            Model.modelName, count);\n          return cb(new Error(\n            g.f('Bulk update failed, the connector has modified unexpected ' +\n            'number of records: %s', JSON.stringify(count))));\n      }\n    });\n  }\n\n  function applyCreate(Model, id, current, data, change, conflicts, options, cb) {\n    Model.create(data, options, function(createErr) {\n      if (!createErr) return cb();\n\n      // We don't have a reliable way how to detect the situation\n      // where he model was not create because of a duplicate id\n      // The workaround is to query the DB to check if the model already exists\n      Model.findById(id, function(findErr, inst) {\n        if (findErr || !inst) {\n          // There isn't any instance with the same id, thus there isn't\n          // any conflict and we just report back the original error.\n          return cb(createErr);\n        }\n\n        return conflict();\n      });\n    });\n\n    function conflict() {\n      // The instance already exists - report a conflict\n      debug('Detected non-rectified new instance of %s %j',\n        Model.modelName, id);\n      conflicts.push(change);\n\n      var Change = Model.getChangeModel();\n      return Change.rectifyModelChanges(Model.modelName, [id], cb);\n    }\n  }\n\n  function applyDelete(Model, id, current, change, conflicts, options, cb) {\n    if (!current) {\n      // The instance was either already deleted or not created at all,\n      // we are done.\n      return cb();\n    }\n\n    var Change = Model.getChangeModel();\n    var rev = Change.revisionForInst(current);\n    if (rev !== change.prev) {\n      debug('Detected non-rectified change of %s %j',\n        Model.modelName, id);\n      debug('\\tExpected revision: %s', change.rev);\n      debug('\\tActual revision:   %s', rev);\n      conflicts.push(change);\n      return Change.rectifyModelChanges(Model.modelName, [id], cb);\n    }\n\n    Model.deleteAll(current.toObject(), options, function(err, result) {\n      if (err) return cb(err);\n\n      var count = result && result.count;\n      switch (count) {\n        case 1:\n          // The happy path, exactly one record was updated\n          return cb();\n\n        case 0:\n          debug('DeleteAll detected non-rectified change of %s %j',\n            Model.modelName, id);\n          conflicts.push(change);\n          // NOTE(bajtos) deleteAll triggers change rectification\n          // for all model instances, even when no records were updated,\n          // thus we don't need to rectify explicitly ourselves\n          return cb();\n\n        case undefined:\n        case null:\n          return cb(new Error(\n            g.f('Cannot apply bulk updates, ' +\n            'the connector does not correctly report ' +\n            'the number of deleted records.')));\n\n        default:\n          debug('%s.deleteAll modified unexpected number of instances: %j',\n            Model.modelName, count);\n          return cb(new Error(\n            g.f('Bulk update failed, the connector has deleted unexpected ' +\n            'number of records: %s', JSON.stringify(count))));\n      }\n    });\n  }\n\n  /**\n   * Get the `Change` model.\n   * Throws an error if the change model is not correctly setup.\n   * @return {Change}\n   */\n\n  PersistedModel.getChangeModel = function() {\n    var changeModel = this.Change;\n    var isSetup = changeModel && changeModel.dataSource;\n\n    assert(isSetup, 'Cannot get a setup Change model for ' + this.modelName);\n\n    return changeModel;\n  };\n\n  /**\n   * Get the source identifier for this model or dataSource.\n   *\n   * @callback {Function} callback Callback function called with `(err, id)` arguments.\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   * @param {String} sourceId Source identifier for the model or dataSource.\n   */\n\n  PersistedModel.getSourceId = function(cb) {\n    var dataSource = this.dataSource;\n    if (!dataSource) {\n      this.once('dataSourceAttached', this.getSourceId.bind(this, cb));\n    }\n    assert(\n      dataSource.connector.name,\n      'Model.getSourceId: cannot get id without dataSource.connector.name'\n    );\n    var id = [dataSource.connector.name, this.modelName].join('-');\n    cb(null, id);\n  };\n\n  /**\n   * Enable the tracking of changes made to the model. Usually for replication.\n   */\n\n  PersistedModel.enableChangeTracking = function() {\n    var Model = this;\n    var Change = this.Change || this._defineChangeModel();\n    var cleanupInterval = Model.settings.changeCleanupInterval || 30000;\n\n    assert(this.dataSource, 'Cannot enableChangeTracking(): ' + this.modelName +\n      ' is not attached to a dataSource');\n\n    var idName = this.getIdName();\n    var idProp = this.definition.properties[idName];\n    var idType = idProp && idProp.type;\n    var idDefn = idProp && idProp.defaultFn;\n    if (idType !== String || !(idDefn === 'uuid' || idDefn === 'guid')) {\n      deprecated('The model ' + this.modelName + ' is tracking changes, ' +\n        'which requires a string id with GUID/UUID default value.');\n    }\n\n    Model.observe('after save', rectifyOnSave);\n\n    Model.observe('after delete', rectifyOnDelete);\n\n    // Only run if the run time is server\n    // Can switch off cleanup by setting the interval to -1\n    if (runtime.isServer && cleanupInterval > 0) {\n      // initial cleanup\n      cleanup();\n\n      // cleanup\n      setInterval(cleanup, cleanupInterval);\n    }\n\n    function cleanup() {\n      Model.rectifyAllChanges(function(err) {\n        if (err) {\n          Model.handleChangeError(err, 'cleanup');\n        }\n      });\n    }\n  };\n\n  function rectifyOnSave(ctx, next) {\n    var instance = ctx.instance || ctx.currentInstance;\n    var id = instance ? instance.getId() :\n      getIdFromWhereByModelId(ctx.Model, ctx.where);\n\n    if (debug.enabled) {\n      debug('rectifyOnSave %s -> ' + (id ? 'id %j' : '%s'),\n        ctx.Model.modelName, id ? id : 'ALL');\n      debug('context instance:%j currentInstance:%j where:%j data %j',\n        ctx.instance, ctx.currentInstance, ctx.where, ctx.data);\n    }\n\n    if (id) {\n      ctx.Model.rectifyChange(id, reportErrorAndNext);\n    } else {\n      ctx.Model.rectifyAllChanges(reportErrorAndNext);\n    }\n\n    function reportErrorAndNext(err) {\n      if (err) {\n        ctx.Model.handleChangeError(err, 'after save');\n      }\n      next();\n    }\n  }\n\n  function rectifyOnDelete(ctx, next) {\n    var id = ctx.instance ? ctx.instance.getId() :\n      getIdFromWhereByModelId(ctx.Model, ctx.where);\n\n    if (debug.enabled) {\n      debug('rectifyOnDelete %s -> ' + (id ? 'id %j' : '%s'),\n        ctx.Model.modelName, id ? id : 'ALL');\n      debug('context instance:%j where:%j', ctx.instance, ctx.where);\n    }\n\n    if (id) {\n      ctx.Model.rectifyChange(id, reportErrorAndNext);\n    } else {\n      ctx.Model.rectifyAllChanges(reportErrorAndNext);\n    }\n\n    function reportErrorAndNext(err) {\n      if (err) {\n        ctx.Model.handleChangeError(err, 'after delete');\n      }\n      next();\n    }\n  }\n\n  function getIdFromWhereByModelId(Model, where) {\n    var idName = Model.getIdName();\n    if (!(idName in where)) return undefined;\n\n    var id = where[idName];\n    // TODO(bajtos) support object values that are not LB conditions\n    if (typeof id === 'string' || typeof id === 'number') {\n      return id;\n    }\n    return undefined;\n  }\n\n  PersistedModel._defineChangeModel = function() {\n    var BaseChangeModel = this.registry.getModel('Change');\n    assert(BaseChangeModel,\n      'Change model must be defined before enabling change replication');\n\n    const additionalChangeModelProperties =\n      this.settings.additionalChangeModelProperties || {};\n\n    this.Change = BaseChangeModel.extend(this.modelName + '-change',\n      additionalChangeModelProperties,\n      {trackModel: this}\n    );\n\n    if (this.dataSource) {\n      attachRelatedModels(this);\n    }\n\n    // Re-attach related models whenever our datasource is changed.\n    var self = this;\n    this.on('dataSourceAttached', function() {\n      attachRelatedModels(self);\n    });\n\n    return this.Change;\n\n    function attachRelatedModels(self) {\n      self.Change.attachTo(self.dataSource);\n      self.Change.getCheckpointModel().attachTo(self.dataSource);\n    }\n  };\n\n  PersistedModel.rectifyAllChanges = function(callback) {\n    this.getChangeModel().rectifyAll(callback);\n  };\n\n  /**\n   * Handle a change error. Override this method in a subclassing model to customize\n   * change error handling.\n   *\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).\n   */\n\n  PersistedModel.handleChangeError = function(err, operationName) {\n    if (!err) return;\n    this.emit('error', err, operationName);\n  };\n\n  /**\n   * Specify that a change to the model with the given ID has occurred.\n   *\n   * @param {*} id The ID of the model that has changed.\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n\n  PersistedModel.rectifyChange = function(id, callback) {\n    var Change = this.getChangeModel();\n    Change.rectifyModelChanges(this.modelName, [id], callback);\n  };\n\n  PersistedModel.findLastChange = function(id, cb) {\n    var Change = this.getChangeModel();\n    Change.findOne({where: {modelId: id}}, cb);\n  };\n\n  PersistedModel.updateLastChange = function(id, data, cb) {\n    var self = this;\n    this.findLastChange(id, function(err, inst) {\n      if (err) return cb(err);\n      if (!inst) {\n        err = new Error(g.f('No change record found for %s with id %s',\n          self.modelName, id));\n        err.statusCode = 404;\n        return cb(err);\n      }\n\n      inst.updateAttributes(data, cb);\n    });\n  };\n\n  /**\n   * Create a change stream. [See here for more info](http://loopback.io/doc/en/lb2/Realtime-server-sent-events.html)\n   *\n   * @param {Object} options\n   * @param {Object} options.where Only changes to models matching this where filter will be included in the `ChangeStream`.\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {ChangeStream} changes\n   */\n\n  PersistedModel.createChangeStream = function(options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = undefined;\n    }\n\n    var idName = this.getIdName();\n    var Model = this;\n    var changes = new PassThrough({objectMode: true});\n    var writeable = true;\n\n    changes.destroy = function() {\n      changes.removeAllListeners('error');\n      changes.removeAllListeners('end');\n      writeable = false;\n      changes = null;\n    };\n\n    changes.on('error', function() {\n      writeable = false;\n    });\n    changes.on('end', function() {\n      writeable = false;\n    });\n\n    process.nextTick(function() {\n      cb(null, changes);\n    });\n\n    Model.observe('after save', createChangeHandler('save'));\n    Model.observe('after delete', createChangeHandler('delete'));\n\n    function createChangeHandler(type) {\n      return function(ctx, next) {\n        // since it might have set to null via destroy\n        if (!changes) {\n          return next();\n        }\n\n        var where = ctx.where;\n        var data = ctx.instance || ctx.data;\n        var whereId = where && where[idName];\n\n        // the data includes the id\n        // or the where includes the id\n        var target;\n\n        if (data && (data[idName] || data[idName] === 0)) {\n          target = data[idName];\n        } else if (where && (where[idName] || where[idName] === 0)) {\n          target = where[idName];\n        }\n\n        var hasTarget = target === 0 || !!target;\n\n        var change = {\n          target: target,\n          where: where,\n          data: data,\n        };\n\n        switch (type) {\n          case 'save':\n            if (ctx.isNewInstance === undefined) {\n              change.type = hasTarget ? 'update' : 'create';\n            } else {\n              change.type = ctx.isNewInstance ? 'create' : 'update';\n            }\n\n            break;\n          case 'delete':\n            change.type = 'remove';\n            break;\n        }\n\n        // TODO(ritch) this is ugly... maybe a ReadableStream would be better\n        if (writeable) {\n          changes.write(change);\n        }\n\n        next();\n      };\n    }\n  };\n\n  /**\n   * Get the filter for searching related changes.\n   *\n   * Models should override this function to copy properties\n   * from the model instance filter into the change search filter.\n   *\n   * ```js\n   * module.exports = (TargetModel, config) => {\n   *   TargetModel.createChangeFilter = function(since, modelFilter) {\n   *     const filter = this.base.createChangeFilter.apply(this, arguments);\n   *     if (modelFilter && modelFilter.where && modelFilter.where.tenantId) {\n   *       filter.where.tenantId = modelFilter.where.tenantId;\n   *     }\n   *     return filter;\n   *   };\n   * };\n   * ```\n   *\n   * @param {Number} since Return only changes since this checkpoint.\n   * @param {Object} modelFilter Filter describing which model instances to\n   * include in the list of changes.\n   * @returns {Object} The filter object to pass to `Change.find()`. Default:\n   * ```\n   * {where: {checkpoint: {gte: since}, modelName: this.modelName}}\n   * ```\n   */\n  PersistedModel.createChangeFilter = function(since, modelFilter) {\n    return {\n      where: {\n        checkpoint: {gte: since},\n        modelName: this.modelName,\n      },\n    };\n  };\n\n  /**\n   * Add custom data to the Change instance.\n   *\n   * Models should override this function to duplicate model instance properties\n   * to the Change instance properties, typically to allow the changes() method\n   * to filter the changes using these duplicated properties directly while\n   * querying the Change model.\n   *\n   * ```js\n   * module.exports = (TargetModel, config) => {\n   *   TargetModel.prototype.fillCustomChangeProperties = function(change, cb) {\n   *     var inst = this;\n   *     const base = this.constructor.base;\n   *     base.prototype.fillCustomChangeProperties.call(this, change, err => {\n   *       if (err) return cb(err);\n   *\n   *       if (inst && inst.tenantId) {\n   *         change.tenantId = inst.tenantId;\n   *       } else {\n   *         change.tenantId = null;\n   *       }\n   *\n   *       cb();\n   *     });\n   *   };\n   * };\n   * ```\n   *\n   * @callback {Function} callback\n   * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb3/Error-object.html).\n   */\n  PersistedModel.prototype.fillCustomChangeProperties = function(change, cb) {\n    // no-op by default\n    cb();\n  };\n\n  PersistedModel.setup();\n\n  return PersistedModel;\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/runtime.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*\n * This is an internal file that should not be used outside of loopback.\n * All exported entities can be accessed via the `loopback` object.\n * @private\n */\n\n'use strict';\nvar runtime = exports;\n\n/**\n * True if running in a browser environment; false otherwise.\n * @header loopback.isBrowser\n */\n\nruntime.isBrowser = typeof window !== 'undefined';\n\n/**\n * True if running in a server environment; false otherwise.\n * @header loopback.isServer\n */\n\nruntime.isServer = !runtime.isBrowser;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/utils.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nexports.createPromiseCallback = createPromiseCallback;\nexports.uploadInChunks = uploadInChunks;\nexports.downloadInChunks = downloadInChunks;\nexports.concatResults = concatResults;\n\nvar Promise = require('bluebird');\nvar async = require('async');\n\nfunction createPromiseCallback() {\n  var cb;\n  var promise = new Promise(function(resolve, reject) {\n    cb = function(err, data) {\n      if (err) return reject(err);\n      return resolve(data);\n    };\n  });\n  cb.promise = promise;\n  return cb;\n}\n\nfunction throwPromiseNotDefined() {\n  throw new Error(\n    'Your Node runtime does support ES6 Promises. ' +\n    'Set \"global.Promise\" to your preferred implementation of promises.');\n}\n\n/**\n * Divide an async call with large array into multiple calls using smaller chunks\n * @param {Array} largeArray - the large array to be chunked\n * @param {Number} chunkSize - size of each chunks\n * @param {Function} processFunction - the function to be called multiple times\n * @param {Function} cb - the callback\n */\nfunction uploadInChunks(largeArray, chunkSize, processFunction, cb) {\n  var chunkArrays = [];\n\n  if (!chunkSize || chunkSize < 1 || largeArray.length <= chunkSize) {\n    // if chunking not required\n    processFunction(largeArray, cb);\n  } else {\n    // copying so that the largeArray object does not get affected during splice\n    var copyOfLargeArray = [].concat(largeArray);\n\n    // chunking to smaller arrays\n    while (copyOfLargeArray.length > 0) {\n      chunkArrays.push(copyOfLargeArray.splice(0, chunkSize));\n    }\n\n    var tasks = chunkArrays.map(function(chunkArray) {\n      return function(previousResults, chunkCallback) {\n        var lastArg = arguments[arguments.length - 1];\n\n        if (typeof lastArg === 'function') {\n          chunkCallback = lastArg;\n        }\n\n        processFunction(chunkArray, function(err, results) {\n          if (err) {\n            return chunkCallback(err);\n          }\n\n          // if this is the first async waterfall call or if previous results was not defined\n          if (typeof previousResults === 'function' || typeof previousResults === 'undefined' ||\n            previousResults === null) {\n            previousResults = results;\n          } else if (results) {\n            previousResults = concatResults(previousResults, results);\n          }\n\n          chunkCallback(err, previousResults);\n        });\n      };\n    });\n\n    async.waterfall(tasks, cb);\n  }\n}\n\n/**\n * Page async download calls\n * @param {Object} filter - filter object used for the async call\n * @param {Number} chunkSize - size of each chunks\n * @param {Function} processFunction - the function to be called multiple times\n * @param {Function} cb - the callback\n */\nfunction downloadInChunks(filter, chunkSize, processFunction, cb) {\n  var results = [];\n  filter = filter ? JSON.parse(JSON.stringify(filter)) : {};\n\n  if (!chunkSize || chunkSize < 1) {\n    // if chunking not required\n    processFunction(filter, cb);\n  } else {\n    filter.skip = 0;\n    filter.limit = chunkSize;\n\n    processFunction(JSON.parse(JSON.stringify(filter)), pageAndConcatResults);\n  }\n\n  function pageAndConcatResults(err, pagedResults) {\n    if (err) {\n      return cb(err);\n    } else {\n      results = concatResults(results, pagedResults);\n      if (pagedResults.length >= chunkSize) {\n        filter.skip += pagedResults.length;\n        processFunction(JSON.parse(JSON.stringify(filter)), pageAndConcatResults);\n      } else {\n        cb(null, results);\n      }\n    }\n  }\n}\n\n/**\n * Concat current results into previous results\n * Assumption made here that the previous results and current results are homogeneous\n * @param {Object|Array} previousResults\n * @param {Object|Array} currentResults\n */\nfunction concatResults(previousResults, currentResults) {\n  if (Array.isArray(currentResults)) {\n    previousResults = previousResults.concat(currentResults);\n  } else if (typeof currentResults === 'object') {\n    Object.keys(currentResults).forEach(function(key) {\n      previousResults[key] = concatResults(previousResults[key], currentResults[key]);\n    });\n  } else {\n    previousResults = currentResults;\n  }\n\n  return previousResults;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/context.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('../../lib/globalize');\n\nmodule.exports = function() {\n  throw new Error(g.f(\n    '%s middleware was removed in version 3.0. See %s for more details.',\n    'loopback#context',\n    'http://loopback.io/doc/en/lb2/Using-current-context.html'));\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/error-handler.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nmodule.exports = function(options) {\n  throw new Error('loopback.errorHandler is no longer available.' +\n  ' Please use the module \"strong-error-handler\" instead.');\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/favicon.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar favicon = require('serve-favicon');\nvar path = require('path');\n\n/**\n * Serve the LoopBack favicon.\n * @header loopback.favicon()\n */\nmodule.exports = function(icon, options) {\n  icon = icon || path.join(__dirname, '../../favicon.ico');\n  return favicon(icon, options);\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/rest.js":"// Copyright IBM Corp. 2014,2015. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module dependencies.\n */\n\n'use strict';\nvar g = require('../../lib/globalize');\nvar loopback = require('../../lib/loopback');\nvar async = require('async');\n\n/*!\n * Export the middleware.\n */\n\nmodule.exports = rest;\n\n/**\n * Expose models over REST.\n *\n * For example:\n * ```js\n * app.use(loopback.rest());\n * ```\n * For more information, see [Exposing models over a REST API](http://loopback.io/doc/en/lb2/Exposing-models-over-REST.html).\n * @header loopback.rest()\n */\n\nfunction rest() {\n  var handlers; // Cached handlers\n\n  return function restApiHandler(req, res, next) {\n    var app = req.app;\n    var registry = app.registry;\n\n    if (!handlers) {\n      handlers = [];\n      var remotingOptions = app.get('remoting') || {};\n\n      var contextOptions = remotingOptions.context;\n      if (contextOptions !== undefined && contextOptions !== false) {\n        throw new Error(g.f(\n          '%s was removed in version 3.0. See %s for more details.',\n          'remoting.context option',\n          'http://loopback.io/doc/en/lb2/Using-current-context.html'));\n      }\n\n      if (app.isAuthEnabled) {\n        var AccessToken = registry.getModelByType('AccessToken');\n        handlers.push(loopback.token({model: AccessToken, app: app}));\n      }\n\n      handlers.push(function(req, res, next) {\n        // Need to get an instance of the REST handler per request\n        return app.handler('rest')(req, res, next);\n      });\n    }\n    if (handlers.length === 1) {\n      return handlers[0](req, res, next);\n    }\n    async.eachSeries(handlers, function(handler, done) {\n      handler(req, res, done);\n    }, next);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/static.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/**\n * Serve static assets of a LoopBack application.\n *\n * @param {string} root The root directory from which the static assets are to\n * be served.\n * @param {object} options Refer to\n *   [express documentation](http://expressjs.com/4x/api.html#express.static)\n *   for the full list of available options.\n * @header loopback.static(root, [options])\n */\n'use strict';\nmodule.exports = require('express').static;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/status.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Export the middleware.\n */\n\n'use strict';\nmodule.exports = status;\n\n/**\n * Return [HTTP response](http://expressjs.com/4x/api.html#res.send) with basic application status information:\n * date the application was started and uptime, in JSON format.\n * For example:\n * ```js\n * {\n *  \"started\": \"2014-06-05T00:26:49.750Z\",\n *  \"uptime\": 9.394\n * }\n * ```\n *\n * @header loopback.status()\n */\nfunction status() {\n  var started = new Date();\n\n  return function(req, res) {\n    res.send({\n      started: started,\n      uptime: (Date.now() - Number(started)) / 1000,\n    });\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/token.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module dependencies.\n */\n\n'use strict';\nvar loopback = require('../../lib/loopback');\nvar assert = require('assert');\nvar debug = require('debug')('loopback:middleware:token');\n\n/*!\n * Export the middleware.\n */\n\nmodule.exports = token;\n\n/*\n * Rewrite the url to replace current user literal with the logged in user id\n */\nfunction rewriteUserLiteral(req, currentUserLiteral) {\n  if (req.accessToken && req.accessToken.userId && currentUserLiteral) {\n    // Replace /me/ with /current-user-id/\n    var urlBeforeRewrite = req.url;\n    req.url = req.url.replace(\n      new RegExp('/' + currentUserLiteral + '(/|$|\\\\?)', 'g'),\n        '/' + req.accessToken.userId + '$1');\n    if (req.url !== urlBeforeRewrite) {\n      debug('req.url has been rewritten from %s to %s', urlBeforeRewrite,\n        req.url);\n    }\n  }\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Check for an access token in cookies, headers, and query string parameters.\n * This function always checks for the following:\n *\n * - `access_token` (params only)\n * - `X-Access-Token` (headers only)\n * - `authorization` (headers and cookies)\n *\n * It checks for these values in cookies, headers, and query string parameters _in addition_ to the items\n * specified in the options parameter.\n *\n * **NOTE:** This function only checks for [signed cookies](http://expressjs.com/api.html#req.signedCookies).\n *\n * The following example illustrates how to check for an `accessToken` in a custom cookie, query string parameter\n * and header called `foo-auth`.\n *\n * ```js\n * app.use(loopback.token({\n *   cookies: ['foo-auth'],\n *   headers: ['foo-auth', 'X-Foo-Auth'],\n *   params: ['foo-auth', 'foo_auth']\n * }));\n * ```\n *\n * @options {Object} [options] Each option array is used to add additional keys to find an `accessToken` for a `request`.\n * @property {Array} [cookies] Array of cookie names.\n * @property {Array} [headers] Array of header names.\n * @property {Array} [params] Array of param names.\n * @property {Boolean} [searchDefaultTokenKeys] Use the default search locations for Token in request\n * @property {Boolean} [enableDoublecheck] Execute middleware although an instance mounted earlier in the chain didn't find a token\n * @property {Boolean} [overwriteExistingToken] only has effect in combination with `enableDoublecheck`. If truthy, will allow to overwrite an existing accessToken.\n * @property {Function|String} [model] AccessToken model name or class to use.\n * @property {String} [currentUserLiteral] String literal for the current user.\n * @header loopback.token([options])\n */\n\nfunction token(options) {\n  options = options || {};\n  var TokenModel;\n\n  var currentUserLiteral = options.currentUserLiteral;\n  if (currentUserLiteral && (typeof currentUserLiteral !== 'string')) {\n    debug('Set currentUserLiteral to \\'me\\' as the value is not a string.');\n    currentUserLiteral = 'me';\n  }\n  if (typeof currentUserLiteral === 'string') {\n    currentUserLiteral = escapeRegExp(currentUserLiteral);\n  }\n\n  var enableDoublecheck = !!options.enableDoublecheck;\n  var overwriteExistingToken = !!options.overwriteExistingToken;\n\n  return function(req, res, next) {\n    var app = req.app;\n    var registry = app.registry;\n    if (!TokenModel) {\n      TokenModel = registry.getModel(options.model || 'AccessToken');\n    }\n\n    assert(typeof TokenModel === 'function',\n      'loopback.token() middleware requires a AccessToken model');\n\n    if (req.accessToken !== undefined) {\n      if (!enableDoublecheck) {\n        // req.accessToken is defined already (might also be \"null\" or \"false\") and enableDoublecheck\n        // has not been set --> skip searching for credentials\n        rewriteUserLiteral(req, currentUserLiteral);\n        return next();\n      }\n      if (req.accessToken && req.accessToken.id && !overwriteExistingToken) {\n        // req.accessToken.id is defined, which means that some other middleware has identified a valid user.\n        // when overwriteExistingToken is not set to a truthy value, skip searching for credentials.\n        rewriteUserLiteral(req, currentUserLiteral);\n        return next();\n      }\n      // continue normal operation (as if req.accessToken was undefined)\n    }\n    TokenModel.findForRequest(req, options, function(err, token) {\n      req.accessToken = token || null;\n      rewriteUserLiteral(req, currentUserLiteral);\n      var ctx = req.loopbackContext;\n      if (ctx && ctx.active) ctx.set('accessToken', token);\n      next(err);\n    });\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/server/middleware/url-not-found.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Export the middleware.\n * See discussion in Connect pull request #954 for more details\n * https://github.com/senchalabs/connect/pull/954.\n */\n'use strict';\nmodule.exports = urlNotFound;\n\n/**\n * Convert any request not handled so far to a 404 error\n * to be handled by error-handling middleware.\n * @header loopback.urlNotFound()\n */\nfunction urlNotFound() {\n  return function raiseUrlNotFoundError(req, res, next) {\n    var error = new Error('Cannot ' + req.method + ' ' + req.url);\n    error.status = 404;\n    next(error);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/current-context.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('./globalize');\nvar juggler = require('loopback-datasource-juggler');\nvar remoting = require('strong-remoting');\n\nmodule.exports = function(loopback) {\n  juggler.getCurrentContext =\n  remoting.getCurrentContext =\n  loopback.getCurrentContext = function() {\n    throw new Error(g.f(\n      '%s was removed in version 3.0. See %s for more details.',\n      'loopback.getCurrentContext()',\n      'http://loopback.io/doc/en/lb2/Using-current-context.html'));\n  };\n\n  loopback.runInContext = function(fn) {\n    throw new Error(g.f(\n      '%s was removed in version 3.0. See %s for more details.',\n      'loopback.runInContext()',\n      'http://loopback.io/doc/en/lb2/Using-current-context.html'));\n  };\n\n  loopback.createContext = function(scopeName) {\n    throw new Error(g.f(\n      '%s was removed in version 3.0. See %s for more details.',\n      'loopback.createContext()',\n      'http://loopback.io/doc/en/lb2/Using-current-context.html'));\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/builtin-models.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nconst assert = require('assert');\n\nmodule.exports = function(registry) {\n  // NOTE(bajtos) we must use static require() due to browserify limitations\n\n  registry.KeyValueModel = createModel(\n    require('../common/models/key-value-model.json'),\n    require('../common/models/key-value-model.js'));\n\n  registry.Email = createModel(\n    require('../common/models/email.json'),\n    require('../common/models/email.js'));\n\n  registry.Application = createModel(\n    require('../common/models/application.json'),\n    require('../common/models/application.js'));\n\n  registry.AccessToken = createModel(\n    require('../common/models/access-token.json'),\n    require('../common/models/access-token.js'));\n\n  registry.User = createModel(\n    require('../common/models/user.json'),\n    require('../common/models/user.js'));\n\n  registry.RoleMapping = createModel(\n    require('../common/models/role-mapping.json'),\n    require('../common/models/role-mapping.js'));\n\n  registry.Role = createModel(\n    require('../common/models/role.json'),\n    require('../common/models/role.js'));\n\n  registry.ACL = createModel(\n    require('../common/models/acl.json'),\n    require('../common/models/acl.js'));\n\n  registry.Scope = createModel(\n    require('../common/models/scope.json'),\n    require('../common/models/scope.js'));\n\n  registry.Change = createModel(\n    require('../common/models/change.json'),\n    require('../common/models/change.js'));\n\n  registry.Checkpoint = createModel(\n    require('../common/models/checkpoint.json'),\n    require('../common/models/checkpoint.js'));\n\n  function createModel(definitionJson, customizeFn) {\n    // Clone the JSON definition to allow applications\n    // to modify model settings while not affecting\n    // settings of new models created in the local registry\n    // of another app.\n    // This is needed because require() always returns the same\n    // object instance it loaded during the first call.\n    definitionJson = cloneDeepJson(definitionJson);\n\n    var Model = registry.createModel(definitionJson);\n    customizeFn(Model);\n    return Model;\n  }\n};\n\n// Because we are cloning objects created by JSON.parse,\n// the cloning algorithm can stay much simpler than a general-purpose\n// \"cloneDeep\" e.g. from lodash.\nfunction cloneDeepJson(obj) {\n  const result = Array.isArray(obj) ? [] : {};\n  assert.equal(Object.getPrototypeOf(result), Object.getPrototypeOf(obj));\n  for (const key in obj) {\n    const value = obj[key];\n    if (typeof value === 'object') {\n      result[key] = cloneDeepJson(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/key-value-model.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('../../lib/globalize');\n\n/**\n * Data model for key-value databases.\n *\n * @class KeyValueModel\n * @inherits {Model}\n */\n\nmodule.exports = function(KeyValueModel) {\n  /**\n   * Return the value associated with a given key.\n   *\n   * @param {String} key Key to use when searching the database.\n   * @options {Object} options\n   * @callback {Function} callback\n   * @param {Error} err Error object.\n   * @param {Any} result Value associated with the given key.\n   * @promise\n   *\n   * @header KeyValueModel.get(key, cb)\n   */\n  KeyValueModel.get = function(key, options, callback) {\n    throwNotAttached(this.modelName, 'get');\n  };\n\n  /**\n   * Persist a value and associate it with the given key.\n   *\n   * @param {String} key Key to associate with the given value.\n   * @param {Any} value Value to persist.\n   * @options {Number|Object} options Optional settings for the key-value\n   *   pair. If a Number is provided, it is set as the TTL (time to live) in ms\n   *   (milliseconds) for the key-value pair.\n   * @property {Number} ttl TTL for the key-value pair in ms.\n   * @callback {Function} callback\n   * @param {Error} err Error object.\n   * @promise\n   *\n   * @header KeyValueModel.set(key, value, cb)\n   */\n  KeyValueModel.set = function(key, value, options, callback) {\n    throwNotAttached(this.modelName, 'set');\n  };\n\n  /**\n   * Set the TTL (time to live) in ms (milliseconds) for a given key. TTL is the\n   * remaining time before a key-value pair is discarded from the database.\n   *\n   * @param {String} key Key to use when searching the database.\n   * @param {Number} ttl TTL in ms to set for the key.\n   * @options {Object} options\n   * @callback {Function} callback\n   * @param {Error} err Error object.\n   * @promise\n   *\n   * @header KeyValueModel.expire(key, ttl, cb)\n   */\n  KeyValueModel.expire = function(key, ttl, options, callback) {\n    throwNotAttached(this.modelName, 'expire');\n  };\n\n  /**\n   * Return the TTL (time to live) for a given key. TTL is the remaining time\n   * before a key-value pair is discarded from the database.\n   *\n   * @param {String} key Key to use when searching the database.\n   * @options {Object} options\n   * @callback {Function} callback\n   * @param {Error} error\n   * @param {Number} ttl Expiration time for the key-value pair. `undefined` if\n   *   TTL was not initially set.\n   * @promise\n   *\n   * @header KeyValueModel.ttl(key, cb)\n   */\n  KeyValueModel.ttl = function(key, options, callback) {\n    throwNotAttached(this.modelName, 'ttl');\n  };\n\n  /**\n   * Return all keys in the database.\n   *\n   * **WARNING**: This method is not suitable for large data sets as all\n   * key-values pairs are loaded into memory at once. For large data sets,\n   * use `iterateKeys()` instead.\n   *\n   * @param {Object} filter An optional filter object with the following\n   * @param {String} filter.match Glob string used to filter returned\n   *   keys (i.e. `userid.*`). All connectors are required to support `*` and\n   *   `?`, but may also support additional special characters specific to the\n   *   database.\n   * @param {Object} options\n   * @callback {Function} callback\n   * @promise\n   *\n   * @header KeyValueModel.keys(filter, cb)\n   */\n  KeyValueModel.keys = function(filter, options, callback) {\n    throwNotAttached(this.modelName, 'keys');\n  };\n\n  /**\n   * Asynchronously iterate all keys in the database. Similar to `.keys()` but\n   * instead allows for iteration over large data sets without having to load\n   * everything into memory at once.\n   *\n   * Callback example:\n   * ```js\n   * // Given a model named `Color` with two keys `red` and `blue`\n   * var iterator = Color.iterateKeys();\n   * it.next(function(err, key) {\n   *   // key contains `red`\n   *   it.next(function(err, key) {\n   *     // key contains `blue`\n   *   });\n   * });\n   * ```\n   *\n   * Promise example:\n   * ```js\n   * // Given a model named `Color` with two keys `red` and `blue`\n   * var iterator = Color.iterateKeys();\n   * Promise.resolve().then(function() {\n   *   return it.next();\n   * })\n   * .then(function(key) {\n   *   // key contains `red`\n   *   return it.next();\n   * });\n   * .then(function(key) {\n   *   // key contains `blue`\n   * });\n   * ```\n   *\n   * @param {Object} filter An optional filter object with the following\n   * @param {String} filter.match Glob string to use to filter returned\n   *   keys (i.e. `userid.*`). All connectors are required to support `*` and\n   *   `?`. They may also support additional special characters that are\n   *   specific to the backing database.\n   * @param {Object} options\n   * @returns {AsyncIterator} An Object implementing `next(cb) -> Promise`\n   *   function that can be used to iterate all keys.\n   *\n   * @header KeyValueModel.iterateKeys(filter)\n   */\n  KeyValueModel.iterateKeys = function(filter, options) {\n    throwNotAttached(this.modelName, 'iterateKeys');\n  };\n\n  /*!\n   * Set up remoting metadata for this model.\n   *\n   * **Notes**:\n   * - The method is called automatically by `Model.extend` and/or\n   *   `app.registry.createModel`\n   * - In general, base models use call this to ensure remote methods are\n   *   inherited correctly, see bug at\n   *   https://github.com/strongloop/loopback/issues/2350\n   */\n  KeyValueModel.setup = function() {\n    KeyValueModel.base.setup.apply(this, arguments);\n\n    this.remoteMethod('get', {\n      accepts: {\n        arg: 'key', type: 'string', required: true,\n        http: {source: 'path'},\n      },\n      returns: {arg: 'value', type: 'any', root: true},\n      http: {path: '/:key', verb: 'get'},\n      rest: {after: convertNullToNotFoundError},\n    });\n\n    this.remoteMethod('set', {\n      accepts: [\n        {arg: 'key', type: 'string', required: true,\n          http: {source: 'path'}},\n        {arg: 'value', type: 'any', required: true,\n          http: {source: 'body'}},\n        {arg: 'ttl', type: 'number',\n          http: {source: 'query'},\n          description: 'time to live in milliseconds'},\n      ],\n      http: {path: '/:key', verb: 'put'},\n    });\n\n    this.remoteMethod('expire', {\n      accepts: [\n        {arg: 'key', type: 'string', required: true,\n          http: {source: 'path'}},\n        {arg: 'ttl', type: 'number', required: true,\n          http: {source: 'form'}},\n      ],\n      http: {path: '/:key/expire', verb: 'put'},\n    });\n\n    this.remoteMethod('ttl', {\n      accepts: {\n        arg: 'key', type: 'string', required: true,\n        http: {source: 'path'},\n      },\n      returns: {arg: 'value', type: 'any', root: true},\n      http: {path: '/:key/ttl', verb: 'get'},\n    });\n\n    this.remoteMethod('keys', {\n      accepts: {\n        arg: 'filter', type: 'object', required: false,\n        http: {source: 'query'},\n      },\n      returns: {arg: 'keys', type: ['string'], root: true},\n      http: {path: '/keys', verb: 'get'},\n    });\n  };\n};\n\nfunction throwNotAttached(modelName, methodName) {\n  throw new Error(g.f(\n    'Cannot call %s.%s(). ' +\n      'The %s method has not been setup. '  +\n      'The {{KeyValueModel}} has not been correctly attached ' +\n      'to a {{DataSource}}!',\n    modelName, methodName, methodName));\n}\n\nfunction convertNullToNotFoundError(ctx, cb) {\n  if (ctx.result !== null) return cb();\n\n  var modelName = ctx.method.sharedClass.name;\n  var id = ctx.getArgByName('id');\n  var msg = g.f('Unknown \"%s\" {{key}} \"%s\".', modelName, id);\n  var error = new Error(msg);\n  error.statusCode = error.status = 404;\n  error.code = 'KEY_NOT_FOUND';\n  cb(error);\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/email.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar g = require('../../lib/globalize');\n\n/**\n* Email model.  Extends LoopBack base [Model](#model-new-model).\n* @property {String} to Email addressee.  Required.\n* @property {String} from Email sender address.  Required.\n* @property {String} subject Email subject string.  Required.\n* @property {String} text Text body of email.\n* @property {String} html HTML body of email.\n*\n* @class Email\n* @inherits {Model}\n*/\n\nmodule.exports = function(Email) {\n  /**\n   * Send an email with the given `options`.\n   *\n   * Example Options:\n   *\n   * ```js\n   * {\n   *   from: \"Fred Foo <foo@blurdybloop.com>\", // sender address\n   *   to: \"bar@blurdybloop.com, baz@blurdybloop.com\", // list of receivers\n   *   subject: \"Hello\", // Subject line\n   *   text: \"Hello world\", // plaintext body\n   *   html: \"<b>Hello world</b>\" // html body\n   * }\n   * ```\n   *\n   * See https://github.com/andris9/Nodemailer for other supported options.\n   *\n   * @options {Object} options See below\n   * @prop {String} from Senders's email address\n   * @prop {String} to List of one or more recipient email addresses (comma-delimited)\n   * @prop {String} subject Subject line\n   * @prop {String} text Body text\n   * @prop {String} html Body HTML (optional)\n   * @param {Function} callback Called after the e-mail is sent or the sending failed\n   */\n\n  Email.send = function() {\n    throw new Error(g.f('You must connect the {{Email}} Model to a {{Mail}} connector'));\n  };\n\n  /**\n   * A shortcut for Email.send(this).\n   */\n  Email.prototype.send = function() {\n    throw new Error(g.f('You must connect the {{Email}} Model to a {{Mail}} connector'));\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/application.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar assert = require('assert');\nvar utils = require('../../lib/utils');\n\n/*!\n * Application management functions\n */\n\nvar crypto = require('crypto');\n\nfunction generateKey(hmacKey, algorithm, encoding) {\n  hmacKey = hmacKey || 'loopback';\n  algorithm = algorithm || 'sha1';\n  encoding = encoding || 'hex';\n  var hmac = crypto.createHmac(algorithm, hmacKey);\n  var buf = crypto.randomBytes(32);\n  hmac.update(buf);\n  var key = hmac.digest(encoding);\n  return key;\n}\n\n/**\n * Manage client applications and organize their users.\n *\n * @property {String} id  Generated ID.\n * @property {String} name Name; required.\n * @property {String} description Text description\n * @property {String} icon String Icon image URL.\n * @property {String} owner User ID of the developer who registers the application.\n * @property {String} email E-mail address\n * @property {Boolean} emailVerified Whether the e-mail is verified.\n * @property {String} url OAuth 2.0  application URL.\n * @property {String}[] callbackUrls The OAuth 2.0 code/token callback URL.\n * @property {String} status Status of the application; Either `production`, `sandbox` (default), or `disabled`.\n * @property {Date} created Date Application object was created.  Default: current date.\n * @property {Date} modified Date Application object was modified.  Default: current date.\n *\n * @property {Object} pushSettings.apns APNS configuration, see the options\n *   below and also\n *   https://github.com/argon/node-apn/blob/master/doc/apn.markdown\n * @property {Boolean} pushSettings.apns.production Whether to use production Apple Push Notification Service (APNS) servers to send push notifications.\n * If true, uses `gateway.push.apple.com:2195` and `feedback.push.apple.com:2196`.\n * If false, uses `gateway.sandbox.push.apple.com:2195` and `feedback.sandbox.push.apple.com:2196`\n * @property {String} pushSettings.apns.certData The certificate data loaded from the cert.pem file (APNS).\n * @property {String} pushSettings.apns.keyData The key data loaded from the key.pem file (APNS).\n * @property {String} pushSettings.apns.pushOptions.gateway (APNS).\n * @property {Number} pushSettings.apns.pushOptions.port (APNS).\n * @property {String} pushSettings.apns.feedbackOptions.gateway  (APNS).\n * @property {Number} pushSettings.apns.feedbackOptions.port (APNS).\n * @property {Boolean} pushSettings.apns.feedbackOptions.batchFeedback (APNS).\n * @property {Number} pushSettings.apns.feedbackOptions.interval (APNS).\n * @property {String} pushSettings.gcm.serverApiKey: Google Cloud Messaging API key.\n *\n * @property {Boolean} authenticationEnabled\n * @property {Boolean} anonymousAllowed\n * @property {Array} authenticationSchemes List of authentication schemes\n *  (see below).\n * @property {String} authenticationSchemes.scheme Scheme name.\n *   Supported values: `local`, `facebook`, `google`,\n *   `twitter`, `linkedin`, `github`.\n * @property {Object} authenticationSchemes.credential\n *   Scheme-specific credentials.\n *\n * @class Application\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(Application) {\n  /*!\n   * A hook to generate keys before creation\n   * @param next\n   */\n  Application.observe('before save', function(ctx, next) {\n    if (!ctx.instance) {\n      // Partial update - don't generate new keys\n      // NOTE(bajtos) This also means that an atomic updateOrCreate\n      // will not generate keys when a new record is creatd\n      return next();\n    }\n\n    var app = ctx.instance;\n    app.created = app.modified = new Date();\n    if (!app.id) {\n      app.id = generateKey('id', 'md5');\n    }\n    app.clientKey = generateKey('client');\n    app.javaScriptKey = generateKey('javaScript');\n    app.restApiKey = generateKey('restApi');\n    app.windowsKey = generateKey('windows');\n    app.masterKey = generateKey('master');\n    next();\n  });\n\n  /**\n   * Register a new application\n   * @param {String} owner Owner's user ID.\n   * @param {String} name  Name of the application\n   * @param {Object} options  Other options\n   * @callback {Function} callback  Callback function\n   * @param {Error} err\n   * @promise\n   */\n  Application.register = function(owner, name, options, cb) {\n    assert(owner, 'owner is required');\n    assert(name, 'name is required');\n\n    if (typeof options === 'function' && !cb) {\n      cb = options;\n      options = {};\n    }\n    cb = cb || utils.createPromiseCallback();\n\n    var props = {owner: owner, name: name};\n    for (var p in options) {\n      if (!(p in props)) {\n        props[p] = options[p];\n      }\n    }\n    this.create(props, cb);\n    return cb.promise;\n  };\n\n  /**\n   * Reset keys for the application instance\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n  Application.prototype.resetKeys = function(cb) {\n    this.clientKey = generateKey('client');\n    this.javaScriptKey = generateKey('javaScript');\n    this.restApiKey = generateKey('restApi');\n    this.windowsKey = generateKey('windows');\n    this.masterKey = generateKey('master');\n    this.modified = new Date();\n    this.save(cb);\n  };\n\n  /**\n   * Reset keys for a given application by the appId\n   * @param {Any} appId\n   * @callback {Function} callback\n   * @param {Error} err\n   * @promise\n   */\n  Application.resetKeys = function(appId, cb) {\n    cb = cb || utils.createPromiseCallback();\n    this.findById(appId, function(err, app) {\n      if (err) {\n        if (cb) cb(err, app);\n        return;\n      }\n      app.resetKeys(cb);\n    });\n    return cb.promise;\n  };\n\n  /**\n   * Authenticate the application id and key.\n   *\n   * @param {Any} appId\n   * @param {String} key\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {String} matched The matching key; one of:\n   * - clientKey\n   * - javaScriptKey\n   * - restApiKey\n   * - windowsKey\n   * - masterKey\n   * @promise\n   */\n  Application.authenticate = function(appId, key, cb) {\n    cb = cb || utils.createPromiseCallback();\n\n    this.findById(appId, function(err, app) {\n      if (err || !app) {\n        cb(err, null);\n        return cb.promise;\n      }\n      var result = null;\n      var keyNames = ['clientKey', 'javaScriptKey', 'restApiKey', 'windowsKey', 'masterKey'];\n      for (var i = 0; i < keyNames.length; i++) {\n        if (app[keyNames[i]] === key) {\n          result = {\n            application: app,\n            keyType: keyNames[i],\n          };\n          break;\n        }\n      }\n      cb(null, result);\n    });\n    return cb.promise;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/access-token.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module Dependencies.\n */\n\n'use strict';\nvar g = require('../../lib/globalize');\nvar loopback = require('../../lib/loopback');\nvar assert = require('assert');\nvar uid = require('uid2');\nvar DEFAULT_TOKEN_LEN = 64;\n\n/**\n * Token based authentication and access control.\n *\n * **Default ACLs**\n *\n *  - DENY EVERYONE `*`\n *  - ALLOW EVERYONE create\n *\n * @property {String} id Generated token ID.\n * @property {Number} ttl Time to live in seconds, 2 weeks by default.\n * @property {Date} created When the token was created.\n * @property {Object} settings Extends the `Model.settings` object.\n * @property {Number} settings.accessTokenIdLength Length of the base64-encoded string access token. Default value is 64.\n * Increase the length for a more secure access token.\n *\n * @class AccessToken\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(AccessToken) {\n  /**\n   * Anonymous Token\n   *\n   * ```js\n   * assert(AccessToken.ANONYMOUS.id === '$anonymous');\n   * ```\n   */\n\n  AccessToken.ANONYMOUS = new AccessToken({id: '$anonymous'});\n\n  /**\n   * Create a cryptographically random access token id.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {String} token\n   */\n\n  AccessToken.createAccessTokenId = function(fn) {\n    uid(this.settings.accessTokenIdLength || DEFAULT_TOKEN_LEN, function(err, guid) {\n      if (err) {\n        fn(err);\n      } else {\n        fn(null, guid);\n      }\n    });\n  };\n\n  /*!\n   * Hook to create accessToken id.\n   */\n  AccessToken.observe('before save', function(ctx, next) {\n    if (!ctx.instance || ctx.instance.id) {\n      // We are running a partial update or the instance already has an id\n      return next();\n    }\n\n    AccessToken.createAccessTokenId(function(err, id) {\n      if (err) return next(err);\n      ctx.instance.id = id;\n      next();\n    });\n  });\n\n  /**\n   * Find a token for the given `ServerRequest`.\n   *\n   * @param {ServerRequest} req\n   * @param {Object} [options] Options for finding the token\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {AccessToken} token\n   */\n\n  AccessToken.findForRequest = function(req, options, cb) {\n    if (cb === undefined && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    var id = tokenIdForRequest(req, options);\n\n    if (id) {\n      this.findById(id, function(err, token) {\n        if (err) {\n          cb(err);\n        } else if (token) {\n          token.validate(function(err, isValid) {\n            if (err) {\n              cb(err);\n            } else if (isValid) {\n              cb(null, token);\n            } else {\n              var e = new Error(g.f('Invalid Access Token'));\n              e.status = e.statusCode = 401;\n              e.code = 'INVALID_TOKEN';\n              cb(e);\n            }\n          });\n        } else {\n          cb();\n        }\n      });\n    } else {\n      process.nextTick(function() {\n        cb();\n      });\n    }\n  };\n\n  /**\n   * Validate the token.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Boolean} isValid\n   */\n\n  AccessToken.prototype.validate = function(cb) {\n    try {\n      assert(\n          this.created && typeof this.created.getTime === 'function',\n        'token.created must be a valid Date'\n      );\n      assert(this.ttl !== 0, 'token.ttl must be not be 0');\n      assert(this.ttl, 'token.ttl must exist');\n      assert(this.ttl >= -1, 'token.ttl must be >= -1');\n\n      var AccessToken = this.constructor;\n      var userRelation = AccessToken.relations.user; // may not be set up\n      var User = userRelation && userRelation.modelTo;\n\n      // redefine user model if accessToken's principalType is available\n      if (this.principalType) {\n        User = AccessToken.registry.findModel(this.principalType);\n        if (!User) {\n          process.nextTick(function() {\n            return cb(null, false);\n          });\n        }\n      }\n\n      var now = Date.now();\n      var created = this.created.getTime();\n      var elapsedSeconds = (now - created) / 1000;\n      var secondsToLive = this.ttl;\n      var eternalTokensAllowed = !!(User && User.settings.allowEternalTokens);\n      var isEternalToken = secondsToLive === -1;\n      var isValid = isEternalToken ?\n        eternalTokensAllowed :\n        elapsedSeconds < secondsToLive;\n\n      if (isValid) {\n        process.nextTick(function() {\n          cb(null, isValid);\n        });\n      } else {\n        this.destroy(function(err) {\n          cb(err, isValid);\n        });\n      }\n    } catch (e) {\n      process.nextTick(function() {\n        cb(e);\n      });\n    }\n  };\n\n  function tokenIdForRequest(req, options) {\n    var params = options.params || [];\n    var headers = options.headers || [];\n    var cookies = options.cookies || [];\n    var i = 0;\n    var length, id;\n\n    // https://github.com/strongloop/loopback/issues/1326\n    if (options.searchDefaultTokenKeys !== false) {\n      params = params.concat(['access_token']);\n      headers = headers.concat(['X-Access-Token', 'authorization']);\n      cookies = cookies.concat(['access_token', 'authorization']);\n    }\n\n    for (length = params.length; i < length; i++) {\n      var param = params[i];\n      // replacement for deprecated req.param()\n      id = req.params && req.params[param] !== undefined ? req.params[param] :\n        req.body && req.body[param] !== undefined ? req.body[param] :\n        req.query && req.query[param] !== undefined ? req.query[param] :\n        undefined;\n\n      if (typeof id === 'string') {\n        return id;\n      }\n    }\n\n    for (i = 0, length = headers.length; i < length; i++) {\n      id = req.header(headers[i]);\n\n      if (typeof id === 'string') {\n        // Add support for oAuth 2.0 bearer token\n        // http://tools.ietf.org/html/rfc6750\n        if (id.indexOf('Bearer ') === 0) {\n          id = id.substring(7);\n          // Decode from base64\n          var buf = new Buffer(id, 'base64');\n          id = buf.toString('utf8');\n        } else if (/^Basic /i.test(id)) {\n          id = id.substring(6);\n          id = (new Buffer(id, 'base64')).toString('utf8');\n          // The spec says the string is user:pass, so if we see both parts\n          // we will assume the longer of the two is the token, so we will\n          // extract \"a2b2c3\" from:\n          //   \"a2b2c3\"\n          //   \"a2b2c3:\"   (curl http://a2b2c3@localhost:3000/)\n          //   \"token:a2b2c3\" (curl http://token:a2b2c3@localhost:3000/)\n          //   \":a2b2c3\"\n          var parts = /^([^:]*):(.*)$/.exec(id);\n          if (parts) {\n            id = parts[2].length > parts[1].length ? parts[2] : parts[1];\n          }\n        }\n        return id;\n      }\n    }\n\n    if (req.signedCookies) {\n      for (i = 0, length = cookies.length; i < length; i++) {\n        id = req.signedCookies[cookies[i]];\n\n        if (typeof id === 'string') {\n          return id;\n        }\n      }\n    }\n    return null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/user.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module Dependencies.\n */\n\n'use strict';\nvar g = require('../../lib/globalize');\nvar isEmail = require('isemail');\nvar loopback = require('../../lib/loopback');\nvar utils = require('../../lib/utils');\nvar path = require('path');\nvar qs = require('querystring');\nvar SALT_WORK_FACTOR = 10;\nvar crypto = require('crypto');\nvar MAX_PASSWORD_LENGTH = 72;\nvar bcrypt;\ntry {\n  // Try the native module first\n  bcrypt = require('bcrypt');\n  // Browserify returns an empty object\n  if (bcrypt && typeof bcrypt.compare !== 'function') {\n    bcrypt = require('bcryptjs');\n  }\n} catch (err) {\n  // Fall back to pure JS impl\n  bcrypt = require('bcryptjs');\n}\n\nvar DEFAULT_TTL = 1209600; // 2 weeks in seconds\nvar DEFAULT_RESET_PW_TTL = 15 * 60; // 15 mins in seconds\nvar DEFAULT_MAX_TTL = 31556926; // 1 year in seconds\nvar assert = require('assert');\n\nvar debug = require('debug')('loopback:user');\n\n/**\n * Built-in User model.\n * Extends LoopBack [PersistedModel](#persistedmodel-new-persistedmodel).\n *\n * Default `User` ACLs.\n *\n * - DENY EVERYONE `*`\n * - ALLOW EVERYONE `create`\n * - ALLOW OWNER `deleteById`\n * - ALLOW EVERYONE `login`\n * - ALLOW EVERYONE `logout`\n * - ALLOW OWNER `findById`\n * - ALLOW OWNER `updateAttributes`\n *\n * @property {String} username Must be unique.\n * @property {String} password Hidden from remote clients.\n * @property {String} email Must be valid email.\n * @property {Boolean} emailVerified Set when a user's email has been verified via `confirm()`.\n * @property {String} verificationToken Set when `verify()` is called.\n * @property {String} realm The namespace the user belongs to. See [Partitioning users with realms](http://loopback.io/doc/en/lb2/Partitioning-users-with-realms.html) for details.\n * @property {Object} settings Extends the `Model.settings` object.\n * @property {Boolean} settings.emailVerificationRequired Require the email verification\n * process before allowing a login.\n * @property {Number} settings.ttl Default time to live (in seconds) for the `AccessToken` created by `User.login() / user.createAccessToken()`.\n * Default is `1209600` (2 weeks)\n * @property {Number} settings.maxTTL The max value a user can request a token to be alive / valid for.\n * Default is `31556926` (1 year)\n * @property {Boolean} settings.realmRequired Require a realm when logging in a user.\n * @property {String} settings.realmDelimiter When set a realm is required.\n * @property {Number} settings.resetPasswordTokenTTL Time to live for password reset `AccessToken`. Default is `900` (15 minutes).\n * @property {Number} settings.saltWorkFactor The `bcrypt` salt work factor. Default is `10`.\n * @property {Boolean} settings.caseSensitiveEmail Enable case sensitive email.\n *\n * @class User\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(User) {\n  /**\n   * Create access token for the logged in user. This method can be overridden to\n   * customize how access tokens are generated\n   *\n   * @param {Number} ttl The requested ttl\n   * @param {Object} [options] The options for access token, such as scope, appId\n   * @callback {Function} cb The callback function\n   * @param {String|Error} err The error string or object\n   * @param {AccessToken} token The generated access token object\n   * @promise\n   */\n  User.prototype.createAccessToken = function(ttl, options, cb) {\n    if (cb === undefined && typeof options === 'function') {\n      // createAccessToken(ttl, cb)\n      cb = options;\n      options = undefined;\n    }\n\n    cb = cb || utils.createPromiseCallback();\n\n    if (typeof ttl === 'object' && !options) {\n      // createAccessToken(options, cb)\n      options = ttl;\n      ttl = options.ttl;\n    }\n    options = options || {};\n    var userModel = this.constructor;\n    ttl = Math.min(ttl || userModel.settings.ttl, userModel.settings.maxTTL);\n    this.accessTokens.create({\n      ttl: ttl,\n    }, cb);\n    return cb.promise;\n  };\n\n  function splitPrincipal(name, realmDelimiter) {\n    var parts = [null, name];\n    if (!realmDelimiter) {\n      return parts;\n    }\n    var index = name.indexOf(realmDelimiter);\n    if (index !== -1) {\n      parts[0] = name.substring(0, index);\n      parts[1] = name.substring(index + realmDelimiter.length);\n    }\n    return parts;\n  }\n\n  /**\n   * Normalize the credentials\n   * @param {Object} credentials The credential object\n   * @param {Boolean} realmRequired\n   * @param {String} realmDelimiter The realm delimiter, if not set, no realm is needed\n   * @returns {Object} The normalized credential object\n   */\n  User.normalizeCredentials = function(credentials, realmRequired, realmDelimiter) {\n    var query = {};\n    credentials = credentials || {};\n    if (!realmRequired) {\n      if (credentials.email) {\n        query.email = credentials.email;\n      } else if (credentials.username) {\n        query.username = credentials.username;\n      }\n    } else {\n      if (credentials.realm) {\n        query.realm = credentials.realm;\n      }\n      var parts;\n      if (credentials.email) {\n        parts = splitPrincipal(credentials.email, realmDelimiter);\n        query.email = parts[1];\n        if (parts[0]) {\n          query.realm = parts[0];\n        }\n      } else if (credentials.username) {\n        parts = splitPrincipal(credentials.username, realmDelimiter);\n        query.username = parts[1];\n        if (parts[0]) {\n          query.realm = parts[0];\n        }\n      }\n    }\n    return query;\n  };\n\n  /**\n   * Login a user by with the given `credentials`.\n   *\n   * ```js\n   *    User.login({username: 'foo', password: 'bar'}, function (err, token) {\n  *      console.log(token.id);\n  *    });\n   * ```\n   *\n   * @param {Object} credentials username/password or email/password\n   * @param {String[]|String} [include] Optionally set it to \"user\" to include\n   * the user info\n   * @callback {Function} callback Callback function\n   * @param {Error} err Error object\n   * @param {AccessToken} token Access token if login is successful\n   * @promise\n   */\n\n  User.login = function(credentials, include, fn) {\n    var self = this;\n    if (typeof include === 'function') {\n      fn = include;\n      include = undefined;\n    }\n\n    fn = fn || utils.createPromiseCallback();\n\n    include = (include || '');\n    if (Array.isArray(include)) {\n      include = include.map(function(val) {\n        return val.toLowerCase();\n      });\n    } else {\n      include = include.toLowerCase();\n    }\n\n    var realmDelimiter;\n    // Check if realm is required\n    var realmRequired = !!(self.settings.realmRequired ||\n      self.settings.realmDelimiter);\n    if (realmRequired) {\n      realmDelimiter = self.settings.realmDelimiter;\n    }\n    var query = self.normalizeCredentials(credentials, realmRequired,\n      realmDelimiter);\n\n    if (realmRequired && !query.realm) {\n      var err1 = new Error(g.f('{{realm}} is required'));\n      err1.statusCode = 400;\n      err1.code = 'REALM_REQUIRED';\n      fn(err1);\n      return fn.promise;\n    }\n    if (!query.email && !query.username) {\n      var err2 = new Error(g.f('{{username}} or {{email}} is required'));\n      err2.statusCode = 400;\n      err2.code = 'USERNAME_EMAIL_REQUIRED';\n      fn(err2);\n      return fn.promise;\n    }\n\n    self.findOne({where: query}, function(err, user) {\n      var defaultError = new Error(g.f('login failed'));\n      defaultError.statusCode = 401;\n      defaultError.code = 'LOGIN_FAILED';\n\n      function tokenHandler(err, token) {\n        if (err) return fn(err);\n        if (Array.isArray(include) ? include.indexOf('user') !== -1 : include === 'user') {\n          // NOTE(bajtos) We can't set token.user here:\n          //  1. token.user already exists, it's a function injected by\n          //     \"AccessToken belongsTo User\" relation\n          //  2. ModelBaseClass.toJSON() ignores own properties, thus\n          //     the value won't be included in the HTTP response\n          // See also loopback#161 and loopback#162\n          token.__data.user = user;\n        }\n        fn(err, token);\n      }\n\n      if (err) {\n        debug('An error is reported from User.findOne: %j', err);\n        fn(defaultError);\n      } else if (user) {\n        user.hasPassword(credentials.password, function(err, isMatch) {\n          if (err) {\n            debug('An error is reported from User.hasPassword: %j', err);\n            fn(defaultError);\n          } else if (isMatch) {\n            if (self.settings.emailVerificationRequired && !user.emailVerified) {\n              // Fail to log in if email verification is not done yet\n              debug('User email has not been verified');\n              err = new Error(g.f('login failed as the email has not been verified'));\n              err.statusCode = 401;\n              err.code = 'LOGIN_FAILED_EMAIL_NOT_VERIFIED';\n              fn(err);\n            } else {\n              if (user.createAccessToken.length === 2) {\n                user.createAccessToken(credentials.ttl, tokenHandler);\n              } else {\n                user.createAccessToken(credentials.ttl, credentials, tokenHandler);\n              }\n            }\n          } else {\n            debug('The password is invalid for user %s', query.email || query.username);\n            fn(defaultError);\n          }\n        });\n      } else {\n        debug('No matching record is found for user %s', query.email || query.username);\n        fn(defaultError);\n      }\n    });\n    return fn.promise;\n  };\n\n  /**\n   * Logout a user with the given accessToken id.\n   *\n   * ```js\n   *    User.logout('asd0a9f8dsj9s0s3223mk', function (err) {\n  *      console.log(err || 'Logged out');\n  *    });\n   * ```\n   *\n   * @param {String} accessTokenID\n   * @callback {Function} callback\n   * @param {Error} err\n   * @promise\n   */\n\n  User.logout = function(tokenId, fn) {\n    fn = fn || utils.createPromiseCallback();\n\n    var err;\n    if (!tokenId) {\n      err = new Error(g.f('{{accessToken}} is required to logout'));\n      err.status = 401;\n      process.nextTick(fn, err);\n      return fn.promise;\n    }\n\n    this.relations.accessTokens.modelTo.destroyById(tokenId, function(err, info) {\n      if (err) {\n        fn(err);\n      } else if ('count' in info && info.count === 0) {\n        err = new Error(g.f('Could not find {{accessToken}}'));\n        err.status = 401;\n        fn(err);\n      } else {\n        fn();\n      }\n    });\n    return fn.promise;\n  };\n\n  User.observe('before delete', function(ctx, next) {\n    var AccessToken = ctx.Model.relations.accessTokens.modelTo;\n    var pkName = ctx.Model.definition.idName() || 'id';\n    ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {\n      if (err) return next(err);\n\n      var ids = list.map(function(u) { return u[pkName]; });\n      ctx.where = {};\n      ctx.where[pkName] = {inq: ids};\n\n      AccessToken.destroyAll({userId: {inq: ids}}, next);\n    });\n  });\n\n  /**\n   * Compare the given `password` with the users hashed password.\n   *\n   * @param {String} password The plain text password\n   * @callback {Function} callback Callback function\n   * @param {Error} err Error object\n   * @param {Boolean} isMatch Returns true if the given `password` matches record\n   * @promise\n   */\n\n  User.prototype.hasPassword = function(plain, fn) {\n    fn = fn || utils.createPromiseCallback();\n    if (this.password && plain) {\n      bcrypt.compare(plain, this.password, function(err, isMatch) {\n        if (err) return fn(err);\n        fn(null, isMatch);\n      });\n    } else {\n      fn(null, false);\n    }\n    return fn.promise;\n  };\n\n  /**\n   * Change this user's password.\n   *\n   * @param {*} userId Id of the user changing the password\n   * @param {string} oldPassword Current password, required in order\n   *   to strongly verify the identity of the requesting user\n   * @param {string} newPassword The new password to use.\n   * @param {object} [options]\n   * @callback {Function} callback\n   * @param {Error} err Error object\n   * @promise\n   */\n  User.changePassword = function(userId, oldPassword, newPassword, options, cb) {\n    if (cb === undefined && typeof options === 'function') {\n      cb = options;\n      options = undefined;\n    }\n    cb = cb || utils.createPromiseCallback();\n\n    // Make sure to use the constructor of the (sub)class\n    // where the method is invoked from (`this` instead of `User`)\n    this.findById(userId, options, (err, inst) => {\n      if (err) return cb(err);\n\n      if (!inst) {\n        const err = new Error(`User ${userId} not found`);\n        Object.assign(err, {\n          code: 'USER_NOT_FOUND',\n          statusCode: 401,\n        });\n        return cb(err);\n      }\n\n      inst.changePassword(oldPassword, newPassword, options, cb);\n    });\n\n    return cb.promise;\n  };\n\n  /**\n   * Change this user's password (prototype/instance version).\n   *\n   * @param {string} oldPassword Current password, required in order\n   *   to strongly verify the identity of the requesting user\n   * @param {string} newPassword The new password to use.\n   * @param {object} [options]\n   * @callback {Function} callback\n   * @param {Error} err Error object\n   * @promise\n   */\n  User.prototype.changePassword = function(oldPassword, newPassword, options, cb) {\n    if (cb === undefined && typeof options === 'function') {\n      cb = options;\n      options = undefined;\n    }\n    cb = cb || utils.createPromiseCallback();\n\n    this.hasPassword(oldPassword, (err, isMatch) => {\n      if (err) return cb(err);\n      if (!isMatch) {\n        const err = new Error('Invalid current password');\n        Object.assign(err, {\n          code: 'INVALID_PASSWORD',\n          statusCode: 400,\n        });\n        return cb(err);\n      }\n\n      try {\n        User.validatePassword(newPassword);\n      } catch (err) {\n        return cb(err);\n      }\n\n      const delta = {password: newPassword};\n      this.patchAttributes(delta, options, (err, updated) => cb(err));\n    });\n    return cb.promise;\n  };\n\n  /**\n   * Verify a user's identity by sending them a confirmation email.\n   *\n   * ```js\n   *    var options = {\n   *      type: 'email',\n   *      to: user.email,\n   *      template: 'verify.ejs',\n   *      redirect: '/',\n   *      tokenGenerator: function (user, cb) { cb(\"random-token\"); }\n   *    };\n   *\n   *    user.verify(options, next);\n   * ```\n   *\n   * @options {Object} options\n   * @property {String} type Must be 'email'.\n   * @property {String} to Email address to which verification email is sent.\n   * @property {String} from Sender email addresss, for example\n   *   `'noreply@myapp.com'`.\n   * @property {String} subject Subject line text.\n   * @property {String} text Text of email.\n   * @property {String} template Name of template that displays verification\n   *  page, for example, `'verify.ejs'.\n   * @property {Function} templateFn A function generating the email HTML body\n   * from `verify()` options object and generated attributes like `options.verifyHref`.\n   * It must accept the option object and a callback function with `(err, html)`\n   * as parameters\n   * @property {String} redirect Page to which user will be redirected after\n   *  they verify their email, for example `'/'` for root URI.\n   * @property {Function} generateVerificationToken A function to be used to\n   *  generate the verification token. It must accept the user object and a\n   *  callback function. This function should NOT add the token to the user\n   *  object, instead simply execute the callback with the token! User saving\n   *  and email sending will be handled in the `verify()` method.\n   * @callback {Function} fn Callback function.\n   * @param {Error} err Error object.\n   * @param {Object} object Contains email, token, uid.\n   * @promise\n   */\n\n  User.prototype.verify = function(options, fn) {\n    fn = fn || utils.createPromiseCallback();\n\n    var user = this;\n    var userModel = this.constructor;\n    var registry = userModel.registry;\n    var pkName = userModel.definition.idName() || 'id';\n    assert(typeof options === 'object', 'options required when calling user.verify()');\n    assert(options.type, 'You must supply a verification type (options.type)');\n    assert(options.type === 'email', 'Unsupported verification type');\n    assert(options.to || this.email,\n      'Must include options.to when calling user.verify() ' +\n      'or the user must have an email property');\n    assert(options.from, 'Must include options.from when calling user.verify()');\n\n    options.redirect = options.redirect || '/';\n    var defaultTemplate = path.join(__dirname, '..', '..', 'templates', 'verify.ejs');\n    options.template = path.resolve(options.template || defaultTemplate);\n    options.user = this;\n    options.protocol = options.protocol || 'http';\n\n    var app = userModel.app;\n    options.host = options.host || (app && app.get('host')) || 'localhost';\n    options.port = options.port || (app && app.get('port')) || 3000;\n    options.restApiRoot = options.restApiRoot || (app && app.get('restApiRoot')) || '/api';\n\n    var displayPort = (\n      (options.protocol === 'http' && options.port == '80') ||\n      (options.protocol === 'https' && options.port == '443')\n    ) ? '' : ':' + options.port;\n\n    var urlPath = joinUrlPath(\n      options.restApiRoot,\n      userModel.http.path,\n      userModel.sharedClass.findMethodByName('confirm').http.path\n    );\n\n    options.verifyHref = options.verifyHref ||\n      options.protocol +\n      '://' +\n      options.host +\n      displayPort +\n      urlPath +\n      '?' + qs.stringify({\n        uid: '' + options.user[pkName],\n        redirect: options.redirect,\n      });\n\n    options.templateFn = options.templateFn || createVerificationEmailBody;\n\n    // Email model\n    var Email =\n      options.mailer || this.constructor.email || registry.getModelByType(loopback.Email);\n\n    // Set a default token generation function if one is not provided\n    var tokenGenerator = options.generateVerificationToken || User.generateVerificationToken;\n    assert(typeof tokenGenerator === 'function', 'generateVerificationToken must be a function');\n\n    tokenGenerator(user, function(err, token) {\n      if (err) { return fn(err); }\n\n      user.verificationToken = token;\n      user.save(function(err) {\n        if (err) {\n          fn(err);\n        } else {\n          sendEmail(user);\n        }\n      });\n    });\n\n    // TODO - support more verification types\n    function sendEmail(user) {\n      options.verifyHref += '&token=' + user.verificationToken;\n\n      options.verificationToken = user.verificationToken;\n\n      options.text = options.text || g.f('Please verify your email by opening ' +\n        'this link in a web browser:\\n\\t%s', options.verifyHref);\n\n      options.text = options.text.replace(/\\{href\\}/g, options.verifyHref);\n\n      options.to = options.to || user.email;\n\n      options.subject = options.subject || g.f('Thanks for Registering');\n\n      options.headers = options.headers || {};\n\n      options.templateFn(options, function(err, html) {\n        if (err) {\n          fn(err);\n        } else {\n          setHtmlContentAndSend(html);\n        }\n      });\n\n      function setHtmlContentAndSend(html) {\n        options.html = html;\n\n        // Remove options.template to prevent rejection by certain\n        // nodemailer transport plugins.\n        delete options.template;\n\n        Email.send(options, function(err, email) {\n          if (err) {\n            fn(err);\n          } else {\n            fn(null, {email: email, token: user.verificationToken, uid: user[pkName]});\n          }\n        });\n      }\n    }\n    return fn.promise;\n  };\n\n  function createVerificationEmailBody(options, cb) {\n    var template = loopback.template(options.template);\n    var body = template(options);\n    cb(null, body);\n  }\n\n  /**\n   * A default verification token generator which accepts the user the token is\n   * being generated for and a callback function to indicate completion.\n   * This one uses the crypto library and 64 random bytes (converted to hex)\n   * for the token. When used in combination with the user.verify() method this\n   * function will be called with the `user` object as it's context (`this`).\n   *\n   * @param {object} user The User this token is being generated for.\n   * @param {Function} cb The generator must pass back the new token with this function call\n   */\n  User.generateVerificationToken = function(user, cb) {\n    crypto.randomBytes(64, function(err, buf) {\n      cb(err, buf && buf.toString('hex'));\n    });\n  };\n\n  /**\n   * Confirm the user's identity.\n   *\n   * @param {Any} userId\n   * @param {String} token The validation token\n   * @param {String} redirect URL to redirect the user to once confirmed\n   * @callback {Function} callback\n   * @param {Error} err\n   * @promise\n   */\n  User.confirm = function(uid, token, redirect, fn) {\n    fn = fn || utils.createPromiseCallback();\n    this.findById(uid, function(err, user) {\n      if (err) {\n        fn(err);\n      } else {\n        if (user && user.verificationToken === token) {\n          user.verificationToken = null;\n          user.emailVerified = true;\n          user.save(function(err) {\n            if (err) {\n              fn(err);\n            } else {\n              fn();\n            }\n          });\n        } else {\n          if (user) {\n            err = new Error(g.f('Invalid token: %s', token));\n            err.statusCode = 400;\n            err.code = 'INVALID_TOKEN';\n          } else {\n            err = new Error(g.f('User not found: %s', uid));\n            err.statusCode = 404;\n            err.code = 'USER_NOT_FOUND';\n          }\n          fn(err);\n        }\n      }\n    });\n    return fn.promise;\n  };\n\n  /**\n   * Create a short lived access token for temporary login. Allows users\n   * to change passwords if forgotten.\n   *\n   * @options {Object} options\n   * @prop {String} email The user's email address\n   * @property {String} realm The user's realm (optional)\n   * @callback {Function} callback\n   * @param {Error} err\n   * @promise\n   */\n\n  User.resetPassword = function(options, cb) {\n    cb = cb || utils.createPromiseCallback();\n    var UserModel = this;\n    var ttl = UserModel.settings.resetPasswordTokenTTL || DEFAULT_RESET_PW_TTL;\n    options = options || {};\n    if (typeof options.email !== 'string') {\n      var err = new Error(g.f('Email is required'));\n      err.statusCode = 400;\n      err.code = 'EMAIL_REQUIRED';\n      cb(err);\n      return cb.promise;\n    }\n\n    try {\n      if (options.password) {\n        UserModel.validatePassword(options.password);\n      }\n    } catch (err) {\n      return cb(err);\n    }\n    var where = {\n      email: options.email,\n    };\n    if (options.realm) {\n      where.realm = options.realm;\n    }\n    UserModel.findOne({where: where}, function(err, user) {\n      if (err) {\n        return cb(err);\n      }\n      if (!user) {\n        err = new Error(g.f('Email not found'));\n        err.statusCode = 404;\n        err.code = 'EMAIL_NOT_FOUND';\n        return cb(err);\n      }\n      // create a short lived access token for temp login to change password\n      // TODO(ritch) - eventually this should only allow password change\n      if (UserModel.settings.emailVerificationRequired && !user.emailVerified) {\n        err = new Error(g.f('Email has not been verified'));\n        err.statusCode = 401;\n        err.code = 'RESET_FAILED_EMAIL_NOT_VERIFIED';\n        return cb(err);\n      }\n\n      user.createAccessToken(ttl, function(err, accessToken) {\n        if (err) {\n          return cb(err);\n        }\n        cb();\n        UserModel.emit('resetPasswordRequest', {\n          email: options.email,\n          accessToken: accessToken,\n          user: user,\n          options: options,\n        });\n      });\n    });\n\n    return cb.promise;\n  };\n\n  /*!\n   * Hash the plain password\n   */\n  User.hashPassword = function(plain) {\n    this.validatePassword(plain);\n    var salt = bcrypt.genSaltSync(this.settings.saltWorkFactor || SALT_WORK_FACTOR);\n    return bcrypt.hashSync(plain, salt);\n  };\n\n  User.validatePassword = function(plain) {\n    var err;\n    if (plain && typeof plain === 'string' && plain.length <= MAX_PASSWORD_LENGTH) {\n      return true;\n    }\n    if (plain.length > MAX_PASSWORD_LENGTH) {\n      err = new Error(g.f('Password too long: %s', plain));\n      err.code = 'PASSWORD_TOO_LONG';\n    } else {\n      err =  new Error(g.f('Invalid password: %s', plain));\n      err.code = 'INVALID_PASSWORD';\n    }\n    err.statusCode = 422;\n    throw err;\n  };\n\n  User._invalidateAccessTokensOfUsers = function(userIds, options, cb) {\n    if (typeof options === 'function' && cb === undefined) {\n      cb = options;\n      options = {};\n    }\n\n    if (!Array.isArray(userIds) || !userIds.length)\n      return process.nextTick(cb);\n\n    var accessTokenRelation = this.relations.accessTokens;\n    if (!accessTokenRelation)\n      return process.nextTick(cb);\n\n    var AccessToken = accessTokenRelation.modelTo;\n    var query = {userId: {inq: userIds}};\n    var tokenPK = AccessToken.definition.idName() || 'id';\n    if (options.accessToken && tokenPK in options.accessToken) {\n      query[tokenPK] = {neq: options.accessToken[tokenPK]};\n    }\n    // add principalType in AccessToken.query if using polymorphic relations\n    // between AccessToken and User\n    var relatedUser = AccessToken.relations.user;\n    var isRelationPolymorphic = relatedUser && relatedUser.polymorphic &&\n      !relatedUser.modelTo;\n    if (isRelationPolymorphic) {\n      query.principalType = this.modelName;\n    }\n    AccessToken.deleteAll(query, options, cb);\n  };\n\n  /*!\n   * Setup an extended user model.\n   */\n\n  User.setup = function() {\n    // We need to call the base class's setup method\n    User.base.setup.call(this);\n    var UserModel = this;\n\n    // max ttl\n    this.settings.maxTTL = this.settings.maxTTL || DEFAULT_MAX_TTL;\n    this.settings.ttl = this.settings.ttl || DEFAULT_TTL;\n\n    UserModel.setter.email = function(value) {\n      if (!UserModel.settings.caseSensitiveEmail) {\n        this.$email = value.toLowerCase();\n      } else {\n        this.$email = value;\n      }\n    };\n\n    UserModel.setter.password = function(plain) {\n      if (typeof plain !== 'string') {\n        return;\n      }\n      if (plain.indexOf('$2a$') === 0 && plain.length === 60) {\n        // The password is already hashed. It can be the case\n        // when the instance is loaded from DB\n        this.$password = plain;\n      } else {\n        this.$password = this.constructor.hashPassword(plain);\n      }\n    };\n\n    // Make sure emailVerified is not set by creation\n    UserModel.beforeRemote('create', function(ctx, user, next) {\n      var body = ctx.req.body;\n      if (body && body.emailVerified) {\n        body.emailVerified = false;\n      }\n      next();\n    });\n\n    UserModel.remoteMethod(\n      'login',\n      {\n        description: 'Login a user with username/email and password.',\n        accepts: [\n          {arg: 'credentials', type: 'object', required: true, http: {source: 'body'}},\n          {arg: 'include', type: ['string'], http: {source: 'query'},\n            description: 'Related objects to include in the response. ' +\n            'See the description of return value for more details.'},\n        ],\n        returns: {\n          arg: 'accessToken', type: 'object', root: true,\n          description:\n            g.f('The response body contains properties of the {{AccessToken}} created on login.\\n' +\n            'Depending on the value of `include` parameter, the body may contain ' +\n            'additional properties:\\n\\n' +\n            '  - `user` - `U+007BUserU+007D` - Data of the currently logged in user. ' +\n            '{{(`include=user`)}}\\n\\n'),\n        },\n        http: {verb: 'post'},\n      }\n    );\n\n    UserModel.remoteMethod(\n      'logout',\n      {\n        description: 'Logout a user with access token.',\n        accepts: [\n          {arg: 'access_token', type: 'string', http: function(ctx) {\n            var req = ctx && ctx.req;\n            var accessToken = req && req.accessToken;\n            var tokenID = accessToken ? accessToken.id : undefined;\n\n            return tokenID;\n          }, description: 'Do not supply this argument, it is automatically extracted ' +\n            'from request headers.',\n          },\n        ],\n        http: {verb: 'all'},\n      }\n    );\n\n    UserModel.remoteMethod(\n      'confirm',\n      {\n        description: 'Confirm a user registration with email verification token.',\n        accepts: [\n          {arg: 'uid', type: 'string', required: true},\n          {arg: 'token', type: 'string', required: true},\n          {arg: 'redirect', type: 'string'},\n        ],\n        http: {verb: 'get', path: '/confirm'},\n      }\n    );\n\n    UserModel.remoteMethod(\n      'resetPassword',\n      {\n        description: 'Reset password for a user with email.',\n        accepts: [\n          {arg: 'options', type: 'object', required: true, http: {source: 'body'}},\n        ],\n        http: {verb: 'post', path: '/reset'},\n      }\n    );\n\n    UserModel.remoteMethod(\n      'changePassword',\n      {\n        description: 'Change a user\\'s password.',\n        accepts: [\n          {arg: 'id', type: 'any',\n            http: ctx => ctx.req.accessToken && ctx.req.accessToken.userId,\n          },\n          {arg: 'oldPassword', type: 'string', required: true, http: {source: 'form'}},\n          {arg: 'newPassword', type: 'string', required: true, http: {source: 'form'}},\n          {arg: 'options', type: 'object', http: 'optionsFromRequest'},\n        ],\n        http: {verb: 'POST', path: '/change-password'},\n      }\n    );\n\n    UserModel.afterRemote('confirm', function(ctx, inst, next) {\n      if (ctx.args.redirect !== undefined) {\n        if (!ctx.res) {\n          return next(new Error(g.f('The transport does not support HTTP redirects.')));\n        }\n        ctx.res.location(ctx.args.redirect);\n        ctx.res.status(302);\n      }\n      next();\n    });\n\n    // default models\n    assert(loopback.Email, 'Email model must be defined before User model');\n    UserModel.email = loopback.Email;\n\n    assert(loopback.AccessToken, 'AccessToken model must be defined before User model');\n    UserModel.accessToken = loopback.AccessToken;\n\n    UserModel.validate('email', emailValidator, {\n      message: g.f('Must provide a valid email'),\n    });\n\n    // Realm users validation\n    if (UserModel.settings.realmRequired && UserModel.settings.realmDelimiter) {\n      UserModel.validatesUniquenessOf('email', {\n        message: 'Email already exists',\n        scopedTo: ['realm'],\n      });\n      UserModel.validatesUniquenessOf('username', {\n        message: 'User already exists',\n        scopedTo: ['realm'],\n      });\n    } else {\n      // Regular(Non-realm) users validation\n      UserModel.validatesUniquenessOf('email', {message: 'Email already exists'});\n      UserModel.validatesUniquenessOf('username', {message: 'User already exists'});\n    }\n\n    return UserModel;\n  };\n\n  /*!\n   * Setup the base user.\n   */\n\n  User.setup();\n\n  // --- OPERATION HOOKS ---\n  //\n  // Important: Operation hooks are inherited by subclassed models,\n  // therefore they must be registered outside of setup() function\n\n  // Access token to normalize email credentials\n  User.observe('access', function normalizeEmailCase(ctx, next) {\n    if (!ctx.Model.settings.caseSensitiveEmail && ctx.query.where &&\n        ctx.query.where.email && typeof(ctx.query.where.email) === 'string') {\n      ctx.query.where.email = ctx.query.where.email.toLowerCase();\n    }\n    next();\n  });\n\n  User.observe('before save', function prepareForTokenInvalidation(ctx, next) {\n    if (ctx.isNewInstance) return next();\n    if (!ctx.where && !ctx.instance) return next();\n\n    var pkName = ctx.Model.definition.idName() || 'id';\n    var where = ctx.where;\n    if (!where) {\n      where = {};\n      where[pkName] = ctx.instance[pkName];\n    }\n\n    ctx.Model.find({where: where}, ctx.options, function(err, userInstances) {\n      if (err) return next(err);\n      ctx.hookState.originalUserData = userInstances.map(function(u) {\n        var user = {};\n        user[pkName] = u[pkName];\n        user.email = u.email;\n        user.password = u.password;\n        return user;\n      });\n      var emailChanged;\n      if (ctx.instance) {\n        emailChanged = ctx.instance.email !== ctx.hookState.originalUserData[0].email;\n        if (emailChanged && ctx.Model.settings.emailVerificationRequired) {\n          ctx.instance.emailVerified = false;\n        }\n      } else if (ctx.data.email) {\n        emailChanged = ctx.hookState.originalUserData.some(function(data) {\n          return data.email != ctx.data.email;\n        });\n        if (emailChanged && ctx.Model.settings.emailVerificationRequired) {\n          ctx.data.emailVerified = false;\n        }\n      }\n\n      next();\n    });\n  });\n\n  User.observe('after save', function invalidateOtherTokens(ctx, next) {\n    if (!ctx.instance && !ctx.data) return next();\n    if (!ctx.hookState.originalUserData) return next();\n\n    var pkName = ctx.Model.definition.idName() || 'id';\n    var newEmail = (ctx.instance || ctx.data).email;\n    var newPassword = (ctx.instance || ctx.data).password;\n\n    if (!newEmail && !newPassword) return next();\n\n    var userIdsToExpire = ctx.hookState.originalUserData.filter(function(u) {\n      return (newEmail && u.email !== newEmail) ||\n        (newPassword && u.password !== newPassword);\n    }).map(function(u) {\n      return u[pkName];\n    });\n    ctx.Model._invalidateAccessTokensOfUsers(userIdsToExpire, ctx.options, next);\n  });\n};\n\nfunction emailValidator(err, done) {\n  var value = this.email;\n  if (value == null)\n    return;\n  if (typeof value !== 'string')\n    return err('string');\n  if (value === '') return;\n  if (!isEmail.validate(value))\n    return err('email');\n}\n\nfunction joinUrlPath(args) {\n  var result = arguments[0];\n  for (var ix = 1; ix < arguments.length; ix++) {\n    var next = arguments[ix];\n    result += result[result.length - 1] === '/' && next[0] === '/' ?\n      next.slice(1) : next;\n  }\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/role-mapping.js":"// Copyright IBM Corp. 2014,2015. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar loopback = require('../../lib/loopback');\nvar utils = require('../../lib/utils');\n\n/**\n * The `RoleMapping` model extends from the built in `loopback.Model` type.\n *\n * @property {String} id Generated ID.\n * @property {String} name Name of the role.\n * @property {String} Description Text description.\n *\n * @class RoleMapping\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(RoleMapping) {\n  // Principal types\n  RoleMapping.USER = 'USER';\n  RoleMapping.APP = RoleMapping.APPLICATION = 'APP';\n  RoleMapping.ROLE = 'ROLE';\n\n  RoleMapping.resolveRelatedModels = function() {\n    if (!this.userModel) {\n      var reg = this.registry;\n      this.roleModel = reg.getModelByType('Role');\n      this.userModel = reg.getModelByType('User');\n      this.applicationModel = reg.getModelByType('Application');\n    }\n  };\n\n  /**\n   * Get the application principal\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Application} application\n   */\n  RoleMapping.prototype.application = function(callback) {\n    callback = callback || utils.createPromiseCallback();\n    this.constructor.resolveRelatedModels();\n\n    if (this.principalType === RoleMapping.APPLICATION) {\n      var applicationModel = this.constructor.applicationModel;\n      applicationModel.findById(this.principalId, callback);\n    } else {\n      process.nextTick(function() {\n        callback(null, null);\n      });\n    }\n    return callback.promise;\n  };\n\n  /**\n   * Get the user principal\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {User} user\n   */\n  RoleMapping.prototype.user = function(callback) {\n    callback = callback || utils.createPromiseCallback();\n    this.constructor.resolveRelatedModels();\n    var userModel;\n\n    if (this.principalType === RoleMapping.USER) {\n      userModel = this.constructor.userModel;\n      userModel.findById(this.principalId, callback);\n      return callback.promise;\n    }\n\n    // try resolving a user model that matches principalType\n    userModel = this.constructor.registry.findModel(this.principalType);\n    if (userModel) {\n      userModel.findById(this.principalId, callback);\n    } else {\n      process.nextTick(function() {\n        callback(null, null);\n      });\n    }\n    return callback.promise;\n  };\n\n  /**\n   * Get the child role principal\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {User} childUser\n   */\n  RoleMapping.prototype.childRole = function(callback) {\n    callback = callback || utils.createPromiseCallback();\n    this.constructor.resolveRelatedModels();\n\n    if (this.principalType === RoleMapping.ROLE) {\n      var roleModel = this.constructor.roleModel;\n      roleModel.findById(this.principalId, callback);\n    } else {\n      process.nextTick(function() {\n        callback(null, null);\n      });\n    }\n    return callback.promise;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/role.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar loopback = require('../../lib/loopback');\nvar debug = require('debug')('loopback:security:role');\nvar assert = require('assert');\nvar async = require('async');\nvar utils = require('../../lib/utils');\nvar ctx = require('../../lib/access-context');\nvar AccessContext = ctx.AccessContext;\nvar Principal = ctx.Principal;\nvar RoleMapping = loopback.RoleMapping;\n\nassert(RoleMapping, 'RoleMapping model must be defined before Role model');\n\n/**\n * The Role model\n * @class Role\n * @header Role object\n */\nmodule.exports = function(Role) {\n  Role.resolveRelatedModels = function() {\n    if (!this.userModel) {\n      var reg = this.registry;\n      this.roleMappingModel = reg.getModelByType('RoleMapping');\n      this.userModel = reg.getModelByType('User');\n      this.applicationModel = reg.getModelByType('Application');\n    }\n  };\n\n  // Set up the connection to users/applications/roles once the model\n  Role.once('dataSourceAttached', function(roleModel) {\n    ['users', 'applications', 'roles'].forEach(function(rel) {\n      /**\n       * Fetch all users assigned to this role\n       * @function Role.prototype#users\n       * @param {object} [query] query object passed to model find call\n       * @callback {Function} [callback] The callback function\n       * @param {String|Error} err The error string or object\n       * @param {Array} list The list of users.\n       * @promise\n       */\n      /**\n       * Fetch all applications assigned to this role\n       * @function Role.prototype#applications\n       * @param {object} [query] query object passed to model find call\n       * @callback {Function} [callback] The callback function\n       * @param {String|Error} err The error string or object\n       * @param {Array} list The list of applications.\n       * @promise\n       */\n      /**\n       * Fetch all roles assigned to this role\n       * @function Role.prototype#roles\n       * @param {object} [query] query object passed to model find call\n       * @callback {Function} [callback] The callback function\n       * @param {String|Error} err The error string or object\n       * @param {Array} list The list of roles.\n       * @promise\n       */\n      Role.prototype[rel] = function(query, callback) {\n        if (!callback) {\n          if (typeof query === 'function') {\n            callback = query;\n            query = {};\n          } else {\n            callback = utils.createPromiseCallback();\n          }\n        }\n        query = query || {};\n        query.where = query.where || {};\n\n        roleModel.resolveRelatedModels();\n        var relsToModels = {\n          users: roleModel.userModel,\n          applications: roleModel.applicationModel,\n          roles: roleModel,\n        };\n\n        var ACL = loopback.ACL;\n        var relsToTypes = {\n          users: ACL.USER,\n          applications: ACL.APP,\n          roles: ACL.ROLE,\n        };\n\n        var principalModel = relsToModels[rel];\n        var principalType = relsToTypes[rel];\n\n        // redefine user model and user type if user principalType is custom (available and not \"USER\")\n        var isCustomUserPrincipalType = rel === 'users' &&\n          query.where.principalType &&\n          query.where.principalType !== RoleMapping.USER;\n\n        if (isCustomUserPrincipalType) {\n          var registry = this.constructor.registry;\n          principalModel = registry.findModel(query.where.principalType);\n          principalType = query.where.principalType;\n        }\n        // make sure we don't keep principalType in userModel query\n        delete query.where.principalType;\n\n        if (principalModel) {\n          listByPrincipalType(this, principalModel, principalType, query, callback);\n        } else {\n          process.nextTick(function() {\n            callback(null, []);\n          });\n        }\n        return callback.promise;\n      };\n    });\n\n    /**\n     * Fetch all models assigned to this role\n     * @private\n     * @param {object} Context role context\n     * @param {*} model model type to fetch\n     * @param {String} [principalType] principalType used in the rolemapping for model\n     * @param {object} [query] query object passed to model find call\n     * @param  {Function} [callback] callback function called with `(err, models)` arguments.\n     */\n    function listByPrincipalType(context, model, principalType, query, callback) {\n      if (callback === undefined && typeof query === 'function') {\n        callback = query;\n        query = {};\n      }\n      query = query || {};\n\n      roleModel.roleMappingModel.find({\n        where: {roleId: context.id, principalType: principalType},\n      }, function(err, mappings) {\n        var ids;\n        if (err) {\n          return callback(err);\n        }\n        ids = mappings.map(function(m) {\n          return m.principalId;\n        });\n        query.where = query.where || {};\n        query.where.id = {inq: ids};\n        model.find(query, function(err, models) {\n          callback(err, models);\n        });\n      });\n    }\n  });\n\n  // Special roles\n  Role.OWNER = '$owner'; // owner of the object\n  Role.RELATED = '$related'; // any User with a relationship to the object\n  Role.AUTHENTICATED = '$authenticated'; // authenticated user\n  Role.UNAUTHENTICATED = '$unauthenticated'; // authenticated user\n  Role.EVERYONE = '$everyone'; // everyone\n\n  /**\n   * Add custom handler for roles.\n   * @param {String} role Name of role.\n   * @param {Function} resolver Function that determines\n   * if a principal is in the specified role.\n   * Should provide a callback or return a promise.\n   */\n  Role.registerResolver = function(role, resolver) {\n    if (!Role.resolvers) {\n      Role.resolvers = {};\n    }\n    Role.resolvers[role] = resolver;\n  };\n\n  Role.registerResolver(Role.OWNER, function(role, context, callback) {\n    if (!context || !context.model || !context.modelId) {\n      process.nextTick(function() {\n        if (callback) callback(null, false);\n      });\n      return;\n    }\n    var modelClass = context.model;\n    var modelId = context.modelId;\n    var user = context.getUser();\n    var userId = user && user.id;\n    var principalType = user && user.principalType;\n    var opts = {accessToken: context.accessToken};\n    Role.isOwner(modelClass, modelId, userId, principalType, opts, callback);\n  });\n\n  function isUserClass(modelClass) {\n    if (!modelClass) return false;\n    var User = modelClass.modelBuilder.models.User;\n    if (!User) return false;\n    return modelClass == User || modelClass.prototype instanceof User;\n  }\n\n  /*!\n   * Check if two user IDs matches\n   * @param {*} id1\n   * @param {*} id2\n   * @returns {boolean}\n   */\n  function matches(id1, id2) {\n    if (id1 === undefined || id1 === null || id1 === '' ||\n      id2 === undefined || id2 === null || id2 === '') {\n      return false;\n    }\n    // The id can be a MongoDB ObjectID\n    return id1 === id2 || id1.toString() === id2.toString();\n  }\n\n  /**\n   * Check if a given user ID is the owner the model instance.\n   * @param {Function} modelClass The model class\n   * @param {*} modelId The model ID\n   * @param {*} userId The user ID\n   * @param {String} principalType The user principalType (optional)\n   * @options {Object} options\n   * @property {accessToken} The access token used to authorize the current user.\n   * @callback {Function} [callback] The callback function\n   * @param {String|Error} err The error string or object\n   * @param {Boolean} isOwner True if the user is an owner.\n   * @promise\n   */\n  Role.isOwner = function isOwner(modelClass, modelId, userId, principalType, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else if (!callback && typeof principalType === 'function') {\n      callback = principalType;\n      principalType = undefined;\n      options = {};\n    }\n    principalType = principalType || Principal.USER;\n\n    assert(modelClass, 'Model class is required');\n    if (!callback) callback = utils.createPromiseCallback();\n\n    debug('isOwner(): %s %s userId: %s principalType: %s',\n      modelClass && modelClass.modelName, modelId, userId, principalType);\n\n    // Return false if userId is missing\n    if (!userId) {\n      process.nextTick(function() {\n        callback(null, false);\n      });\n      return callback.promise;\n    }\n\n    // Is the modelClass User or a subclass of User?\n    if (isUserClass(modelClass)) {\n      var userModelName = modelClass.modelName;\n      // matching ids is enough if principalType is USER or matches given user model name\n      if (principalType === Principal.USER || principalType === userModelName) {\n        process.nextTick(function() {\n          callback(null, matches(modelId, userId));\n        });\n      }\n      return callback.promise;\n    }\n\n    modelClass.findById(modelId, options, function(err, inst) {\n      if (err || !inst) {\n        debug('Model not found for id %j', modelId);\n        return callback(err, false);\n      }\n      debug('Model found: %j', inst);\n\n      // Historically, for principalType USER, we were resolving isOwner()\n      // as true if the model has \"userId\" or \"owner\" property matching\n      // id of the current user (principalId), even though there was no\n      // belongsTo relation set up.\n      var ownerId = inst.userId || inst.owner;\n      if (principalType === Principal.USER && ownerId && 'function' !== typeof ownerId) {\n        return callback(null, matches(ownerId, userId));\n      }\n\n      // Try to follow belongsTo\n      for (var r in modelClass.relations) {\n        var rel = modelClass.relations[r];\n        // relation should be belongsTo and target a User based class\n        var belongsToUser = rel.type === 'belongsTo' && isUserClass(rel.modelTo);\n        if (!belongsToUser) {\n          continue;\n        }\n        // checking related user\n        var userModelName = rel.modelTo.modelName;\n        if (principalType === Principal.USER || principalType === userModelName) {\n          debug('Checking relation %s to %s: %j', r, userModelName, rel);\n          inst[r](processRelatedUser);\n          return;\n        }\n      }\n      debug('No matching belongsTo relation found for model %j - user %j principalType %j',\n        modelId, userId, principalType);\n      callback(null, false);\n\n      function processRelatedUser(err, user) {\n        if (!err && user) {\n          debug('User found: %j', user.id);\n          callback(null, matches(user.id, userId));\n        } else {\n          callback(err, false);\n        }\n      }\n    });\n    return callback.promise;\n  };\n\n  Role.registerResolver(Role.AUTHENTICATED, function(role, context, callback) {\n    if (!context) {\n      process.nextTick(function() {\n        if (callback) callback(null, false);\n      });\n      return;\n    }\n    Role.isAuthenticated(context, callback);\n  });\n\n  /**\n   * Check if the user ID is authenticated\n   * @param {Object} context The security context.\n   *\n   * @callback {Function} callback Callback function.\n   * @param {Error} err Error object.\n   * @param {Boolean} isAuthenticated True if the user is authenticated.\n   * @promise\n   */\n  Role.isAuthenticated = function isAuthenticated(context, callback) {\n    if (!callback) callback = utils.createPromiseCallback();\n    process.nextTick(function() {\n      if (callback) callback(null, context.isAuthenticated());\n    });\n    return callback.promise;\n  };\n\n  Role.registerResolver(Role.UNAUTHENTICATED, function(role, context, callback) {\n    process.nextTick(function() {\n      if (callback) callback(null, !context || !context.isAuthenticated());\n    });\n  });\n\n  Role.registerResolver(Role.EVERYONE, function(role, context, callback) {\n    process.nextTick(function() {\n      if (callback) callback(null, true); // Always true\n    });\n  });\n\n  /**\n   * Check if a given principal is in the specified role.\n   *\n   * @param {String} role The role name.\n   * @param {Object} context The context object.\n   *\n   * @callback {Function} callback Callback function.\n   * @param {Error} err Error object.\n   * @param {Boolean} isInRole True if the principal is in the specified role.\n   * @promise\n   */\n  Role.isInRole = function(role, context, callback) {\n    context.registry = this.registry;\n    if (!(context instanceof AccessContext)) {\n      context = new AccessContext(context);\n    }\n\n    if (!callback) {\n      callback = utils.createPromiseCallback();\n      // historically, isInRole is returning the Role instance instead of true\n      // we are preserving that behaviour for callback-based invocation,\n      // but fixing it when invoked in Promise mode\n      callback.promise = callback.promise.then(function(isInRole) {\n        return !!isInRole;\n      });\n    }\n\n    this.resolveRelatedModels();\n\n    debug('isInRole(): %s', role);\n    context.debug();\n\n    var resolver = Role.resolvers[role];\n    if (resolver) {\n      debug('Custom resolver found for role %s', role);\n\n      var promise = resolver(role, context, callback);\n      if (promise && typeof promise.then === 'function') {\n        promise.then(\n          function(result) { callback(null, result); },\n          callback\n        );\n      }\n      return callback.promise;\n    }\n\n    if (context.principals.length === 0) {\n      debug('isInRole() returns: false');\n      process.nextTick(function() {\n        if (callback) callback(null, false);\n      });\n      return callback.promise;\n    }\n\n    var inRole = context.principals.some(function(p) {\n      var principalType = p.type || undefined;\n      var principalId = p.id || undefined;\n\n      // Check if it's the same role\n      return principalType === RoleMapping.ROLE && principalId === role;\n    });\n\n    if (inRole) {\n      debug('isInRole() returns: %j', inRole);\n      process.nextTick(function() {\n        if (callback) callback(null, true);\n      });\n      return callback.promise;\n    }\n\n    var roleMappingModel = this.roleMappingModel;\n    this.findOne({where: {name: role}}, function(err, result) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      if (!result) {\n        if (callback) callback(null, false);\n        return;\n      }\n      debug('Role found: %j', result);\n\n      // Iterate through the list of principals\n      async.some(context.principals, function(p, done) {\n        var principalType = p.type || undefined;\n        var principalId = p.id || undefined;\n        var roleId = result.id.toString();\n        var principalIdIsString = typeof principalId === 'string';\n\n        if (principalId !== null && principalId !== undefined && !principalIdIsString) {\n          principalId = principalId.toString();\n        }\n\n        if (principalType && principalId) {\n          roleMappingModel.findOne({where: {roleId: roleId,\n            principalType: principalType, principalId: principalId}},\n            function(err, result) {\n              debug('Role mapping found: %j', result);\n              done(!err && result); // The only arg is the result\n            });\n        } else {\n          process.nextTick(function() {\n            done(false);\n          });\n        }\n      }, function(inRole) {\n        debug('isInRole() returns: %j', inRole);\n        if (callback) callback(null, inRole);\n      });\n    });\n    return callback.promise;\n  };\n\n  /**\n   * List roles for a given principal.\n   * @param {Object} context The security context.\n   *\n   * @callback {Function} callback Callback function.\n   * @param {Error} err Error object.\n   * @param {String[]} roles An array of role IDs\n   * @promise\n   */\n  Role.getRoles = function(context, options, callback) {\n    if (!callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        callback = utils.createPromiseCallback();\n      }\n    }\n    if (!options) options = {};\n\n    context.registry = this.registry;\n    if (!(context instanceof AccessContext)) {\n      context = new AccessContext(context);\n    }\n    var roles = [];\n    this.resolveRelatedModels();\n\n    var addRole = function(role) {\n      if (role && roles.indexOf(role) === -1) {\n        roles.push(role);\n      }\n    };\n\n    var self = this;\n    // Check against the smart roles\n    var inRoleTasks = [];\n    Object.keys(Role.resolvers).forEach(function(role) {\n      inRoleTasks.push(function(done) {\n        self.isInRole(role, context, function(err, inRole) {\n          if (debug.enabled) {\n            debug('In role %j: %j', role, inRole);\n          }\n          if (!err && inRole) {\n            addRole(role);\n            done();\n          } else {\n            done(err, null);\n          }\n        });\n      });\n    });\n\n    var roleMappingModel = this.roleMappingModel;\n    context.principals.forEach(function(p) {\n      // Check against the role mappings\n      var principalType = p.type || undefined;\n      var principalId = p.id == null ? undefined : p.id;\n\n      if (typeof principalId !== 'string' && principalId != null) {\n        principalId = principalId.toString();\n      }\n\n      // Add the role itself\n      if (principalType === RoleMapping.ROLE && principalId) {\n        addRole(principalId);\n      }\n\n      if (principalType && principalId) {\n        // Please find() treat undefined matches all values\n        inRoleTasks.push(function(done) {\n          var filter = {where: {principalType: principalType, principalId: principalId}};\n          if (options.returnOnlyRoleNames === true) {\n            filter.include = ['role'];\n          }\n          roleMappingModel.find(filter, function(err, mappings) {\n            debug('Role mappings found: %s %j', err, mappings);\n            if (err) {\n              if (done) done(err);\n              return;\n            }\n            mappings.forEach(function(m) {\n              var role;\n              if (options.returnOnlyRoleNames === true) {\n                role = m.toJSON().role.name;\n              } else {\n                role = m.roleId;\n              }\n              addRole(role);\n            });\n            if (done) done();\n          });\n        });\n      }\n    });\n\n    async.parallel(inRoleTasks, function(err, results) {\n      debug('getRoles() returns: %j %j', err, roles);\n      if (callback) callback(err, roles);\n    });\n    return callback.promise;\n  };\n\n  Role.validatesUniquenessOf('name', {message: 'already exists'});\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/access-context.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar assert = require('assert');\nvar loopback = require('./loopback');\nvar debug = require('debug')('loopback:security:access-context');\n\n/**\n * Access context represents the context for a request to access protected\n * resources\n *\n * NOTE While the method expects an array of principals in the AccessContext instance/object,\n * it also accepts a single principal defined with the following properties:\n * ```js\n * {\n *   // AccessContext instance/object\n *   // ..\n *   principalType: 'somePrincipalType', // APP, ROLE, USER, or custom user model name\n *   principalId: 'somePrincipalId',\n * }\n * ```\n *\n * @class\n * @options {AccessContext|Object} context An AccessContext instance or an object\n * @property {Principal[]} principals An array of principals\n * @property {Function} model The model class\n * @property {String} modelName The model name\n * @property {*} modelId The model id\n * @property {String} property The model property/method/relation name\n * @property {String} method The model method to be invoked\n * @property {String} accessType The access type: READ, REPLICATE, WRITE, or EXECUTE.\n * @property {AccessToken} accessToken The access token resolved for the request\n * @property {RemotingContext} remotingContext The request's remoting context\n * @property {Registry} registry The application or global registry\n * @returns {AccessContext}\n * @constructor\n */\nfunction AccessContext(context) {\n  if (!(this instanceof AccessContext)) {\n    return new AccessContext(context);\n  }\n  context = context || {};\n\n  assert(context.registry,\n    'Application registry is mandatory in AccessContext but missing in provided context');\n  this.registry = context.registry;\n  this.principals = context.principals || [];\n  var model = context.model;\n  model = ('string' === typeof model) ? this.registry.getModel(model) : model;\n  this.model = model;\n  this.modelName = model && model.modelName;\n\n  this.modelId = context.id || context.modelId;\n  this.property = context.property || AccessContext.ALL;\n\n  this.method = context.method;\n  this.sharedMethod = context.sharedMethod;\n  this.sharedClass = this.sharedMethod && this.sharedMethod.sharedClass;\n  if (this.sharedMethod) {\n    this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);\n  } else {\n    this.methodNames = [];\n  }\n\n  if (this.sharedMethod) {\n    this.accessType = this.model._getAccessTypeForMethod(this.sharedMethod);\n  }\n\n  this.accessType = context.accessType || AccessContext.ALL;\n  assert(loopback.AccessToken,\n    'AccessToken model must be defined before AccessContext model');\n  this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;\n\n  var principalType = context.principalType || Principal.USER;\n  var principalId = context.principalId || undefined;\n  var principalName = context.principalName || undefined;\n\n  if (principalId) {\n    this.addPrincipal(principalType, principalId, principalName);\n  }\n\n  var token = this.accessToken || {};\n\n  if (token.userId) {\n    this.addPrincipal(Principal.USER, token.userId);\n  }\n  if (token.appId) {\n    this.addPrincipal(Principal.APPLICATION, token.appId);\n  }\n  this.remotingContext = context.remotingContext;\n}\n\n// Define constant for the wildcard\nAccessContext.ALL = '*';\n\n// Define constants for access types\nAccessContext.READ = 'READ'; // Read operation\nAccessContext.REPLICATE = 'REPLICATE'; // Replicate (pull) changes\nAccessContext.WRITE = 'WRITE'; // Write operation\nAccessContext.EXECUTE = 'EXECUTE'; // Execute operation\n\nAccessContext.DEFAULT = 'DEFAULT'; // Not specified\nAccessContext.ALLOW = 'ALLOW'; // Allow\nAccessContext.ALARM = 'ALARM'; // Warn - send an alarm\nAccessContext.AUDIT = 'AUDIT'; // Audit - record the access\nAccessContext.DENY = 'DENY'; // Deny\n\nAccessContext.permissionOrder = {\n  DEFAULT: 0,\n  ALLOW: 1,\n  ALARM: 2,\n  AUDIT: 3,\n  DENY: 4,\n};\n\n/**\n * Add a principal to the context\n * @param {String} principalType The principal type\n * @param {*} principalId The principal id\n * @param {String} [principalName] The principal name\n * @returns {boolean}\n */\nAccessContext.prototype.addPrincipal = function(principalType, principalId, principalName) {\n  var principal = new Principal(principalType, principalId, principalName);\n  for (var i = 0; i < this.principals.length; i++) {\n    var p = this.principals[i];\n    if (p.equals(principal)) {\n      return false;\n    }\n  }\n  this.principals.push(principal);\n  return true;\n};\n\n/**\n * Get the user id\n * @returns {*}\n */\nAccessContext.prototype.getUserId = function() {\n  var user = this.getUser();\n  return user && user.id;\n};\n\n/**\n * Get the user\n * @returns {*}\n */\nAccessContext.prototype.getUser = function() {\n  var BaseUser = this.registry.getModel('User');\n  for (var i = 0; i < this.principals.length; i++) {\n    var p = this.principals[i];\n    var isBuiltinPrincipal = p.type === Principal.APP ||\n      p.type === Principal.ROLE ||\n      p.type == Principal.SCOPE;\n    if (isBuiltinPrincipal) continue;\n\n    // the principalType must either be 'USER'\n    if (p.type === Principal.USER) {\n      return {id: p.id, principalType: p.type};\n    }\n\n    // or permit to resolve a valid user model\n    var userModel = this.registry.findModel(p.type);\n    if (!userModel) continue;\n    if (userModel.prototype instanceof BaseUser) {\n      return {id: p.id, principalType: p.type};\n    }\n  }\n};\n\n/**\n * Get the application id\n * @returns {*}\n */\nAccessContext.prototype.getAppId = function() {\n  for (var i = 0; i < this.principals.length; i++) {\n    var p = this.principals[i];\n    if (p.type === Principal.APPLICATION) {\n      return p.id;\n    }\n  }\n  return null;\n};\n\n/**\n * Check if the access context has authenticated principals\n * @returns {boolean}\n */\nAccessContext.prototype.isAuthenticated = function() {\n  return !!(this.getUserId() || this.getAppId());\n};\n\n/*!\n * Print debug info for access context.\n */\n\nAccessContext.prototype.debug = function() {\n  if (debug.enabled) {\n    debug('---AccessContext---');\n    if (this.principals && this.principals.length) {\n      debug('principals:');\n      this.principals.forEach(function(principal) {\n        debug('principal: %j', principal);\n      });\n    } else {\n      debug('principals: %j', this.principals);\n    }\n    debug('modelName %s', this.modelName);\n    debug('modelId %s', this.modelId);\n    debug('property %s', this.property);\n    debug('method %s', this.method);\n    debug('accessType %s', this.accessType);\n    if (this.accessToken) {\n      debug('accessToken:');\n      debug('  id %j', this.accessToken.id);\n      debug('  ttl %j', this.accessToken.ttl);\n    }\n    debug('getUserId() %s', this.getUserId());\n    debug('isAuthenticated() %s', this.isAuthenticated());\n  }\n};\n\n/**\n * This class represents the abstract notion of a principal, which can be used\n * to represent any entity, such as an individual, a corporation, and a login id\n * @param {String} type The principal type\n * @param {*} id The principal id\n * @param {String} [name] The principal name\n * @param {String} modelName The principal model name\n * @returns {Principal}\n * @class\n */\nfunction Principal(type, id, name) {\n  if (!(this instanceof Principal)) {\n    return new Principal(type, id, name);\n  }\n  this.type = type;\n  this.id = id;\n  this.name = name;\n}\n\n// Define constants for principal types\nPrincipal.USER = 'USER';\nPrincipal.APP = Principal.APPLICATION = 'APP';\nPrincipal.ROLE = 'ROLE';\nPrincipal.SCOPE = 'SCOPE';\n\n/**\n * Compare if two principals are equal\n * Returns true if argument principal is equal to this principal.\n * @param {Object} p The other principal\n */\nPrincipal.prototype.equals = function(p) {\n  if (p instanceof Principal) {\n    return this.type === p.type && String(this.id) === String(p.id);\n  }\n  return false;\n};\n\n/**\n * A request to access protected resources.\n *\n * The method can either be called with the following signature or with a single\n * argument: an AccessRequest instance or an object containing all the required properties.\n *\n * @class\n * @options {String|AccessRequest|Object} model|req The model name,<br>\n *    or an AccessRequest instance/object.\n * @param {String} property The property/method/relation name\n * @param {String} accessType The access type\n * @param {String} permission The requested permission\n * @param {String[]} methodNames The names of involved methods\n * @param {Registry} registry The application or global registry\n * @returns {AccessRequest}\n */\nfunction AccessRequest(model, property, accessType, permission, methodNames, registry) {\n  if (!(this instanceof AccessRequest)) {\n    return new AccessRequest(model, property, accessType, permission, methodNames);\n  }\n  if (arguments.length === 1 && typeof model === 'object') {\n    // The argument is an object that contains all required properties\n    var obj = model || {};\n    this.model = obj.model || AccessContext.ALL;\n    this.property = obj.property || AccessContext.ALL;\n    this.accessType = obj.accessType || AccessContext.ALL;\n    this.permission = obj.permission || AccessContext.DEFAULT;\n    this.methodNames = obj.methodNames || [];\n    this.registry = obj.registry;\n  } else {\n    this.model = model || AccessContext.ALL;\n    this.property = property || AccessContext.ALL;\n    this.accessType = accessType || AccessContext.ALL;\n    this.permission = permission || AccessContext.DEFAULT;\n    this.methodNames = methodNames || [];\n    this.registry = registry;\n  }\n  // do not create AccessRequest without a registry\n  assert(this.registry,\n    'Application registry is mandatory in AccessRequest but missing in provided argument(s)');\n}\n\n/**\n * Does the request contain any wildcards?\n *\n * @returns {Boolean}\n */\nAccessRequest.prototype.isWildcard = function() {\n  return this.model === AccessContext.ALL ||\n    this.property === AccessContext.ALL ||\n    this.accessType === AccessContext.ALL;\n};\n\n/**\n * Does the given `ACL` apply to this `AccessRequest`.\n *\n * @param {ACL} acl\n */\n\nAccessRequest.prototype.exactlyMatches = function(acl) {\n  var matchesModel = acl.model === this.model;\n  var matchesProperty = acl.property === this.property;\n  var matchesMethodName = this.methodNames.indexOf(acl.property) !== -1;\n  var matchesAccessType = acl.accessType === this.accessType;\n\n  if (matchesModel && matchesAccessType) {\n    return matchesProperty || matchesMethodName;\n  }\n\n  return false;\n};\n\n/**\n * Settle the accessRequest's permission if DEFAULT\n * In most situations, the default permission can be resolved from the nested model\n * config. An default permission can also be explicitly provided to override it or\n * cope with AccessRequest instances without a nested model (e.g. model is '*')\n *\n * @param {String} defaultPermission (optional) the default permission to apply\n */\n\nAccessRequest.prototype.settleDefaultPermission = function(defaultPermission) {\n  if (this.permission !== 'DEFAULT')\n    return;\n\n  var modelName = this.model;\n  if (!defaultPermission) {\n    var modelClass = this.registry.findModel(modelName);\n    defaultPermission = modelClass && modelClass.settings.defaultPermission;\n  }\n\n  this.permission = defaultPermission || 'ALLOW';\n};\n\n/**\n * Is the request for access allowed?\n *\n * @returns {Boolean}\n */\n\nAccessRequest.prototype.isAllowed = function() {\n  return this.permission !== loopback.ACL.DENY;\n};\n\nAccessRequest.prototype.debug = function() {\n  if (debug.enabled) {\n    debug('---AccessRequest---');\n    debug(' model %s', this.model);\n    debug(' property %s', this.property);\n    debug(' accessType %s', this.accessType);\n    debug(' permission %s', this.permission);\n    debug(' isWildcard() %s', this.isWildcard());\n    debug(' isAllowed() %s', this.isAllowed());\n  }\n};\n\nmodule.exports.AccessContext = AccessContext;\nmodule.exports.Principal = Principal;\nmodule.exports.AccessRequest = AccessRequest;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/acl.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n/*!\n Schema ACL options\n Object level permissions, for example, an album owned by a user\n Factors to be authorized against:\n * model name: Album\n * model instance properties: userId of the album, friends, shared\n * methods\n * app and/or user ids/roles\n ** loggedIn\n ** roles\n ** userId\n ** appId\n ** none\n ** everyone\n ** relations: owner/friend/granted\n Class level permissions, for example, Album\n * model name: Album\n * methods\n URL/Route level permissions\n * url pattern\n * application id\n * ip addresses\n * http headers\n Map to oAuth 2.0 scopes\n */\n\nvar g = require('../../lib/globalize');\nvar loopback = require('../../lib/loopback');\nvar utils = require('../../lib/utils');\nvar async = require('async');\nvar extend = require('util')._extend;\nvar assert = require('assert');\nvar debug = require('debug')('loopback:security:acl');\n\nvar ctx = require('../../lib/access-context');\nvar AccessContext = ctx.AccessContext;\nvar Principal = ctx.Principal;\nvar AccessRequest = ctx.AccessRequest;\n\nvar Role = loopback.Role;\nassert(Role, 'Role model must be defined before ACL model');\n\n/**\n * A Model for access control meta data.\n *\n * System grants permissions to principals (users/applications, can be grouped\n * into roles).\n *\n * Protected resource: the model data and operations\n * (model/property/method/relation/)\n *\n * For a given principal, such as client application and/or user, is it allowed\n * to access (read/write/execute)\n * the protected resource?\n *\n * @header ACL\n * @property {String} model Name of the model.\n * @property {String} property Name of the property, method, scope, or relation.\n * @property {String} accessType Type of access being granted: one of READ, WRITE, or EXECUTE.\n * @property {String} permission Type of permission granted. One of:\n *\n *  - ALARM: Generate an alarm, in a system-dependent way, the access specified in the permissions component of the ACL entry.\n *  - ALLOW: Explicitly grants access to the resource.\n *  - AUDIT: Log, in a system-dependent way, the access specified in the permissions component of the ACL entry.\n *  - DENY: Explicitly denies access to the resource.\n * @property {String} principalType Type of the principal; one of: Application, User, Role.\n * @property {String} principalId ID of the principal - such as appId, userId or roleId.\n * @property {Object} settings Extends the `Model.settings` object.\n * @property {String} settings.defaultPermission Default permission setting: ALLOW, DENY, ALARM, or AUDIT. Default is ALLOW.\n * Set to DENY to prohibit all API access by default.\n *\n * @class ACL\n * @inherits PersistedModel\n */\n\nmodule.exports = function(ACL) {\n  ACL.ALL = AccessContext.ALL;\n\n  ACL.DEFAULT = AccessContext.DEFAULT; // Not specified\n  ACL.ALLOW = AccessContext.ALLOW; // Allow\n  ACL.ALARM = AccessContext.ALARM; // Warn - send an alarm\n  ACL.AUDIT = AccessContext.AUDIT; // Audit - record the access\n  ACL.DENY = AccessContext.DENY; // Deny\n\n  ACL.READ = AccessContext.READ; // Read operation\n  ACL.REPLICATE = AccessContext.REPLICATE; // Replicate (pull) changes\n  ACL.WRITE = AccessContext.WRITE; // Write operation\n  ACL.EXECUTE = AccessContext.EXECUTE; // Execute operation\n\n  ACL.USER = Principal.USER;\n  ACL.APP = ACL.APPLICATION = Principal.APPLICATION;\n  ACL.ROLE = Principal.ROLE;\n  ACL.SCOPE = Principal.SCOPE;\n\n  /**\n   * Calculate the matching score for the given rule and request\n   * @param {ACL} rule The ACL entry\n   * @param {AccessRequest} req The request\n   * @returns {Number}\n   */\n  ACL.getMatchingScore = function getMatchingScore(rule, req) {\n    var props = ['model', 'property', 'accessType'];\n    var score = 0;\n\n    for (var i = 0; i < props.length; i++) {\n      // Shift the score by 4 for each of the properties as the weight\n      score = score * 4;\n      var ruleValue = rule[props[i]] || ACL.ALL;\n      var requestedValue = req[props[i]] || ACL.ALL;\n      var isMatchingMethodName = props[i] === 'property' &&\n        req.methodNames.indexOf(ruleValue) !== -1;\n\n      var isMatchingAccessType = ruleValue === requestedValue;\n      if (props[i] === 'accessType' && !isMatchingAccessType) {\n        switch (ruleValue) {\n          case ACL.EXECUTE:\n            // EXECUTE should match READ, REPLICATE and WRITE\n            isMatchingAccessType = true;\n            break;\n          case ACL.WRITE:\n            // WRITE should match REPLICATE too\n            isMatchingAccessType = requestedValue === ACL.REPLICATE;\n            break;\n        }\n      }\n\n      if (isMatchingMethodName || isMatchingAccessType) {\n        // Exact match\n        score += 3;\n      } else if (ruleValue === ACL.ALL) {\n        // Wildcard match\n        score += 2;\n      } else if (requestedValue === ACL.ALL) {\n        score += 1;\n      } else {\n        // Doesn't match at all\n        return -1;\n      }\n    }\n\n    // Weigh against the principal type into 4 levels\n    // - user level (explicitly allow/deny a given user)\n    // - app level (explicitly allow/deny a given app)\n    // - role level (role based authorization)\n    // - other\n    // user > app > role > ...\n    score = score * 4;\n    switch (rule.principalType) {\n      case ACL.USER:\n        score += 4;\n        break;\n      case ACL.APP:\n        score += 3;\n        break;\n      case ACL.ROLE:\n        score += 2;\n        break;\n      default:\n        score += 1;\n    }\n\n    // Weigh against the roles\n    // everyone < authenticated/unauthenticated < related < owner < ...\n    score = score * 8;\n    if (rule.principalType === ACL.ROLE) {\n      switch (rule.principalId) {\n        case Role.OWNER:\n          score += 4;\n          break;\n        case Role.RELATED:\n          score += 3;\n          break;\n        case Role.AUTHENTICATED:\n        case Role.UNAUTHENTICATED:\n          score += 2;\n          break;\n        case Role.EVERYONE:\n          score += 1;\n          break;\n        default:\n          score += 5;\n      }\n    }\n    score = score * 4;\n    score += AccessContext.permissionOrder[rule.permission || ACL.ALLOW] - 1;\n    return score;\n  };\n\n  /**\n   * Get matching score for the given `AccessRequest`.\n   * @param {AccessRequest} req The request\n   * @returns {Number} score\n   */\n\n  ACL.prototype.score = function(req) {\n    return this.constructor.getMatchingScore(this, req);\n  };\n\n  /*!\n   * Resolve permission from the ACLs\n   * @param {Object[]) acls The list of ACLs\n   * @param {AccessRequest} req The access request\n   * @returns {AccessRequest} result The resolved access request\n   */\n  ACL.resolvePermission = function resolvePermission(acls, req) {\n    if (!(req instanceof AccessRequest)) {\n      req.registry = this.registry;\n      req = new AccessRequest(req);\n    }\n    // Sort by the matching score in descending order\n    acls = acls.sort(function(rule1, rule2) {\n      return ACL.getMatchingScore(rule2, req) - ACL.getMatchingScore(rule1, req);\n    });\n    var permission = ACL.DEFAULT;\n    var score = 0;\n\n    for (var i = 0; i < acls.length; i++) {\n      var candidate = acls[i];\n      score = ACL.getMatchingScore(candidate, req);\n      if (score < 0) {\n        // the highest scored ACL did not match\n        break;\n      }\n      if (!req.isWildcard()) {\n        // We should stop from the first match for non-wildcard\n        permission = candidate.permission;\n        break;\n      } else {\n        if (req.exactlyMatches(candidate)) {\n          permission = candidate.permission;\n          break;\n        }\n        // For wildcard match, find the strongest permission\n        var candidateOrder = AccessContext.permissionOrder[candidate.permission];\n        var permissionOrder = AccessContext.permissionOrder[permission];\n        if (candidateOrder > permissionOrder) {\n          permission = candidate.permission;\n        }\n      }\n    }\n\n    if (debug.enabled) {\n      debug('The following ACLs were searched: ');\n      acls.forEach(function(acl) {\n        acl.debug();\n        debug('with score:', acl.score(req));\n      });\n    }\n    var res = new AccessRequest({\n      model: req.model,\n      property: req.property,\n      accessType: req.accessType,\n      permission: permission || ACL.DEFAULT,\n      registry: this.registry});\n\n    // Elucidate permission status if DEFAULT\n    res.settleDefaultPermission();\n\n    return res;\n  };\n\n  /*!\n   * Get the static ACLs from the model definition\n   * @param {String} model The model name\n   * @param {String} property The property/method/relation name\n   *\n   * @return {Object[]} An array of ACLs\n   */\n  ACL.getStaticACLs = function getStaticACLs(model, property) {\n    var modelClass = this.registry.findModel(model);\n    var staticACLs = [];\n    if (modelClass && modelClass.settings.acls) {\n      modelClass.settings.acls.forEach(function(acl) {\n        var prop = acl.property;\n        // We support static ACL property with array of string values.\n        if (Array.isArray(prop) && prop.indexOf(property) >= 0)\n          prop = property;\n        if (!prop || prop === ACL.ALL || property === prop) {\n          staticACLs.push(new ACL({\n            model: model,\n            property: prop || ACL.ALL,\n            principalType: acl.principalType,\n            principalId: acl.principalId, // TODO: Should it be a name?\n            accessType: acl.accessType || ACL.ALL,\n            permission: acl.permission,\n          }));\n        }\n      });\n    }\n    var prop = modelClass && (\n      // regular property\n      modelClass.definition.properties[property] ||\n      // relation/scope\n      (modelClass._scopeMeta && modelClass._scopeMeta[property]) ||\n      // static method\n      modelClass[property] ||\n      // prototype method\n      modelClass.prototype[property]);\n    if (prop && prop.acls) {\n      prop.acls.forEach(function(acl) {\n        staticACLs.push(new ACL({\n          model: modelClass.modelName,\n          property: property,\n          principalType: acl.principalType,\n          principalId: acl.principalId,\n          accessType: acl.accessType,\n          permission: acl.permission,\n        }));\n      });\n    }\n    return staticACLs;\n  };\n\n  /**\n   * Check if the given principal is allowed to access the model/property\n   * @param {String} principalType The principal type.\n   * @param {String} principalId The principal ID.\n   * @param {String} model The model name.\n   * @param {String} property The property/method/relation name.\n   * @param {String} accessType The access type.\n   * @callback {Function} callback Callback function.\n   * @param {String|Error} err The error object.\n   * @param {AccessRequest} result The resolved access request.\n   */\n  ACL.checkPermission = function checkPermission(principalType, principalId,\n                                                 model, property, accessType,\n                                                 callback) {\n    if (!callback) callback = utils.createPromiseCallback();\n    if (principalId !== null && principalId !== undefined && (typeof principalId !== 'string')) {\n      principalId = principalId.toString();\n    }\n    property = property || ACL.ALL;\n    var propertyQuery = (property === ACL.ALL) ? undefined : {inq: [property, ACL.ALL]};\n    accessType = accessType || ACL.ALL;\n    var accessTypeQuery = (accessType === ACL.ALL) ? undefined :\n      {inq: [accessType, ACL.ALL, ACL.EXECUTE]};\n\n    var req = new AccessRequest({model, property, accessType, registry: this.registry});\n\n    var acls = this.getStaticACLs(model, property);\n\n    // resolved is an instance of AccessRequest\n    var resolved = this.resolvePermission(acls, req);\n\n    if (resolved && resolved.permission === ACL.DENY) {\n      debug('Permission denied by statically resolved permission');\n      debug(' Resolved Permission: %j', resolved);\n      process.nextTick(function() {\n        callback(null, resolved);\n      });\n      return callback.promise;\n    }\n\n    var self = this;\n    this.find({where: {principalType: principalType, principalId: principalId,\n      model: model, property: propertyQuery, accessType: accessTypeQuery}},\n      function(err, dynACLs) {\n        if (err) {\n          return callback(err);\n        }\n        acls = acls.concat(dynACLs);\n        // resolved is an instance of AccessRequest\n        resolved = self.resolvePermission(acls, req);\n        return callback(null, resolved);\n      });\n    return callback.promise;\n  };\n\n  ACL.prototype.debug = function() {\n    if (debug.enabled) {\n      debug('---ACL---');\n      debug('model %s', this.model);\n      debug('property %s', this.property);\n      debug('principalType %s', this.principalType);\n      debug('principalId %s', this.principalId);\n      debug('accessType %s', this.accessType);\n      debug('permission %s', this.permission);\n    }\n  };\n\n  // NOTE Regarding ACL.isAllowed() and ACL.prototype.isAllowed()\n  // Extending existing logic, including from ACL.checkAccessForContext() method,\n  // ACL instance with missing property `permission` are not promoted to\n  // permission = ACL.DEFAULT config. Such ACL instances will hence always be\n  // inefective\n\n  /**\n   * Test if ACL's permission is ALLOW\n   * @param {String} permission The permission to test, expects one of 'ALLOW', 'DENY', 'DEFAULT'\n   * @param {String} defaultPermission The default permission to apply if not providing a finite one in the permission parameter\n   * @returns {Boolean} true if ACL permission is ALLOW\n   */\n  ACL.isAllowed = function(permission, defaultPermission) {\n    if (permission === ACL.DEFAULT) {\n      permission = defaultPermission || ACL.ALLOW;\n    }\n    return permission !== loopback.ACL.DENY;\n  };\n\n  /**\n   * Test if ACL's permission is ALLOW\n   * @param {String} defaultPermission The default permission to apply if missing in ACL instance\n   * @returns {Boolean} true if ACL permission is ALLOW\n   */\n  ACL.prototype.isAllowed = function(defaultPermission) {\n    return this.constructor.isAllowed(this.permission, defaultPermission);\n  };\n\n  /**\n   * Check if the request has the permission to access.\n   * @options {AccessContext|Object} context\n   * An AccessContext instance or a plain object with the following properties.\n   * @property {Object[]} principals An array of principals.\n   * @property {String|Model} model The model name or model class.\n   * @property {*} modelId The model instance ID.\n   * @property {String} property The property/method/relation name.\n   * @property {String} accessType The access type:\n   * READ, REPLICATE, WRITE, or EXECUTE.\n   * @callback {Function} callback Callback function\n   * @param {String|Error} err The error object.\n   * @param {AccessRequest} result The resolved access request.\n   */\n  ACL.checkAccessForContext = function(context, callback) {\n    if (!callback) callback = utils.createPromiseCallback();\n    var self = this;\n    self.resolveRelatedModels();\n    var roleModel = self.roleModel;\n\n    if (!(context instanceof AccessContext)) {\n      context.registry = this.registry;\n      context = new AccessContext(context);\n    }\n\n    var authorizedRoles = {};\n    var remotingContext = context.remotingContext;\n    var model = context.model;\n    var modelDefaultPermission = model && model.settings.defaultPermission;\n    var property = context.property;\n    var accessType = context.accessType;\n    var modelName = context.modelName;\n\n    var methodNames = context.methodNames;\n    var propertyQuery = (property === ACL.ALL) ? undefined : {inq: methodNames.concat([ACL.ALL])};\n\n    var accessTypeQuery = (accessType === ACL.ALL) ?\n      undefined :\n      (accessType === ACL.REPLICATE) ?\n        {inq: [ACL.REPLICATE, ACL.WRITE, ACL.ALL]} :\n        {inq: [accessType, ACL.ALL]};\n\n    var req = new AccessRequest({\n      model: modelName,\n      property,\n      accessType,\n      permission: ACL.DEFAULT,\n      methodNames,\n      registry: this.registry});\n\n    var effectiveACLs = [];\n    var staticACLs = self.getStaticACLs(model.modelName, property);\n\n    this.find({where: {model: model.modelName, property: propertyQuery,\n      accessType: accessTypeQuery}}, function(err, acls) {\n      if (err) return callback(err);\n      var inRoleTasks = [];\n\n      acls = acls.concat(staticACLs);\n\n      acls.forEach(function(acl) {\n        // Check exact matches\n        for (var i = 0; i < context.principals.length; i++) {\n          var p = context.principals[i];\n          var typeMatch = p.type === acl.principalType;\n          var idMatch = String(p.id) === String(acl.principalId);\n          if (typeMatch && idMatch) {\n            effectiveACLs.push(acl);\n            return;\n          }\n        }\n\n        // Check role matches\n        if (acl.principalType === ACL.ROLE) {\n          inRoleTasks.push(function(done) {\n            roleModel.isInRole(acl.principalId, context,\n              function(err, inRole) {\n                if (!err && inRole) {\n                  effectiveACLs.push(acl);\n                  // add the role to authorizedRoles if allowed\n                  if (acl.isAllowed(modelDefaultPermission))\n                    authorizedRoles[acl.principalId] = true;\n                }\n                done(err, acl);\n              });\n          });\n        }\n      });\n\n      async.parallel(inRoleTasks, function(err, results) {\n        if (err) return callback(err, null);\n\n        // resolved is an instance of AccessRequest\n        var resolved = self.resolvePermission(effectiveACLs, req);\n        debug('---Resolved---');\n        resolved.debug();\n\n        // set authorizedRoles in remotingContext options argument if\n        // resolved AccessRequest permission is ALLOW, else set it to empty object\n        authorizedRoles = resolved.isAllowed() ? authorizedRoles : {};\n        saveAuthorizedRolesToRemotingContext(remotingContext, authorizedRoles);\n        return callback(null, resolved);\n      });\n    });\n    return callback.promise;\n  };\n\n  function saveAuthorizedRolesToRemotingContext(remotingContext, authorizedRoles) {\n    const options = remotingContext && remotingContext.args && remotingContext.args.options;\n    // authorizedRoles key/value map is added to the options argument only if\n    // the latter exists and is an object. This means that the feature's availability\n    // will depend on the app configuration\n    if (options && typeof options === 'object') { // null is object too\n      options.authorizedRoles = authorizedRoles;\n    }\n  }\n\n  /**\n   * Check if the given access token can invoke the method\n   * @param {AccessToken} token The access token\n   * @param {String} model The model name\n   * @param {*} modelId The model id\n   * @param {String} method The method name\n   * @callback {Function} callback Callback function\n   * @param {String|Error} err The error object\n   * @param {Boolean} allowed is the request allowed\n   */\n  ACL.checkAccessForToken = function(token, model, modelId, method, callback) {\n    assert(token, 'Access token is required');\n    if (!callback) callback = utils.createPromiseCallback();\n    var context = new AccessContext({\n      registry: this.registry,\n      accessToken: token,\n      model: model,\n      property: method,\n      method: method,\n      modelId: modelId,\n    });\n\n    this.checkAccessForContext(context, function(err, accessRequest) {\n      if (err) callback(err);\n      else callback(null, accessRequest.isAllowed());\n    });\n    return callback.promise;\n  };\n\n  ACL.resolveRelatedModels = function() {\n    if (!this.roleModel) {\n      var reg = this.registry;\n      this.roleModel = reg.getModelByType('Role');\n      this.roleMappingModel = reg.getModelByType('RoleMapping');\n      this.userModel = reg.getModelByType('User');\n      this.applicationModel = reg.getModelByType('Application');\n    }\n  };\n\n  /**\n   * Resolve a principal by type/id\n   * @param {String} type Principal type - ROLE/APP/USER\n   * @param {String|Number} id Principal id or name\n   * @callback {Function} callback Callback function\n   * @param {String|Error} err The error object\n   * @param {Object} result An instance of principal (Role, Application or User)\n   */\n  ACL.resolvePrincipal = function(type, id, cb) {\n    cb = cb || utils.createPromiseCallback();\n    type = type || ACL.ROLE;\n    this.resolveRelatedModels();\n\n    switch (type) {\n      case ACL.ROLE:\n        this.roleModel.findOne({where: {or: [{name: id}, {id: id}]}}, cb);\n        break;\n      case ACL.USER:\n        this.userModel.findOne(\n          {where: {or: [{username: id}, {email: id}, {id: id}]}}, cb);\n        break;\n      case ACL.APP:\n        this.applicationModel.findOne(\n          {where: {or: [{name: id}, {email: id}, {id: id}]}}, cb);\n        break;\n      default:\n        // try resolving a user model with a name matching the principalType\n        var userModel = this.registry.findModel(type);\n        if (userModel) {\n          userModel.findOne(\n            {where: {or: [{username: id}, {email: id}, {id: id}]}},\n            cb);\n        } else {\n          process.nextTick(function() {\n            var err = new Error(g.f('Invalid principal type: %s', type));\n            err.statusCode = 400;\n            err.code = 'INVALID_PRINCIPAL_TYPE';\n            cb(err);\n          });\n        }\n    }\n    return cb.promise;\n  };\n\n  /**\n   * Check if the given principal is mapped to the role\n   * @param {String} principalType Principal type\n   * @param {String|*} principalId Principal id/name\n   * @param {String|*} role Role id/name\n   * @callback {Function} callback Callback function\n   * @param {String|Error} err The error object\n   * @param {Boolean} isMapped is the ACL mapped to the role\n   */\n  ACL.isMappedToRole = function(principalType, principalId, role, cb) {\n    cb = cb || utils.createPromiseCallback();\n    var self = this;\n    this.resolvePrincipal(principalType, principalId,\n      function(err, principal) {\n        if (err) return cb(err);\n        if (principal != null) {\n          principalId = principal.id;\n        }\n        principalType = principalType || 'ROLE';\n        self.resolvePrincipal('ROLE', role, function(err, role) {\n          if (err || !role) return cb(err, role);\n          self.roleMappingModel.findOne({\n            where: {\n              roleId: role.id,\n              principalType: principalType,\n              principalId: String(principalId),\n            },\n          }, function(err, result) {\n            if (err) return cb(err);\n            return cb(null, !!result);\n          });\n        });\n      });\n    return cb.promise;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/scope.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar assert = require('assert');\nvar loopback = require('../../lib/loopback');\n\n/**\n * Resource owner grants/delegates permissions to client applications\n *\n * For a protected resource, does the client application have the authorization\n * from the resource owner (user or system)?\n *\n * Scope has many resource access entries\n *\n * @class Scope\n */\n\nmodule.exports = function(Scope) {\n  Scope.resolveRelatedModels = function() {\n    if (!this.aclModel) {\n      var reg = this.registry;\n      this.aclModel = reg.getModelByType(loopback.ACL);\n    }\n  };\n\n  /**\n   * Check if the given scope is allowed to access the model/property\n   * @param {String} scope The scope name\n   * @param {String} model The model name\n   * @param {String} property The property/method/relation name\n   * @param {String} accessType The access type\n   * @callback {Function} callback\n   * @param {String|Error} err The error object\n   * @param {AccessRequest} result The access permission\n   */\n  Scope.checkPermission = function(scope, model, property, accessType, callback) {\n    this.resolveRelatedModels();\n    var aclModel = this.aclModel;\n    assert(aclModel,\n      'ACL model must be defined before Scope.checkPermission is called');\n\n    this.findOne({where: {name: scope}}, function(err, scope) {\n      if (err) {\n        if (callback) callback(err);\n      } else {\n        aclModel.checkPermission(\n          aclModel.SCOPE, scope.id, model, property, accessType, callback);\n      }\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/change.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/*!\n * Module Dependencies.\n */\n\n'use strict';\nvar g = require('../../lib/globalize');\nvar PersistedModel = require('../../lib/loopback').PersistedModel;\nvar loopback = require('../../lib/loopback');\nvar utils = require('../../lib/utils');\nvar crypto = require('crypto');\nvar CJSON = {stringify: require('canonical-json')};\nvar async = require('async');\nvar assert = require('assert');\nvar debug = require('debug')('loopback:change');\n\n/**\n * Change list entry.\n *\n * @property {String} id Hash of the modelName and ID.\n * @property {String} rev The current model revision.\n * @property {String} prev The previous model revision.\n * @property {Number} checkpoint The current checkpoint at time of the change.\n * @property {String} modelName Model name.\n * @property {String} modelId Model ID.\n * @property {Object} settings Extends the `Model.settings` object.\n * @property {String} settings.hashAlgorithm Algorithm used to create cryptographic hash, used as argument\n * to [crypto.createHash](http://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm).  Default is sha1.\n * @property {Boolean} settings.ignoreErrors By default, when changes are rectified, an error will throw an exception.\n * However, if this setting is true, then errors will not throw exceptions.\n * @class Change\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(Change) {\n  /*!\n   * Constants\n   */\n\n  Change.UPDATE = 'update';\n  Change.CREATE = 'create';\n  Change.DELETE = 'delete';\n  Change.UNKNOWN = 'unknown';\n\n  /*!\n   * Conflict Class\n   */\n\n  Change.Conflict = Conflict;\n\n  /*!\n   * Setup the extended model.\n   */\n\n  Change.setup = function() {\n    PersistedModel.setup.call(this);\n    var Change = this;\n\n    Change.getter.id = function() {\n      var hasModel = this.modelName && this.modelId;\n      if (!hasModel) return null;\n\n      return Change.idForModel(this.modelName, this.modelId);\n    };\n  };\n  Change.setup();\n\n  /**\n   * Track the recent change of the given modelIds.\n   *\n   * @param  {String}   modelName\n   * @param  {Array}    modelIds\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Array} changes Changes that were tracked\n   */\n\n  Change.rectifyModelChanges = function(modelName, modelIds, callback) {\n    var Change = this;\n    var errors = [];\n\n    callback = callback || utils.createPromiseCallback();\n\n    var tasks = modelIds.map(function(id) {\n      return function(cb) {\n        Change.findOrCreateChange(modelName, id, function(err, change) {\n          if (err) return next(err);\n          change.rectify(next);\n        });\n\n        function next(err) {\n          if (err) {\n            err.modelName = modelName;\n            err.modelId = id;\n            errors.push(err);\n          }\n          cb();\n        }\n      };\n    });\n\n    async.parallel(tasks, function(err) {\n      if (err) return callback(err);\n      if (errors.length) {\n        var desc = errors\n          .map(function(e) {\n            return '#' + e.modelId + ' - ' + e.toString();\n          })\n          .join('\\n');\n\n        var msg = g.f('Cannot rectify %s changes:\\n%s', modelName, desc);\n        err = new Error(msg);\n        err.details = {errors: errors};\n        return callback(err);\n      }\n      callback();\n    });\n    return callback.promise;\n  };\n\n  /**\n   * Get an identifier for a given model.\n   *\n   * @param  {String} modelName\n   * @param  {String} modelId\n   * @return {String}\n   */\n\n  Change.idForModel = function(modelName, modelId) {\n    return this.hash([modelName, modelId].join('-'));\n  };\n\n  /**\n   * Find or create a change for the given model.\n   *\n   * @param  {String}   modelName\n   * @param  {String}   modelId\n   * @callback  {Function} callback\n   * @param {Error} err\n   * @param {Change} change\n   * @end\n   */\n\n  Change.findOrCreateChange = function(modelName, modelId, callback) {\n    assert(this.registry.findModel(modelName), modelName + ' does not exist');\n    callback = callback || utils.createPromiseCallback();\n    var id = this.idForModel(modelName, modelId);\n    var Change = this;\n\n    this.findById(id, function(err, change) {\n      if (err) return callback(err);\n      if (change) {\n        callback(null, change);\n      } else {\n        var ch = new Change({\n          id: id,\n          modelName: modelName,\n          modelId: modelId,\n        });\n        ch.debug('creating change');\n        Change.updateOrCreate(ch, callback);\n      }\n    });\n    return callback.promise;\n  };\n\n  /**\n   * Update (or create) the change with the current revision.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Change} change\n   */\n\n  Change.prototype.rectify = function(cb) {\n    var change = this;\n    var currentRev = this.rev;\n\n    change.debug('rectify change');\n\n    cb = cb || utils.createPromiseCallback();\n\n    const model = this.getModelCtor();\n    const id = this.getModelId();\n\n    model.findById(id, function(err, inst) {\n      if (err) return cb(err);\n\n      if (inst) {\n        inst.fillCustomChangeProperties(change, function() {\n          const rev = Change.revisionForInst(inst);\n          prepareAndDoRectify(rev);\n        });\n      } else {\n        prepareAndDoRectify(null);\n      }\n    });\n\n    return cb.promise;\n\n    function prepareAndDoRectify(rev) {\n      // avoid setting rev and prev to the same value\n      if (currentRev === rev) {\n        change.debug('rev and prev are equal (not updating anything)');\n        return cb(null, change);\n      }\n\n      // FIXME(@bajtos) Allow callers to pass in the checkpoint value\n      // (or even better - a memoized async function to get the cp value)\n      // That will enable `rectifyAll` to cache the checkpoint value\n      change.constructor.getCheckpointModel().current(\n        function(err, checkpoint) {\n          if (err) return cb(err);\n          doRectify(checkpoint, rev);\n        }\n      );\n    }\n\n    function doRectify(checkpoint, rev) {\n      if (rev) {\n        if (currentRev === rev) {\n          change.debug('ASSERTION FAILED: Change currentRev==rev ' +\n            'should have been already handled');\n          return cb(null, change);\n        } else {\n          change.rev = rev;\n          change.debug('updated revision (was ' + currentRev + ')');\n          if (change.checkpoint !== checkpoint) {\n            // previous revision is updated only across checkpoints\n            change.prev = currentRev;\n            change.debug('updated prev');\n          }\n        }\n      } else {\n        change.rev = null;\n        change.debug('updated revision (was ' + currentRev + ')');\n        if (change.checkpoint !== checkpoint) {\n          // previous revision is updated only across checkpoints\n          if (currentRev) {\n            change.prev = currentRev;\n          } else if (!change.prev) {\n            change.debug('ERROR - could not determine prev');\n            change.prev = Change.UNKNOWN;\n          }\n          change.debug('updated prev');\n        }\n      }\n\n      if (change.checkpoint != checkpoint) {\n        debug('update checkpoint to', checkpoint);\n        change.checkpoint = checkpoint;\n      }\n\n      if (change.prev === Change.UNKNOWN) {\n        // this occurs when a record of a change doesn't exist\n        // and its current revision is null (not found)\n        change.remove(cb);\n      } else {\n        change.save(cb);\n      }\n    }\n  };\n\n  /**\n   * Get a change's current revision based on current data.\n   * @callback  {Function} callback\n   * @param {Error} err\n   * @param {String} rev The current revision\n   */\n\n  Change.prototype.currentRevision = function(cb) {\n    cb = cb || utils.createPromiseCallback();\n    var model = this.getModelCtor();\n    var id = this.getModelId();\n    model.findById(id, function(err, inst) {\n      if (err) return cb(err);\n      if (inst) {\n        cb(null, Change.revisionForInst(inst));\n      } else {\n        cb(null, null);\n      }\n    });\n    return cb.promise;\n  };\n\n  /**\n   * Create a hash of the given `string` with the `options.hashAlgorithm`.\n   * **Default: `sha1`**\n   *\n   * @param  {String} str The string to be hashed\n   * @return {String}     The hashed string\n   */\n\n  Change.hash = function(str) {\n    return crypto\n      .createHash(Change.settings.hashAlgorithm || 'sha1')\n      .update(str)\n      .digest('hex');\n  };\n\n  /**\n   * Get the revision string for the given object\n   * @param  {Object} inst The data to get the revision string for\n   * @return {String}      The revision string\n   */\n\n  Change.revisionForInst = function(inst) {\n    assert(inst, 'Change.revisionForInst() requires an instance object.');\n    return this.hash(CJSON.stringify(inst));\n  };\n\n  /**\n   * Get a change's type. Returns one of:\n   *\n   * - `Change.UPDATE`\n   * - `Change.CREATE`\n   * - `Change.DELETE`\n   * - `Change.UNKNOWN`\n   *\n   * @return {String} the type of change\n   */\n\n  Change.prototype.type = function() {\n    if (this.rev && this.prev) {\n      return Change.UPDATE;\n    }\n    if (this.rev && !this.prev) {\n      return Change.CREATE;\n    }\n    if (!this.rev && this.prev) {\n      return Change.DELETE;\n    }\n    return Change.UNKNOWN;\n  };\n\n  /**\n   * Compare two changes.\n   * @param  {Change} change\n   * @return {Boolean}\n   */\n\n  Change.prototype.equals = function(change) {\n    if (!change) return false;\n    var thisRev = this.rev || null;\n    var thatRev = change.rev || null;\n    return thisRev === thatRev;\n  };\n\n  /**\n   * Does this change conflict with the given change.\n   * @param  {Change} change\n   * @return {Boolean}\n   */\n\n  Change.prototype.conflictsWith = function(change) {\n    if (!change) return false;\n    if (this.equals(change)) return false;\n    if (Change.bothDeleted(this, change)) return false;\n    if (this.isBasedOn(change)) return false;\n    return true;\n  };\n\n  /**\n   * Are both changes deletes?\n   * @param  {Change} a\n   * @param  {Change} b\n   * @return {Boolean}\n   */\n\n  Change.bothDeleted = function(a, b) {\n    return a.type() === Change.DELETE &&\n      b.type() === Change.DELETE;\n  };\n\n  /**\n   * Determine if the change is based on the given change.\n   * @param  {Change} change\n   * @return {Boolean}\n   */\n\n  Change.prototype.isBasedOn = function(change) {\n    return this.prev === change.rev;\n  };\n\n  /**\n   * Determine the differences for a given model since a given checkpoint.\n   *\n   * The callback will contain an error or `result`.\n   *\n   * **result**\n   *\n   * ```js\n   * {\n *   deltas: Array,\n *   conflicts: Array\n * }\n   * ```\n   *\n   * **deltas**\n   *\n   * An array of changes that differ from `remoteChanges`.\n   *\n   * **conflicts**\n   *\n   * An array of changes that conflict with `remoteChanges`.\n   *\n   * @param  {String}   modelName\n   * @param  {Number}   since         Compare changes after this checkpoint\n   * @param  {Change[]} remoteChanges A set of changes to compare\n   * @callback  {Function} callback\n   * @param {Error} err\n   * @param {Object} result See above.\n   */\n\n  Change.diff = function(modelName, since, remoteChanges, callback) {\n    callback = callback || utils.createPromiseCallback();\n\n    if (!Array.isArray(remoteChanges) || remoteChanges.length === 0) {\n      callback(null, {deltas: [], conflicts: []});\n      return callback.promise;\n    }\n    var remoteChangeIndex = {};\n    var modelIds = [];\n    remoteChanges.forEach(function(ch) {\n      modelIds.push(ch.modelId);\n      remoteChangeIndex[ch.modelId] = new Change(ch);\n    });\n\n    // normalize `since`\n    since = Number(since) || 0;\n    this.find({\n      where: {\n        modelName: modelName,\n        modelId: {inq: modelIds},\n      },\n    }, function(err, allLocalChanges) {\n      if (err) return callback(err);\n      var deltas = [];\n      var conflicts = [];\n      var localModelIds = [];\n\n      var localChanges = allLocalChanges.filter(function(c) {\n        return c.checkpoint >= since;\n      });\n\n      localChanges.forEach(function(localChange) {\n        localChange = new Change(localChange);\n        localModelIds.push(localChange.modelId);\n        var remoteChange = remoteChangeIndex[localChange.modelId];\n        if (remoteChange && !localChange.equals(remoteChange)) {\n          if (remoteChange.conflictsWith(localChange)) {\n            remoteChange.debug('remote conflict');\n            localChange.debug('local conflict');\n            conflicts.push(localChange);\n          } else {\n            remoteChange.debug('remote delta');\n            deltas.push(remoteChange);\n          }\n        }\n      });\n\n      modelIds.forEach(function(id) {\n        if (localModelIds.indexOf(id) !== -1) return;\n\n        var d = remoteChangeIndex[id];\n        var oldChange = allLocalChanges.filter(function(c) {\n          return c.modelId === id;\n        })[0];\n\n        if (oldChange) {\n          d.prev = oldChange.rev;\n        } else {\n          d.prev = null;\n        }\n\n        deltas.push(d);\n      });\n\n      callback(null, {\n        deltas: deltas,\n        conflicts: conflicts,\n      });\n    });\n    return callback.promise;\n  };\n\n  /**\n   * Correct all change list entries.\n   * @param {Function} cb\n   */\n\n  Change.rectifyAll = function(cb) {\n    debug('rectify all');\n    var Change = this;\n    // this should be optimized\n    this.find(function(err, changes) {\n      if (err) return cb(err);\n      async.each(\n        changes,\n        function(c, next) { c.rectify(next); },\n        cb);\n    });\n  };\n\n  /**\n   * Get the checkpoint model.\n   * @return {Checkpoint}\n   */\n\n  Change.getCheckpointModel = function() {\n    var checkpointModel = this.Checkpoint;\n    if (checkpointModel) return checkpointModel;\n    // FIXME(bajtos) This code creates multiple different models with the same\n    // model name, which is not a valid supported usage of juggler's API.\n    this.Checkpoint = checkpointModel = loopback.Checkpoint.extend('checkpoint');\n    assert(this.dataSource, 'Cannot getCheckpointModel(): ' + this.modelName +\n      ' is not attached to a dataSource');\n    checkpointModel.attachTo(this.dataSource);\n    return checkpointModel;\n  };\n\n  Change.prototype.debug = function() {\n    if (debug.enabled) {\n      var args = Array.prototype.slice.call(arguments);\n      args[0] = args[0] + ' %s';\n      args.push(this.modelName);\n      debug.apply(this, args);\n      debug('\\tid', this.id);\n      debug('\\trev', this.rev);\n      debug('\\tprev', this.prev);\n      debug('\\tcheckpoint', this.checkpoint);\n      debug('\\tmodelName', this.modelName);\n      debug('\\tmodelId', this.modelId);\n      debug('\\ttype', this.type());\n    }\n  };\n\n  /**\n   * Get the `Model` class for `change.modelName`.\n   * @return {Model}\n   */\n\n  Change.prototype.getModelCtor = function() {\n    return this.constructor.settings.trackModel;\n  };\n\n  Change.prototype.getModelId = function() {\n    // TODO(ritch) get rid of the need to create an instance\n    var Model = this.getModelCtor();\n    var id = this.modelId;\n    var m = new Model();\n    m.setId(id);\n    return m.getId();\n  };\n\n  Change.prototype.getModel = function(callback) {\n    var Model = this.constructor.settings.trackModel;\n    var id = this.getModelId();\n    Model.findById(id, callback);\n  };\n\n  /**\n   * When two changes conflict a conflict is created.\n   *\n   * **Note**: call `conflict.fetch()` to get the `target` and `source` models.\n   *\n   * @param {*} modelId\n   * @param {PersistedModel} SourceModel\n   * @param {PersistedModel} TargetModel\n   * @property {ModelClass} source The source model instance\n   * @property {ModelClass} target The target model instance\n   * @class Change.Conflict\n   */\n\n  function Conflict(modelId, SourceModel, TargetModel) {\n    this.SourceModel = SourceModel;\n    this.TargetModel = TargetModel;\n    this.SourceChange = SourceModel.getChangeModel();\n    this.TargetChange = TargetModel.getChangeModel();\n    this.modelId = modelId;\n  }\n\n  /**\n   * Fetch the conflicting models.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {PersistedModel} source\n   * @param {PersistedModel} target\n   */\n\n  Conflict.prototype.models = function(cb) {\n    var conflict = this;\n    var SourceModel = this.SourceModel;\n    var TargetModel = this.TargetModel;\n    var source, target;\n\n    async.parallel([\n      getSourceModel,\n      getTargetModel,\n    ], done);\n\n    function getSourceModel(cb) {\n      SourceModel.findById(conflict.modelId, function(err, model) {\n        if (err) return cb(err);\n        source = model;\n        cb();\n      });\n    }\n\n    function getTargetModel(cb) {\n      TargetModel.findById(conflict.modelId, function(err, model) {\n        if (err) return cb(err);\n        target = model;\n        cb();\n      });\n    }\n\n    function done(err) {\n      if (err) return cb(err);\n      cb(null, source, target);\n    }\n  };\n\n  /**\n   * Get the conflicting changes.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Change} sourceChange\n   * @param {Change} targetChange\n   */\n\n  Conflict.prototype.changes = function(cb) {\n    var conflict = this;\n    var sourceChange, targetChange;\n\n    async.parallel([\n      getSourceChange,\n      getTargetChange,\n    ], done);\n\n    function getSourceChange(cb) {\n      var SourceModel = conflict.SourceModel;\n      SourceModel.findLastChange(conflict.modelId, function(err, change) {\n        if (err) return cb(err);\n        sourceChange = change;\n        cb();\n      });\n    }\n\n    function getTargetChange(cb) {\n      var TargetModel = conflict.TargetModel;\n      TargetModel.findLastChange(conflict.modelId, function(err, change) {\n        if (err) return cb(err);\n        targetChange = change;\n        cb();\n      });\n    }\n\n    function done(err) {\n      if (err) return cb(err);\n      cb(null, sourceChange, targetChange);\n    }\n  };\n\n  /**\n   * Resolve the conflict.\n   *\n   * Set the source change's previous revision to the current revision of the\n   * (conflicting) target change. Since the changes are no longer conflicting\n   * and appear as if the source change was based on the target, they will be\n   * replicated normally as part of the next replicate() call.\n   *\n   * This is effectively resolving the conflict using the source version.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n\n  Conflict.prototype.resolve = function(cb) {\n    var conflict = this;\n    conflict.TargetModel.findLastChange(\n      this.modelId,\n      function(err, targetChange) {\n        if (err) return cb(err);\n        conflict.SourceModel.updateLastChange(\n          conflict.modelId,\n          {prev: targetChange.rev},\n          cb);\n      });\n  };\n\n  /**\n   * Resolve the conflict using the instance data in the source model.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n  Conflict.prototype.resolveUsingSource = function(cb) {\n    this.resolve(function(err) {\n      // don't forward any cb arguments from resolve()\n      cb(err);\n    });\n  };\n\n  /**\n   * Resolve the conflict using the instance data in the target model.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n  Conflict.prototype.resolveUsingTarget = function(cb) {\n    var conflict = this;\n\n    conflict.models(function(err, source, target) {\n      if (err) return done(err);\n      if (target === null) {\n        return conflict.SourceModel.deleteById(conflict.modelId, done);\n      }\n      var inst = new conflict.SourceModel(\n        target.toObject(),\n        {persisted: true});\n      inst.save(done);\n    });\n\n    function done(err) {\n      // don't forward any cb arguments from internal calls\n      cb(err);\n    }\n  };\n\n  /**\n   * Return a new Conflict instance with swapped Source and Target models.\n   *\n   * This is useful when resolving a conflict in one-way\n   * replication, where the source data must not be changed:\n   *\n   * ```js\n   * conflict.swapParties().resolveUsingTarget(cb);\n   * ```\n   *\n   * @returns {Conflict} A new Conflict instance.\n   */\n  Conflict.prototype.swapParties = function() {\n    var Ctor = this.constructor;\n    return new Ctor(this.modelId, this.TargetModel, this.SourceModel);\n  };\n\n  /**\n   * Resolve the conflict using the supplied instance data.\n   *\n   * @param {Object} data The set of changes to apply on the model\n   * instance. Use `null` value to delete the source instance instead.\n   * @callback {Function} callback\n   * @param {Error} err\n   */\n\n  Conflict.prototype.resolveManually = function(data, cb) {\n    var conflict = this;\n    if (!data) {\n      return conflict.SourceModel.deleteById(conflict.modelId, done);\n    }\n\n    conflict.models(function(err, source, target) {\n      if (err) return done(err);\n      var inst = source || new conflict.SourceModel(target);\n      inst.setAttributes(data);\n      inst.save(function(err) {\n        if (err) return done(err);\n        conflict.resolve(done);\n      });\n    });\n\n    function done(err) {\n      // don't forward any cb arguments from internal calls\n      cb(err);\n    }\n  };\n\n  /**\n   * Determine the conflict type.\n   *\n   * Possible results are\n   *\n   *  - `Change.UPDATE`: Source and target models were updated.\n   *  - `Change.DELETE`: Source and or target model was deleted.\n   *  - `Change.UNKNOWN`: the conflict type is uknown or due to an error.\n   *\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {String} type The conflict type.\n   */\n\n  Conflict.prototype.type = function(cb) {\n    var conflict = this;\n    this.changes(function(err, sourceChange, targetChange) {\n      if (err) return cb(err);\n      var sourceChangeType = sourceChange.type();\n      var targetChangeType = targetChange.type();\n      if (sourceChangeType === Change.UPDATE && targetChangeType === Change.UPDATE) {\n        return cb(null, Change.UPDATE);\n      }\n      if (sourceChangeType === Change.DELETE || targetChangeType === Change.DELETE) {\n        return cb(null, Change.DELETE);\n      }\n      return cb(null, Change.UNKNOWN);\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/common/models/checkpoint.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/**\n * Module Dependencies.\n */\n\n'use strict';\nvar assert = require('assert');\n\n/**\n * Checkpoint list entry.\n *\n * @property id {Number} the sequencial identifier of a checkpoint\n * @property time {Number} the time when the checkpoint was created\n * @property sourceId {String}  the source identifier\n *\n * @class Checkpoint\n * @inherits {PersistedModel}\n */\n\nmodule.exports = function(Checkpoint) {\n  // Workaround for https://github.com/strongloop/loopback/issues/292\n  Checkpoint.definition.rawProperties.time.default =\n    Checkpoint.definition.properties.time.default = function() {\n      return new Date();\n    };\n\n  /**\n   * Get the current checkpoint id\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Number} checkpoint The current checkpoint seq\n   */\n  Checkpoint.current = function(cb) {\n    var Checkpoint = this;\n    Checkpoint._getSingleton(function(err, cp) {\n      cb(err, cp.seq);\n    });\n  };\n\n  Checkpoint._getSingleton = function(cb) {\n    var query = {limit: 1}; // match all instances, return only one\n    var initialData = {seq: 1};\n    this.findOrCreate(query, initialData, cb);\n  };\n\n  /**\n   * Increase the current checkpoint if it already exists otherwise initialize it\n   * @callback {Function} callback\n   * @param {Error} err\n   * @param {Object} checkpoint The current checkpoint\n   */\n  Checkpoint.bumpLastSeq = function(cb) {\n    var Checkpoint = this;\n    Checkpoint._getSingleton(function(err, cp) {\n      if (err) return cb(err);\n      var originalSeq = cp.seq;\n      cp.seq++;\n      // Update the checkpoint but only if it was not changed under our hands\n      Checkpoint.updateAll({id: cp.id, seq: originalSeq}, {seq: cp.seq}, function(err, info) {\n        if (err) return cb(err);\n        // possible outcomes\n        // 1) seq was updated to seq+1 - exactly what we wanted!\n        // 2) somebody else already updated seq to seq+1 and our call was a no-op.\n        //   That should be ok, checkpoints are time based, so we reuse the one created just now\n        //  3) seq was bumped more than once, so we will be using a value that is behind the latest seq.\n        //    @bajtos is not entirely sure if this is ok, but since it wasn't handled by the current implementation either,\n        //    he thinks we can keep it this way.\n        cb(null, cp);\n      });\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/connectors/base-connector.js":"// Copyright IBM Corp. 2013,2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/**\n * Expose `Connector`.\n */\n\n'use strict';\nmodule.exports = Connector;\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('connector');\nvar util = require('util');\nvar inherits = util.inherits;\nvar assert = require('assert');\n\n/**\n * Create a new `Connector` with the given `options`.\n *\n * @param {Object} options\n * @return {Connector}\n */\n\nfunction Connector(options) {\n  EventEmitter.apply(this, arguments);\n  this.options = options;\n\n  debug('created with options', options);\n}\n\n/**\n * Inherit from `EventEmitter`.\n */\n\ninherits(Connector, EventEmitter);\n\n/*!\n * Create an connector instance from a JugglingDB adapter.\n */\n\nConnector._createJDBAdapter = function(jdbModule) {\n  var fauxSchema = {};\n  jdbModule.initialize(fauxSchema, function() {\n    // connected\n  });\n};\n\n/*!\n * Add default crud operations from a JugglingDB adapter.\n */\n\nConnector.prototype._addCrudOperationsFromJDBAdapter = function(connector) {\n\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/connectors/memory.js":"// Copyright IBM Corp. 2013,2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/**\n * Expose `Memory`.\n */\n\n'use strict';\nmodule.exports = Memory;\n\n/**\n * Module dependencies.\n */\n\nvar Connector = require('./base-connector');\nvar debug = require('debug')('memory');\nvar util = require('util');\nvar inherits = util.inherits;\nvar assert = require('assert');\nvar JdbMemory = require('loopback-datasource-juggler/lib/connectors/memory');\n\n/**\n * Create a new `Memory` connector with the given `options`.\n *\n * @param {Object} options\n * @return {Memory}\n */\n\nfunction Memory() {\n  // TODO implement entire memory connector\n}\n\n/**\n * Inherit from `DBConnector`.\n */\n\ninherits(Memory, Connector);\n\n/**\n * JugglingDB Compatibility\n */\n\nMemory.initialize = JdbMemory.initialize;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/connectors/mail.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/**\n * Dependencies.\n */\n\n'use strict';\nvar g = require('../globalize');\nvar mailer = require('nodemailer');\nvar assert = require('assert');\nvar debug = require('debug')('loopback:connector:mail');\nvar loopback = require('../loopback');\n\n/**\n * Export the MailConnector class.\n */\n\nmodule.exports = MailConnector;\n\n/**\n * Create an instance of the connector with the given `settings`.\n */\n\nfunction MailConnector(settings) {\n  assert(typeof settings === 'object', 'cannot initialize MailConnector without a settings object');\n\n  var transports = settings.transports;\n\n  // if transports is not in settings object AND settings.transport exists\n  if (!transports && settings.transport) {\n    // then wrap single transport in an array and assign to transports\n    transports = [settings.transport];\n  }\n\n  if (!transports) {\n    transports = [];\n  }\n\n  this.transportsIndex = {};\n  this.transports = [];\n\n  if (loopback.isServer) {\n    transports.forEach(this.setupTransport.bind(this));\n  }\n}\n\nMailConnector.initialize = function(dataSource, callback) {\n  dataSource.connector = new MailConnector(dataSource.settings);\n  callback();\n};\n\nMailConnector.prototype.DataAccessObject = Mailer;\n\n/**\n * Add a transport to the available transports. See https://github.com/andris9/Nodemailer#setting-up-a-transport-method.\n *\n * Example:\n *\n *   Email.setupTransport({\n *       type: \"SMTP\",\n *       host: \"smtp.gmail.com\", // hostname\n *       secureConnection: true, // use SSL\n *       port: 465, // port for secure SMTP\n *       alias: \"gmail\", // optional alias for use with 'transport' option when sending\n *       auth: {\n *           user: \"gmail.user@gmail.com\",\n *           pass: \"userpass\"\n *       }\n *   });\n *\n */\n\nMailConnector.prototype.setupTransport = function(setting) {\n  var connector = this;\n  connector.transports = connector.transports || [];\n  connector.transportsIndex = connector.transportsIndex || {};\n\n  var transport;\n  var transportType = (setting.type || 'STUB').toLowerCase();\n  if (transportType === 'direct') {\n    transport = mailer.createTransport();\n  } else if (transportType === 'smtp') {\n    transport = mailer.createTransport(setting);\n  } else {\n    var transportModuleName = 'nodemailer-' + transportType + '-transport';\n    var transportModule = require(transportModuleName);\n    transport = mailer.createTransport(transportModule(setting));\n  }\n\n  connector.transportsIndex[setting.alias || setting.type] = transport;\n  connector.transports.push(transport);\n};\n\nfunction Mailer() {\n\n}\n\n/**\n * Get a transport by name.\n *\n * @param {String} name\n * @return {Transport} transport\n */\n\nMailConnector.prototype.transportForName = function(name) {\n  return this.transportsIndex[name];\n};\n\n/**\n * Get the default transport.\n *\n * @return {Transport} transport\n */\n\nMailConnector.prototype.defaultTransport = function() {\n  return this.transports[0] || this.stubTransport;\n};\n\n/**\n * Send an email with the given `options`.\n *\n * Example Options:\n *\n * {\n *   from: \"Fred Foo  <foo@blurdybloop.com>\", // sender address\n *   to: \"bar@blurdybloop.com, baz@blurdybloop.com\", // list of receivers\n *   subject: \"Hello \", // Subject line\n *   text: \"Hello world \", // plaintext body\n *   html: \"<b>Hello world </b>\", // html body\n *   transport: \"gmail\", // See 'alias' option above in setupTransport\n * }\n *\n * See https://github.com/andris9/Nodemailer for other supported options.\n *\n * @param {Object} options\n * @param {Function} callback Called after the e-mail is sent or the sending failed\n */\n\nMailer.send = function(options, fn) {\n  var dataSource = this.dataSource;\n  var settings = dataSource && dataSource.settings;\n  var connector = dataSource.connector;\n  assert(connector, 'Cannot send mail without a connector!');\n\n  var transport = connector.transportForName(options.transport);\n\n  if (!transport) {\n    transport = connector.defaultTransport();\n  }\n\n  if (debug.enabled || settings && settings.debug) {\n    g.log('Sending Mail:');\n    if (options.transport) {\n      console.log(g.f('\\t TRANSPORT:%s', options.transport));\n    }\n    g.log('\\t TO:%s', options.to);\n    g.log('\\t FROM:%s', options.from);\n    g.log('\\t SUBJECT:%s', options.subject);\n    g.log('\\t TEXT:%s', options.text);\n    g.log('\\t HTML:%s', options.html);\n  }\n\n  if (transport) {\n    assert(transport.sendMail,\n      'You must supply an Email.settings.transports containing a valid transport');\n    transport.sendMail(options, fn);\n  } else {\n    g.warn('Warning: No email transport specified for sending email.' +\n      ' Setup a transport to send mail messages.');\n    process.nextTick(function() {\n      fn(null, options);\n    });\n  }\n};\n\n/**\n * Send an email instance using `modelInstance.send()`.\n */\n\nMailer.prototype.send = function(fn) {\n  this.constructor.send(this, fn);\n};\n\n/**\n * Access the node mailer object.\n */\n\nMailConnector.mailer =\nMailConnector.prototype.mailer =\nMailer.mailer =\nMailer.prototype.mailer = mailer;\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector-remote/index.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback-connector-remote\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nmodule.exports = require('./lib/remote-connector');","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector-remote/lib/remote-connector.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector-remote\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\n/**\n * Dependencies.\n */\n\nvar assert = require('assert');\nvar remoting = require('strong-remoting');\nvar utils = require('loopback-datasource-juggler/lib/utils');\nvar jutil = require('loopback-datasource-juggler/lib/jutil');\nvar RelationMixin = require('./relations');\nvar InclusionMixin = require('loopback-datasource-juggler/lib/include');\n\n/**\n * Export the RemoteConnector class.\n */\n\nmodule.exports = RemoteConnector;\n\n/**\n * Create an instance of the connector with the given `settings`.\n */\n\nfunction RemoteConnector(settings) {\n  assert(typeof settings ===\n    'object',\n    'cannot initiaze RemoteConnector without a settings object');\n  this.client = settings.client;\n  this.adapter = settings.adapter || 'rest';\n  this.protocol = settings.protocol || 'http';\n  this.root = settings.root || '';\n  this.host = settings.host || 'localhost';\n  this.port = settings.port || 3000;\n  this.remotes = remoting.create();\n  this.name = 'remote-connector';\n\n  if (settings.url) {\n    this.url = settings.url;\n  } else {\n    this.url = this.protocol + '://' + this.host + ':' + this.port + this.root;\n  }\n\n  // handle mixins in the define() method\n  var DAO = this.DataAccessObject = function() {\n  };\n\n}\n\nRemoteConnector.prototype.connect = function() {\n  this.remotes.connect(this.url, this.adapter);\n};\n\nRemoteConnector.initialize = function(dataSource, callback) {\n  var connector = dataSource.connector =\n    new RemoteConnector(dataSource.settings);\n  connector.connect();\n  process.nextTick(callback);\n};\n\nRemoteConnector.prototype.define = function(definition) {\n  var Model = definition.model;\n  var remotes = this.remotes;\n\n  assert(Model.sharedClass,\n      'cannot attach ' +\n      Model.modelName +\n      ' to a remote connector without a Model.sharedClass');\n\n  jutil.mixin(Model, RelationMixin);\n  jutil.mixin(Model, InclusionMixin);\n  remotes.addClass(Model.sharedClass);\n  this.resolve(Model);\n};\n\nRemoteConnector.prototype.resolve = function(Model) {\n  var remotes = this.remotes;\n\n  Model.sharedClass.methods().forEach(function(remoteMethod) {\n    if (remoteMethod.name !== 'Change' && remoteMethod.name !== 'Checkpoint') {\n      createProxyMethod(Model, remotes, remoteMethod);\n    }\n  });\n\n  // setup a remoting type converter for this model\n  remotes.defineObjectType(Model.modelName, function(data) {\n    return new Model(data);\n  });\n};\n\nfunction createProxyMethod(Model, remotes, remoteMethod) {\n  var scope = remoteMethod.isStatic ? Model : Model.prototype;\n  var original = scope[remoteMethod.name];\n\n  function remoteMethodProxy() {\n    var args = Array.prototype.slice.call(arguments);\n    var lastArgIsFunc = typeof args[args.length - 1] === 'function';\n    var callback;\n    if (lastArgIsFunc) {\n      callback = args.pop();\n    } else {\n      callback = utils.createPromiseCallback();\n    }\n\n    if (remoteMethod.isStatic) {\n      remotes.invoke(remoteMethod.stringName, args, callback);\n    } else {\n      var ctorArgs = [this.id];\n      remotes.invoke(remoteMethod.stringName, ctorArgs, args, callback);\n    }\n\n    return callback.promise;\n  }\n\n  scope[remoteMethod.name] = remoteMethodProxy;\n  remoteMethod.aliases.forEach(function(alias) {\n    scope[alias] = remoteMethodProxy;\n  });\n}\n\nfunction noop() {\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback-connector-remote/lib/relations.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-connector-remote\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\n/*!\n * Dependencies\n */\nvar relation = require('loopback-datasource-juggler/lib/relation-definition');\nvar RelationDefinition = relation.RelationDefinition;\n\nmodule.exports = RelationMixin;\n\n/**\n * RelationMixin class.  Use to define relationships between models.\n *\n * @class RelationMixin\n */\nfunction RelationMixin() {\n}\n\n/**\n * Define a \"one to many\" relationship by specifying the model name\n *\n * Examples:\n * ```\n * User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});\n * ```\n *\n * ```\n * Book.hasMany(Chapter);\n * ```\n * Or, equivalently:\n * ```\n * Book.hasMany('chapters', {model: Chapter});\n * ```\n *\n * Query and create related models:\n *\n * ```js\n * Book.create(function(err, book) {\n *\n *   // Create a chapter instance ready to be saved in the data source.\n *   var chapter = book.chapters.build({name: 'Chapter 1'});\n *\n *   // Save the new chapter\n *   chapter.save();\n *\n *  // you can also call the Chapter.create method with the `chapters` property\n *  // which will build a chapter instance and save the it in the data source.\n *  book.chapters.create({name: 'Chapter 2'}, function(err, savedChapter) {\n *  // this callback is optional\n *  });\n *\n *   // Query chapters for the book\n *   book.chapters(function(err, chapters) {\n *     // all chapters with bookId = book.id\n *     console.log(chapters);\n *   });\n *\n *   book.chapters({where: {name: 'test'}, function(err, chapters) {\n *    // All chapters with bookId = book.id and name = 'test'\n *     console.log(chapters);\n *   });\n * });\n *```\n * @param {Object|String} modelTo Model object (or String name of model) to\n *    which you are creating the relationship.\n * @options {Object} parameters Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n *    corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationMixin.hasMany = function hasMany(modelTo, params) {\n  var def = RelationDefinition.hasMany(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\n/**\n * Declare \"belongsTo\" relation that sets up a one-to-one connection with\n * another model, such that each instance of the declaring model \"belongs\n * to\" one instance of the other model.\n *\n * For example, if an application includes users and posts, and each post can be\n * written by exactly one user. The following code specifies that `Post` has a\n * reference called `author` to the `User` model via the `userId` property of\n * `Post` as the foreign key.\n * ```\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n * ```\n * You can then access the author in one of the following styles.\n * Get the User object for the post author asynchronously:\n * ```\n * post.author(callback);\n * ```\n * Get the User object for the post author synchronously:\n * ```\n * post.author();\n * Set the author to be the given user:\n * ```\n * post.author(user)\n * ```\n * Examples:\n *\n * Suppose the model Post has a *belongsTo* relationship with User (the author\n * of the post). You could declare it this way:\n * ```js\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n * ```\n *\n * When a post is loaded, you can load the related author with:\n * ```js\n * post.author(function(err, user) {\n *     // the user variable is your user object\n * });\n * ```\n *\n * The related object is cached, so if later you try to get again the author, no\n * additional request will be made. But there is an optional boolean parameter\n * in first position that set whether or not you want to reload the cache:\n * ```js\n * post.author(true, function(err, user) {\n *     // The user is reloaded, even if it was already cached.\n * });\n * ```\n * This optional parameter default value is false, so the related object will\n * be loaded from cache if available.\n *\n * @param {Class|String} modelTo Model object (or String name of model)\n *    to which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n *    corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Name of foreign key property.\n *\n */\nRelationMixin.belongsTo = function(modelTo, params) {\n  var def = RelationDefinition.belongsTo(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\n/**\n * A hasAndBelongsToMany relation creates a direct many-to-many connection with\n * another model, with no intervening model. For example, if your application\n * includes users and groups, with each group having many users and each user\n * appearing in many groups, you could declare the models this way:\n * ```\n *  User.hasAndBelongsToMany('groups', {model: Group, foreignKey: 'groupId'});\n * ```\n *  Then, to get the groups to which the user belongs:\n * ```\n *  user.groups(callback);\n * ```\n *  Create a new group and connect it with the user:\n * ```\n *  user.groups.create(data, callback);\n * ```\n *  Connect an existing group with the user:\n * ```\n *  user.groups.add(group, callback);\n * ```\n *  Remove the user from the group:\n * ```\n *  user.groups.remove(group, callback);\n * ```\n *\n * @param {String|Object} modelTo Model object (or String name of model) to\n *    which you are creating the relationship.\n * @options {Object} params Configuration parameters; see below.\n * @property {String} as Name of the property in the referring model that\n *    corresponds to the foreign key field in the related model.\n * @property {String} foreignKey Property name of foreign key field.\n * @property {Object} model Model object\n */\nRelationMixin.hasAndBelongsToMany =\n  function hasAndBelongsToMany(modelTo, params) {\n    var def = RelationDefinition.hasAndBelongsToMany(this, modelTo, params);\n    this.dataSource.adapter.resolve(this);\n    defineRelationProperty(this, def);\n  };\n\nRelationMixin.hasOne = function hasOne(modelTo, params) {\n  var def = RelationDefinition.hasOne(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\nRelationMixin.referencesMany = function referencesMany(modelTo, params) {\n  var def = RelationDefinition.referencesMany(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\nRelationMixin.embedsOne = function embedsOne(modelTo, params) {\n  var def = RelationDefinition.embedsOne(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\nRelationMixin.embedsMany = function embedsMany(modelTo, params) {\n  var def = RelationDefinition.embedsMany(this, modelTo, params);\n  this.dataSource.adapter.resolve(this);\n  defineRelationProperty(this, def);\n};\n\nfunction defineRelationProperty(modelClass, def) {\n  Object.defineProperty(modelClass.prototype, def.name, {\n    get: function() {\n      var that = this;\n      var scope = function() {\n        return that['__get__' + def.name].apply(that, arguments);\n      };\n      scope.count = function() {\n        return that['__count__' + def.name].apply(that, arguments);\n      };\n      scope.create = function() {\n        return that['__create__' + def.name].apply(that, arguments);\n      };\n      scope.deleteById = scope.destroyById = function() {\n        return that['__destroyById__' + def.name].apply(that, arguments);\n      };\n      scope.exists = function() {\n        return that['__exists__' + def.name].apply(that, arguments);\n      };\n      scope.findById = function() {\n        return that['__findById__' + def.name].apply(that, arguments);\n      };\n      return scope;\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/Gruntfile.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n/* global module:false */\n'use strict';\nmodule.exports = function(grunt) {\n  // Do not report warnings from unit-tests exercising deprecated paths\n  process.env.NO_DEPRECATION = 'loopback';\n\n  grunt.loadNpmTasks('grunt-mocha-test');\n\n  // Project configuration.\n  grunt.initConfig({\n    // Metadata.\n    pkg: grunt.file.readJSON('package.json'),\n    banner: '/*! <%= pkg.title || pkg.name %> - v<%= pkg.version %> - ' +\n      '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\n' +\n      '<%= pkg.homepage ? \"* \" + pkg.homepage + \"\\\\n\" : \"\" %>' +\n      '* Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author.name %>;' +\n      ' Licensed <%= _.pluck(pkg.licenses, \"type\").join(\", \") %> */\\n',\n    // Task configuration.\n    uglify: {\n      options: {\n        banner: '<%= banner %>',\n      },\n      dist: {\n        files: {\n          'dist/loopback.min.js': ['dist/loopback.js'],\n        },\n      },\n    },\n    eslint: {\n      gruntfile: {\n        src: 'Gruntfile.js',\n      },\n      lib: {\n        src: ['lib/**/*.js'],\n      },\n      common: {\n        src: ['common/**/*.js'],\n      },\n      server: {\n        src: ['server/**/*.js'],\n      },\n      test: {\n        src: ['test/**/*.js'],\n      },\n    },\n    watch: {\n      gruntfile: {\n        files: '<%= eslint.gruntfile.src %>',\n        tasks: ['eslint:gruntfile'],\n      },\n      browser: {\n        files: ['<%= eslint.browser.src %>'],\n        tasks: ['eslint:browser'],\n      },\n      common: {\n        files: ['<%= eslint.common.src %>'],\n        tasks: ['eslint:common'],\n      },\n      lib: {\n        files: ['<%= eslint.lib.src %>'],\n        tasks: ['eslint:lib'],\n      },\n      server: {\n        files: ['<%= eslint.server.src %>'],\n        tasks: ['eslint:server'],\n      },\n      test: {\n        files: ['<%= eslint.test.src %>'],\n        tasks: ['eslint:test'],\n      },\n    },\n    browserify: {\n      dist: {\n        files: {\n          'dist/loopback.js': ['index.js'],\n        },\n        options: {\n          ignore: ['nodemailer', 'passport', 'bcrypt'],\n          standalone: 'loopback',\n        },\n      },\n    },\n    mochaTest: {\n      'unit': {\n        src: 'test/*.js',\n        options: {\n          reporter: 'dot',\n          require: require.resolve('./test/helpers/use-english.js'),\n        },\n      },\n      'unit-xml': {\n        src: 'test/*.js',\n        options: {\n          reporter: 'xunit',\n          captureFile: 'xunit.xml',\n        },\n      },\n    },\n    karma: {\n      'unit-once': {\n        configFile: 'test/karma.conf.js',\n        browsers: ['PhantomJS'],\n        singleRun: true,\n        reporters: ['dots', 'junit'],\n\n        // increase the timeout for slow build slaves (e.g. Travis-ci)\n        browserNoActivityTimeout: 30000,\n\n        // CI friendly test output\n        junitReporter: {\n          outputFile: 'karma-xunit.xml',\n        },\n\n        browserify: {\n          // Disable sourcemaps to prevent\n          // Fatal error: Maximum call stack size exceeded\n          debug: false,\n          // Disable watcher, grunt will exit after the first run\n          watch: false,\n        },\n      },\n      unit: {\n        configFile: 'test/karma.conf.js',\n      },\n      e2e: {\n        options: {\n          // base path, that will be used to resolve files and exclude\n          basePath: '',\n\n          // frameworks to use\n          frameworks: ['mocha', 'browserify'],\n\n          // list of files / patterns to load in the browser\n          files: [\n            'test/e2e/remote-connector.e2e.js',\n            'test/e2e/replication.e2e.js',\n          ],\n\n          // list of files to exclude\n          exclude: [\n\n          ],\n\n          // test results reporter to use\n          // possible values: 'dots', 'progress', 'junit', 'growl', 'coverage'\n          reporters: ['dots'],\n\n          // web server port\n          port: 9876,\n\n          // cli runner port\n          runnerPort: 9100,\n\n          // enable / disable colors in the output (reporters and logs)\n          colors: true,\n\n          // level of logging\n          // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n          logLevel: 'warn',\n\n          // enable / disable watching file and executing tests whenever any file changes\n          autoWatch: true,\n\n          // Start these browsers, currently available:\n          // - Chrome\n          // - ChromeCanary\n          // - Firefox\n          // - Opera\n          // - Safari (only Mac)\n          // - PhantomJS\n          // - IE (only Windows)\n          browsers: [\n            'Chrome',\n          ],\n\n          // If browser does not capture in given timeout [ms], kill it\n          captureTimeout: 60000,\n\n          // Continuous Integration mode\n          // if true, it capture browsers, run tests and exit\n          singleRun: false,\n\n          // Browserify config (all optional)\n          browserify: {\n            // extensions: ['.coffee'],\n            ignore: [\n              'nodemailer',\n              'passport',\n              'passport-local',\n              'superagent',\n              'supertest',\n              'bcrypt',\n            ],\n            // transform: ['coffeeify'],\n            // debug: true,\n            // noParse: ['jquery'],\n            watch: true,\n          },\n\n          // Add browserify to preprocessors\n          preprocessors: {'test/e2e/*': ['browserify']},\n        },\n      },\n    },\n\n  });\n\n  // These plugins provide necessary tasks.\n  grunt.loadNpmTasks('grunt-browserify');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-eslint');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  grunt.loadNpmTasks('grunt-karma');\n\n  grunt.registerTask('e2e-server', function() {\n    var done = this.async();\n    var app = require('./test/fixtures/e2e/app');\n    app.listen(0, function() {\n      process.env.PORT = this.address().port;\n      done();\n    });\n  });\n\n  grunt.registerTask('skip-karma-on-windows', function() {\n    console.log('*** SKIPPING PHANTOM-JS BASED TESTS ON WINDOWS ***');\n  });\n\n  grunt.registerTask('e2e', ['e2e-server', 'karma:e2e']);\n\n  // Default task.\n  grunt.registerTask('default', ['browserify']);\n\n  grunt.registerTask('test', [\n    'eslint',\n    process.env.JENKINS_HOME ? 'mochaTest:unit-xml' : 'mochaTest:unit',\n    process.env.JENKINS_HOME && /^win/.test(process.platform) ?\n      'skip-karma-on-windows' : 'karma:unit-once',\n  ]);\n\n  // alias for sl-ci-run and `npm test`\n  grunt.registerTask('mocha-and-karma', ['test']);\n};\n","/home/travis/build/npmtest/node-npmtest-loopback/node_modules/loopback/lib/browser-express.js":"// Copyright IBM Corp. 2014. All Rights Reserved.\n// Node module: loopback\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nmodule.exports = browserExpress;\n\nfunction browserExpress() {\n  return new BrowserExpress();\n}\n\nbrowserExpress.errorHandler = {};\n\nfunction BrowserExpress() {\n  this.settings = {};\n}\n\nutil.inherits(BrowserExpress, EventEmitter);\n\nBrowserExpress.prototype.set = function(key, value) {\n  if (arguments.length == 1) {\n    return this.get(key);\n  }\n\n  this.settings[key] = value;\n\n  return this; // fluent API\n};\n\nBrowserExpress.prototype.get = function(key) {\n  return this.settings[key];\n};\n"}